<!DOCTYPE html>





<html lang="zh-tw">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.9.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/myblog/images/apple-touch-icon-next.png?v=7.4.1">
  <link rel="icon" type="image/png" sizes="32x32" href="/myblog/images/favicon-32x32-next.png?v=7.4.1">
  <link rel="icon" type="image/png" sizes="16x16" href="/myblog/images/favicon-16x16-next.png?v=7.4.1">
  <link rel="mask-icon" href="/myblog/images/logo.svg?v=7.4.1" color="#222">

<link rel="stylesheet" href="/myblog/css/main.css?v=7.4.1">


<link rel="stylesheet" href="/myblog/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/myblog/',
    scheme: 'Pisces',
    version: '7.4.1',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: 'Copy',
      copy_success: 'Copied',
      copy_failure: 'Copy failed'
    },
    sidebarPadding: 40
  };
</script>

  <meta name="keywords" content="JavaScript, React, d3, NodeJS, Web">
<meta property="og:type" content="website">
<meta property="og:title" content="Jinny&#39;s blog">
<meta property="og:url" content="https://chinyun.github.io/myblog/index.html">
<meta property="og:site_name" content="Jinny&#39;s blog">
<meta property="og:locale" content="zh-tw">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Jinny&#39;s blog">
  <link rel="canonical" href="https://chinyun.github.io/myblog/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false,
    isPage: false,
    isArchive: false
  };
</script>

  <title>Jinny's blog</title>
  








  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-tw">
  <div class="container use-motion">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/myblog/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Jinny's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">Writing For Sharing</p>
      
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
      
      
      
        
        <li class="menu-item menu-item-home">
      
    

    <a href="/myblog/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-archives">
      
    

    <a href="/myblog/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
            

          <div id="content" class="content">
            
  <div id="posts" class="posts-expand">
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="https://chinyun.github.io/myblog/myblog/2019/11/11/JS-Class/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="chinyun">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/myblog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jinny's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/myblog/2019/11/11/JS-Class/" class="post-title-link" itemprop="url">JS Class</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-11-11 18:30:54 / Modified: 12:44:14" itemprop="dateCreated datePublished" datetime="2019-11-11T18:30:54+00:00">2019-11-11</time>
            </span>
          
            

            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="JavaScript-Class"><a href="#JavaScript-Class" class="headerlink" title="JavaScript Class"></a>JavaScript Class</h1><p>In Object-oriented programming, a class is an extensible program-code-template for creating objects, providing initial values for state(member variables) and implementations of behavior(member functions or methods).class 是一種可以拓展的編程模板，用來創建對象(object)，提供狀態初始值(變量)和行為實現(函數或方法)。</p>
<p>JavaScript 雖然具有物件導向程式語言的特性，但與 Java、C++ 等以類別為基礎的程式設計規範不同，JavaScript 是一種以原型(prototype-based)為基礎的語言。</p>
<p>由於開發上經常需要創建許多相似類型的對象(object)，例如針對 users、goods等。在 JavaScript 中，可以用構造函數(Constructor)和 operator “new” 來達成這個使用目的，但在 ES6 中有一個更進階的用法叫做 “Class”。</p>
<p>ECMAScript 6 中引入了類別 (class) 作為 JavaScript 現有原型程式(prototype-based)繼承的語法糖。語法糖可以讓現有語法操作變得更容易。類別 (class)語法並不是要引入新的物件導向繼承模型到 JavaScript 中，而是提供一個更簡潔的語法來建立物件和處理繼承。</p>
<p>Class 允許使用更簡潔的結構語法來定義 prototype-based 的類別。在 prototype-based 類別中，所有 methods 都存在 prototype 屬性中，藉以與其他延伸出去的類別共用，如此可以節省 memory 空間。<br>比較傳統原型繼承的寫法和使用 class 的寫法會發現，class 省略了 prototype chaining 並且整個 class 的宣告定義集中描述在 class 區塊內，幫助讀者了解這段程式的作用範圍，使 class 的目的更為清楚。</p>
<ul>
<li><p>Constructor 構造函數</p>
<ul>
<li>是一種常規函數，函數名稱首字必須大寫</li>
<li>創建時必須使用 new 來操作</li>
<li>需在 prototype 物件上定義方法</li>
<li>示範：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function User(name) &#123;</span><br><span class="line">  this.name = name;</span><br><span class="line">  this.isAdmin = false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">User.prototype.sayHi = function() &#123;</span><br><span class="line">  console.log(this.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let user = new User(&quot;Jack&quot;); // 創建一個 User Constructor</span><br><span class="line"></span><br><span class="line">alert(user.name); -&gt; Jack</span><br><span class="line">alert(user.isAdmin); -&gt; false</span><br><span class="line">user.sayHi() -&gt; Jack</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>當一個函數作為 new User(…)執行時，它執行以下步驟：</p>
<ol>
<li>一個新的空對像被創建並分配給 this。</li>
<li>函數體執行。通常它會修改 this，為其添加新的屬性。</li>
<li>返回 this 的值。<br>所以 new User(“Jack”) 的结果是相同的對象。</li>
</ol>
</li>
</ul>
<ul>
<li><p>Class</p>
<ul>
<li>使用 constructor() 建構子來定義初始狀態，而且創建時也必須使用 new 來操作。<br>建構子(constructor)方法是一個特別的方法，用來建立和初始化一個類別的物件，一個類別只能有一個建構子(constructor)。<br>Class 的 constructor()函數是默認的 method，即使沒有寫出來也會自動生成一個默認的空構造函數，並加入到 class.prototype上。<br>class syntax：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class User &#123;</span><br><span class="line">  constructor(name) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  sayHi() &#123;</span><br><span class="line">    alert(this.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">let user = new User(&quot;John&quot;);</span><br><span class="line">user.sayHi();</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>此時 User.prototype 包括 constructor 和 sayHi 兩個 methods。</p>
<ul>
<li><p>class expression 像一般 function 一樣，也可以寫作沒有名稱的表達式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">let User = class &#123;</span><br><span class="line">  sayHi() &#123;</span><br><span class="line">    alert(&quot;Hello&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function makeClass(phrase) &#123;</span><br><span class="line">  // 返回並宣告一個 class</span><br><span class="line">  return class &#123;  </span><br><span class="line">    sayHi() &#123;</span><br><span class="line">      alert(phrase);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">let User = makeClass(&quot;Hello&quot;);</span><br><span class="line"></span><br><span class="line">new User().sayHi(); // Hello</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 extend() 以及 super()來繼承父類的參數給子類。<br>關鍵字 extends 是在類別宣告或是類別敘述中建立子類別的方法。若在子類別中有建構子(constructor)，要使用this前則必須先呼叫super()函式：在子類別建構子中用關鍵字 super 來呼叫父類別的建構子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const createPersonClass = name =&gt; class extends User &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    super(name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>內部 method 之間不用逗號區分，與一般物件不同，可以避免我們描述二者時產生混淆</p>
</li>
<li><p>class 結構中的 code 都自動開啟了嚴格模式(use strict)</p>
</li>
<li><p>class 的宣告不會被 hoisting 提升到最高作用區，與函式宣告式不同，編譯器尚未抵達和執行 class 宣告之前無法建立或存取class</p>
</li>
<li><p>Just like literal objects, classes may include getters/setters, computed properties etc.</p>
</li>
</ul>
</li>
</ul>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="https://javascript.info/class" target="_blank" rel="noopener">javascript.info</a><br><a href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Classes" target="_blank" rel="noopener">mozilla.org - MDN Web Docs</a></p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="https://chinyun.github.io/myblog/myblog/2019/11/11/JS-Data-Type/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="chinyun">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/myblog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jinny's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/myblog/2019/11/11/JS-Data-Type/" class="post-title-link" itemprop="url">JS Data Type</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-11-11 17:50:01 / Modified: 12:44:14" itemprop="dateCreated datePublished" datetime="2019-11-11T17:50:01+00:00">2019-11-11</time>
            </span>
          
            

            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="JavaScript-Data-Type"><a href="#JavaScript-Data-Type" class="headerlink" title="JavaScript Data Type"></a>JavaScript Data Type</h1><p>JavaScript 的資料類型總共有七種，其中 6 種被稱為 <strong>原始型別 primitive data types</strong>: string, number, boolean, null, undefined, symbol (new in ECMAScript 2015)，以及最後一種 Object 對象資料型別。</p>
<ul>
<li><strong>number</strong>：number for numbers of any kind: integer or floating-point.</li>
<li><strong>string</strong>：string for strings. A string may have one or more characters, there’s no separate single-character type.</li>
<li><strong>boolean</strong>：boolean for true/false.</li>
<li><strong>null</strong>：null for unknown values – a stand alone type that has a single value null.</li>
<li><strong>indefined</strong>：undefined for unassigned values – a standalone type that has a single value undefined.</li>
<li><strong>object</strong>：object for more complex data structures. 包括 function<code>function(){}</code>, array<code>[]</code>, object<code>{key:value}</code>等不同對象物件資料類型。</li>
<li><strong>symbol</strong>：symbol for unique identifiers.</li>
</ul>
<p>JavaScript 是弱型別，也能說是動態的程式語言，這代表不必特別宣告變數的型別，程式在運作時，型別會自動轉換，這也代表可以用不同的型別使用同一個變數。<br>A variable in JavaScript can contain any data. A variable can at one moment be a string and at another be a number:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let message = &quot;hello&quot;;</span><br><span class="line">message = 123456;</span><br><span class="line">&lt;!-- no error --&gt;</span><br></pre></td></tr></table></figure>

<p>Programming languages that allow such things are called “dynamically typed”, meaning that there are data types, but variables are not bound to any of them.</p>
<h1 id="JavaScript-Equals"><a href="#JavaScript-Equals" class="headerlink" title="JavaScript Equals"></a>JavaScript Equals</h1><p>在 JavaScript 語法中，比較值是否相等有分為一般相等比較和嚴格相等比較兩種：</p>
<ul>
<li>Double Equals == 一般相等比較，若等號兩邊的資料類型不同，會轉換為相同類型再比較</li>
<li>Triple Equals === 嚴格相等比較，若類型不同即為不相等</li>
</ul>
<p>字串的比較：依字典順序，按字母逐個進行比較</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">alert(&apos;Z&apos;&gt;&apos;A&apos;) -&gt; true</span><br><span class="line">alert(&apos;Bee&apos;&gt;&apos;Be&apos;) -&gt; true</span><br><span class="line">alert(&apos;Glow&apos;&gt;&apos;Glee&apos;) -&gt; true</span><br><span class="line">alert(&apos;a&apos;&lt;&apos;A&apos;) -&gt; false；在 unicode 中 小寫 a 大於 大寫 A</span><br></pre></td></tr></table></figure>

<p>若為不同類型比較會先轉換為數字(number)在判定大小：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">alert(&apos;2&apos;&gt;1) -&gt; ture</span><br><span class="line">alert(&apos;01&apos;== 1) -&gt; true</span><br><span class="line">alert(&apos;2&apos;&gt;&apos;12&apos;) -&gt; true</span><br><span class="line">alert(0 == &apos;&apos;) -&gt; true</span><br><span class="line">alert(true == 1) -&gt; true</span><br><span class="line">alert(false == 0) -&gt; true</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let a = 0;</span><br><span class="line">alert(Boolean(a)) -&gt; false</span><br><span class="line">let b = &apos;0&apos;;</span><br><span class="line">alert(Boolean(b)) -&gt; true</span><br><span class="line">alert(a == b) -&gt; true</span><br></pre></td></tr></table></figure>

<h1 id="Type-Conversions-類型轉換"><a href="#Type-Conversions-類型轉換" class="headerlink" title="Type Conversions 類型轉換"></a>Type Conversions 類型轉換</h1><ul>
<li><p>String()</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let value = true;</span><br><span class="line">alert(typeof value);  -&gt; boolean</span><br><span class="line">value = String(value); -&gt; &quot;true&quot;</span><br><span class="line">alert(typeof value); -&gt; string</span><br></pre></td></tr></table></figure>
</li>
<li><p>Number()</p>
<ul>
<li>undefined -&gt; NaN</li>
<li>null -&gt; 0</li>
<li>true 和 false -&gt; 1 and 0</li>
<li>string  <ul>
<li>“按原樣讀取”字符串，兩端的空白會被忽略。空字符串變成 0。轉換出錯則輸出 NaN。</li>
<li>幾乎所有的算術運算符都將值轉換為數字進行運算，加號 + 是個例外：如果其中一個運算元是字符串，則另一個也會被轉換為字符串。<br><code>alert( 1 + &#39;2&#39; ); -&gt; &#39;12&#39;</code></li>
</ul>
</li>
</ul>
</li>
<li><p>Boolean()</p>
<ul>
<li>0, null, undefined, NaN, “”  -&gt; false</li>
<li>1, 其他值  -&gt; true</li>
</ul>
</li>
<li><p>總結注意點：</p>
<ul>
<li>當用 Number() 轉換型別成 number 時，須注意 “” 空字符會轉為 0，undefined 會變成 NaN。</li>
<li>用 Boolean() 轉換型別成 boolean 時， 0 為 false；1 為 true，而 null, undefined, NaN 及 “” 都會是 false。</li>
</ul>
</li>
</ul>
<h1 id="null-NaN-undefined"><a href="#null-NaN-undefined" class="headerlink" title="null, NaN, undefined"></a>null, NaN, undefined</h1><ul>
<li>null 表示無、空值，未知的特殊值，typeof(null) -&gt; object，這是一個誤解，因為 typeof 用型別標籤來辨別，null的型別標籤為 000，符合 object 的 type 所以會產生這個結果，這可以說是一種 bug，詳見:<a href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Operators/typeof" target="_blank" rel="noopener">typeof</a></li>
<li>NaN 表示不是一個數字(not a number)，typeof(NaN) -&gt; number</li>
<li>undefined 表示未被賦值，有宣告但未給予數值、字串等值，typeof(undefined) -&gt; undefined，不等於 not defined，not defined 是沒有宣告系統不認得的意思</li>
</ul>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="https://zh.javascript.info/type-conversions" target="_blank" rel="noopener">javascript.info:type-conversions</a><br><a href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Data_structures" target="_blank" rel="noopener">JavaScript 的資料型別與資料結構</a><br><a href="https://cythilya.github.io/2018/10/24/object/" target="_blank" rel="noopener">型別（Type）</a></p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="https://chinyun.github.io/myblog/myblog/2019/11/09/DOM-Event/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="chinyun">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/myblog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jinny's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/myblog/2019/11/09/DOM-Event/" class="post-title-link" itemprop="url">DOM Event</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-11-09 16:48:30" itemprop="dateCreated datePublished" datetime="2019-11-09T16:48:30+00:00">2019-11-09</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-11-11 12:44:14" itemprop="dateModified" datetime="2019-11-11T12:44:14+00:00">2019-11-11</time>
              </span>
            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="DOM-Document-Object-Model"><a href="#DOM-Document-Object-Model" class="headerlink" title="DOM (Document Object Model)"></a>DOM (Document Object Model)</h1><p>W3C(World Wide Web Consortium) 全球資訊網協會訂定了 DOM 的標準，將 DOM 區分為三部分：core DOM、XML DOM、HTML DOM。HTML DOM 是用來取得、修改、新增、刪除 HTML 元素，有了明確的標準不同瀏覽器才能提供一套相同的操作方式給開發者使用。<br>DOM 的樹狀結構是一種有階層(父子關係)的資料結構，以節點(node)代表一個物件，物件本身具有屬性和方法，上層的節點為父節點(parent)下層節點為子節點(child)，一個父節點可能有很多個子節點，但子節點只會有一個父節點。<br>在 document 之上其實還有一個 window 物件，它不屬於 DOM 但實作時經常會使用到 window 提供的屬性及方法，例如： setInterval, clearIntervel, confirm, alert, location</p>
<h1 id="DOM-事件傳遞機制"><a href="#DOM-事件傳遞機制" class="headerlink" title="DOM 事件傳遞機制"></a>DOM 事件傳遞機制</h1><p>事件在 DOM 裡面有既定的傳遞順序，假設你有一個 ul 元素，底下有很多 li ，代表不同的 item，當你點擊任何一個 li 的時候，其實也點擊了 ul，因為 ul 把所有的 li 都包住了。假如我在兩個元素上面都加了eventListener，哪一個會先執行？這時候知道事件的執行順序就很重要。</p>
<p>DOM 事件觸發有三個階段，例如：當點擊事件發生時，會先從 window 開始往下傳遞，一直傳到被點擊的該物件為止，到這邊就叫做 CAPTURING_PHASE 捕獲階段，接著事件傳遞到物件本身，這時候叫做 AT_TARGET，最後事件會從物件一路傳回去 window，這時候叫做 BUBBLING_PHASE 冒泡階段。</p>
<ul>
<li><p>先捕獲(capturing)再冒泡(bubbling)，當事件傳到 target 本身，沒有分捕獲跟冒泡:<br>一般而言是先捕獲再冒泡，但是當事件傳遞到點擊的真正對象，也就是 event.target 的時候，無論你使用 addEventListener 的第三個參數是 true 還是 false，這邊的 event.eventPhase 都會變成 AT_TARGET，既然這邊已經變成 AT_TARGET ，自然就沒有什麼捕獲跟冒泡之分，所以執行順序就會根據 addEventListener 的順序而定，先添加的先執行，後添加的後執行。</p>
</li>
<li><p>事件註冊，加上監聽機制的方法：<code>target.addEventListener(type, listener[, useCapture]);</code><br>addEventListener 函數的第三個參數是 boolean 值，可以決定事先採取被觸發事件的動作反應，還是其外部元素的觸發動作。設定為 true 代表把這個 listener 添加到捕獲階段，false 代表把這個 listener 添加到冒泡階段，預設為false、在冒泡階段 listen 事件觸發。一個 element可以有多個 eventlistener，監聽不同事件(event)，設置指定動作(function)。</p>
</li>
</ul>
<h1 id="stopPropagation-amp-preventDefault"><a href="#stopPropagation-amp-preventDefault" class="headerlink" title="stopPropagation &amp; preventDefault"></a>stopPropagation &amp; preventDefault</h1><ul>
<li><p>stopPropagation：取消事件繼續往下傳遞。加在哪邊，事件的傳遞就斷在哪裡，不會繼續往下傳遞給下一個節點。<br>用法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$list.addEventListener(&apos;click&apos;, (e) =&gt; &#123;</span><br><span class="line">  console.log(&apos;list capturing&apos;);</span><br><span class="line">  e.stopPropagation();</span><br><span class="line">&#125;, true)</span><br></pre></td></tr></table></figure>

<p>儘管已經用e.stopPropagation，但對於同一個層級，剩下的 listener 還是會被執行到，若是你想要讓其他同一層級的 listener 也不要被執行，可以改用 e.stopImmediatePropagation();</p>
</li>
<li><p>preventDefault：取消瀏覽器的預設行為。最常見的例子是阻止點擊<code>&lt;a&gt;</code>時新開分頁、跳轉或<code>&lt;form&gt;</code> submit action。<br>preventDefault 跟事件傳遞「一點關係都沒有」，事件還是會繼續往下傳遞。有一個特別值得注意的地方是 W3C 的文件裡面有寫到：Once preventDefault has been called it will remain in effect throughout the remainder of the event’s propagation. 意思就是說一旦 call 了 preventDefault，在之後傳遞下去的事件裡面也會有效果。<br>用法舉例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">form.addEventListener(&apos;submit&apos;,e=&gt;&#123;</span><br><span class="line">  e.preventDefault(); // 把原生的 Form submit 跳轉行為停掉</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="Event-Delegation"><a href="#Event-Delegation" class="headerlink" title="Event Delegation"></a>Event Delegation</h1><p>事件代理機制是將許多事件綁定在同一節點，透過該節點使下層的子節點都可以觸發事件，因為只要綁定一個地方不需要每個子節點或後來新增的節點都綁定所以叫做事件代理。</p>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="https://medium.com/@realdennis/javascript-%E4%BA%8B%E4%BB%B6-event-da8104c5c98c" target="_blank" rel="noopener">事件 (Event) 的註冊、觸發與傳遞</a><br><a href="https://blog.techbridge.cc/2017/07/15/javascript-event-propagation/" target="_blank" rel="noopener">DOM 的事件傳遞機制：捕獲與冒泡</a></p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="https://chinyun.github.io/myblog/myblog/2019/11/08/css-pseudo-class-pseudo-element/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="chinyun">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/myblog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jinny's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/myblog/2019/11/08/css-pseudo-class-pseudo-element/" class="post-title-link" itemprop="url">css pseudo class & pseudo element</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-11-08 18:39:38" itemprop="dateCreated datePublished" datetime="2019-11-08T18:39:38+00:00">2019-11-08</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-11-11 12:44:14" itemprop="dateModified" datetime="2019-11-11T12:44:14+00:00">2019-11-11</time>
              </span>
            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>單冒號 (:) 是用在偽類<br>雙冒號 (::) 則是用在偽元素<br>偽類 (pseudo class) 就是在選已經存在的東西，比方說 <code>a:hover</code> 就是選了已經存在的 <code>&lt;a&gt;</code> 的某一個狀態<br>偽元素 (pseudo element) 就是在創造一個新的假元素，因為他不在 DOM 裡面，而是創造的了一個我們看不見的元素。比如說 <code>::first-line</code>，第一行並沒有被任何的 tag 包住，所以在選取的過程就像是用了一個看不到的 tag 把第一行包起來，所以才選得到這行。</p>
<p>使用偽類元素，一方面可以減少頁面中的節點元素，加速頁面渲染速度，另一方面可以為設計動畫提供很多新思維。</p>
<h1 id="pseudo-class"><a href="#pseudo-class" class="headerlink" title="pseudo class"></a>pseudo class</h1><p>Pseudo-classes are used to provide styles not for elements, but for various states of elements. The pseudo-class concept is introduced to permit selection based on information that lies outside of the document tree or that cannot be expressed using the other <em>simple selectors</em>.<br>用於定義元素的特殊狀態，為了選擇 DOM tree 之外的信息，或者使用其他簡單選擇器不能表達的信息，不會出現在 DOM tree。</p>
<p>Simple selectors includes:</p>
<ul>
<li>type selector (<code>h1, p, div</code>)</li>
<li>universal selector (<code>*</code>)</li>
<li>attribute selector (<code>img[alt]</code>)</li>
<li>class selector (<code>.class</code>)</li>
<li>ID selector (<code>#id</code>)</li>
<li>pseudo-class (<code>:</code>) <ul>
<li><strong>:active</strong> </li>
<li><strong>:hover</strong> 設定滑鼠滑過的樣式</li>
<li><strong>:visited</strong> 被訪問過的連結的樣式</li>
<li><strong>:link</strong></li>
<li><strong>:nth-child()</strong></li>
<li><strong>:checked</strong></li>
</ul>
</li>
</ul>
<p>狀態不存在 DOM 裡面，或是這幾種 simple selectors 選不到的東西，就是 pseudo-class 要去解決的問題。</p>
<h1 id="pseudo-element"><a href="#pseudo-element" class="headerlink" title="pseudo element"></a>pseudo element</h1><p>Pseudo elements differ from pseudo-classes in that they don’t select states of elements; they select parts of an element. 用於選擇元素的指定部分，創造一個關於 DOM tree 的抽象內容，提供一種方法來引用源文檔中不存在的內容，創造之後會出現在 DOM tree，偽元素也會「繼承」原本元素的屬性。</p>
<ul>
<li><strong>::first-line</strong>：選取第一行</li>
<li><strong>::first-letter</strong>：選取第一個字</li>
<li><strong>::before</strong>：在原本的元素「之前」加入內容</li>
<li><strong>::after</strong>：在原本的元素「之後」加入內容</li>
<li><strong>::selection</strong>：選取文字反白後</li>
</ul>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="https://stringpiggy.hpd.io/pseudo-element-pseudo-class-difference/" target="_blank" rel="noopener">偽元素 (pseudo element) 和偽類 (pseudo class) 差在哪？</a><br><a href="https://www.itread01.com/content/1549211047.html" target="_blank" rel="noopener">css偽類元素的運用以及相應的hover的使用</a><br><a href="https://ithelp.ithome.com.tw/articles/10196924" target="_blank" rel="noopener">CSS 偽類 與 偽元素</a><br><a href="http://csscoke.com/2013/09/21/%E4%BD%BF%E7%94%A8css3-nth-childn-%E9%81%B8%E5%8F%96%E5%99%A8%E8%A9%B3%E8%A7%A3/" target="_blank" rel="noopener">使用CSS3 :nth-child(n) 選取器教學</a><br><a href="https://www.oxxostudio.tw/articles/201405/css-selector.html" target="_blank" rel="noopener">CSS 偽類 child 和 of-type</a><br><a href="https://www.oxxostudio.tw/articles/201706/pseudo-element-1.html" target="_blank" rel="noopener">CSS 偽元素 ( before 與 after )</a></p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="https://chinyun.github.io/myblog/myblog/2019/11/05/Redux-connect-Redux-part-to-React/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="chinyun">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/myblog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jinny's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/myblog/2019/11/05/Redux-connect-Redux-part-to-React/" class="post-title-link" itemprop="url">Connect Redux part to React</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-11-05 16:13:00" itemprop="dateCreated datePublished" datetime="2019-11-05T16:13:00+00:00">2019-11-05</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-11-11 12:44:14" itemprop="dateModified" datetime="2019-11-11T12:44:14+00:00">2019-11-11</time>
              </span>
            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>以下筆記如何在 react app 中引入 redux：<br>示範 code 專案：<a href="https://github.com/chinyun/Tripper-app-redux/blob/master/src/index.js" target="_blank" rel="noopener">Tripper-app-redux</a></p>
<h1 id="程式碼"><a href="#程式碼" class="headerlink" title="程式碼"></a>程式碼</h1><p>in Tripper-app-redux’s index.js:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import React from &apos;react&apos;;</span><br><span class="line">import ReactDOM from &apos;react-dom&apos;;</span><br><span class="line">import &#123; Provider &#125; from &apos;react-redux&apos;;</span><br><span class="line">import &#123; createStore, applyMiddleware, combineReducers &#125; from &apos;redux&apos;;</span><br><span class="line">import &#123; createLogger &#125; from &apos;redux-logger&apos;;</span><br><span class="line">import thunkMiddleware from &apos;redux-thunk&apos;;</span><br><span class="line">import &#123; requestLogIn, routeChange, requestData &#125; from &apos;./reducers&apos;;</span><br><span class="line">import App from &apos;./containers/App&apos;;</span><br><span class="line"></span><br><span class="line">const logger = createLogger();</span><br><span class="line"></span><br><span class="line">const rootReducer = combineReducers(&#123;requestLogIn, routeChange, requestData&#125;);</span><br><span class="line">const store = createStore(rootReducer, applyMiddleware(thunkMiddleware, logger));</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;Provider store=&#123;store&#125;&gt;</span><br><span class="line">    &lt;App/&gt;</span><br><span class="line">  &lt;/Provider&gt;, document.getElementById(&apos;root&apos;));</span><br></pre></td></tr></table></figure>

<p>in Tripper-app-redux’s App.js:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">import &#123; connect &#125; from &apos;react-redux&apos;;</span><br><span class="line">import &#123; routeChange &#125; from &apos;../actions&apos;;</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">const mapStateToProps = (state) =&gt; &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    user: state.requestData.user,</span><br><span class="line">    journeys: state.requestData.journeys,</span><br><span class="line">    initialJourney: state.requestData.initialJourney,</span><br><span class="line">    journeyList: state.requestData.journeyList,</span><br><span class="line">    route: state.routeChange.route,</span><br><span class="line">    isSignedIn: state.requestLogIn.isSignedIn</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const mapDispatchToProps = (dispatch) =&gt; &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    onRouteChange: (route) =&gt; dispatch(routeChange(route))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line"></span><br><span class="line">export default connect(mapStateToProps, mapDispatchToProps)(App);</span><br></pre></td></tr></table></figure>

<h1 id="Redux-Store-and-Provider"><a href="#Redux-Store-and-Provider" class="headerlink" title="Redux Store and Provider"></a>Redux Store and Provider</h1><p><code>&lt;Provider&gt;&lt;/Provider&gt;</code>包住<code>&lt;App&gt;</code>他會把 store 用 props 傳給所有 App 包含的子組件。<br>The logger will catch the actions and console.log() the action that is going to go to the reducer.</p>
<p>Store binds together the 3 principles fo Redux:</p>
<ol>
<li>The entire state of the application will be represented by one JavaScript Object. -&gt;  Store holds the current application state object. </li>
<li>The state is read only, and can only be modified by dispatching actions. -&gt; Store allows you to dispatch actions.</li>
<li>To specify how actions change state tree, the reducers should be pure functions. -&gt; When you create the Store, <strong>you need to specify the Reducer that tells how states updated with actions.</strong></li>
</ol>
<p>Store 有三個重要的 methods:</p>
<ol>
<li>getState(): run console.log(store.getState()) =&gt; get the current state of the Redux Store.</li>
<li><strong>dispatch(): dispatch actions to change the state of the application.</strong></li>
<li>subscribe(): register a callback that the redux store will call any time an action has been dispatched. So you can update the UI of application to reflect the current application’s state.</li>
</ol>
<p>運用 <code>combineReducers()</code> method 將多個 reducer 綁在一起變成一個，<code>createStore()</code>則負責建立 store，接受兩個參數：要監聽的 reducer、用 applyMiddleware() 加入要使用的 middleware。</p>
<h1 id="Connect"><a href="#Connect" class="headerlink" title="Connect"></a>Connect</h1><p><code>connect()</code> are those which one of these components we want to be smart or be aware that the redux library exists and they subscribe to the changes. The connect function is optimized in order for us to avoid using somthing called <code>store.subscribe()</code>. It is a higher order function, means that a function that return another function. Through connect function, App component now could listen to the states that <code>mapStateToProps</code> gives and interested in actions that <code>mapDispatchToProps</code> gives to the component.</p>
<h1 id="Redux-Middleware"><a href="#Redux-Middleware" class="headerlink" title="Redux Middleware"></a>Redux Middleware</h1><p>Middleware is the suggested way to extend Redux with custom functionality. Middleware lets you wrap the store’s dispatch method for fun and profit. The key feature of middleware is that it is composable. Multiple middleware can be combined together, where each middleware requires no knowledge of what comes before or after it in the chain.<br>Middleware 就像一個 tunnel，在 action 到 reducer 的階段之間建立通道，在 dispatch actions 時適時採取相應的行為。 Middleware helps us to handle side effects, monitor each one of our actions. We can listen to what logging output each one of these actions happen. It provides a third-party extension point between dispatching an action, and the moment it reaches the reducer.</p>
<p>Redux Pattern:</p>
<pre class="mermaid">graph LR;
A(Action) -- Middleware --> B(Reducer);
B --> C(Store);
C --> D(Make changes);</pre>
<p>在 Action 和 Reducer 之間的 Middleware 作用是輔助處理，當 dispatch action 的時候透過 middleware 進行額外動作。<br>常用的 Middleware 例如：</p>
<ul>
<li>redux-logger：監聽 actions，在 console 印出 action type、以及更新前、後的狀態</li>
<li>redux-thunk：額外或是非同步的 dispatch</li>
<li>redux-observable、redux-saga：複雜邏輯 dispatch</li>
</ul>
<p>使用的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const store = createStore(rootReducer, applyMiddleware(thunkMiddleware, logger));</span><br></pre></td></tr></table></figure>

<p>在建立 store 的時候一併設定，透過 applyMiddleware() 放入多個 middleware，表示當 action dispatch時會依序經過 thunkMiddleware、logger 這些 middleware，然後再到 reducer。</p>
<h1 id="Asynchronous-Redux"><a href="#Asynchronous-Redux" class="headerlink" title="Asynchronous Redux"></a>Asynchronous Redux</h1><p>The redux-thunk package that provides a getState and dispatch functions that are passed on. <strong>Redux-thunk can handle asynchronous actions like AJAX calls.</strong> How does this middleware work? Thunk middleware is waiting for a function, it waits and sees if any actions return a function instead of an object. And if it is a function, <strong>give a dispatch so we can call the actions to run</strong> the function as we thought.  </p>
<p>Asynchronous Action 可以寫作這樣：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">export const editBudgets = (data, id, index) =&gt; (dispatch) =&gt; &#123;</span><br><span class="line">  dispatch(&#123; type: REQUEST_DATA_FAILED &#125;);</span><br><span class="line">  fetch(`$&#123;Url&#125;/journeys_budgets/$&#123;id&#125;`, &#123;</span><br><span class="line">    method: &apos;PATCH&apos;,</span><br><span class="line">    headers: &#123;&apos;Content-Type&apos;: &apos;application/json&apos;&#125;,</span><br><span class="line">    body: JSON.stringify(data)</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(response =&gt; response.json())</span><br><span class="line">  .then(journey =&gt; &#123;</span><br><span class="line">    if (journey) &#123;</span><br><span class="line">      dispatch(&#123;</span><br><span class="line">        type: REQUEST_UPDATE_BUDGETS_SUCCESS,</span><br><span class="line">        payload: &#123;</span><br><span class="line">          data: journey,</span><br><span class="line">          index: index</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      alert(&apos;unable to edit budget&apos;)</span><br><span class="line">    &#125;    </span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(err =&gt; dispatch(&#123; type: REQUEST_DATA_FAILED, payload: err &#125;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中 <code>const editBudgets = (data, id, index) =&gt; (dispatch) =&gt; {...}</code> 表示 A function that return another function, redux wouldn’t understand it. Because it’s not an object, as it expects for an action. With the redux-thunk middleware, now we’re listening to actions. Anytime the actions get triggered it’s going to return a function and trigger redux-thunk and redux-thunk is going to know whether it is a function or not then give it a dispatch to call action to run.</p>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="https://redux.js.org/introduction/getting-started" target="_blank" rel="noopener">redux 官方</a></p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="https://chinyun.github.io/myblog/myblog/2019/11/04/MVC-framework-SSR-CSR-SPA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="chinyun">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/myblog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jinny's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/myblog/2019/11/04/MVC-framework-SSR-CSR-SPA/" class="post-title-link" itemprop="url">MVC framework, SSR, CSR, SPA</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-11-04 21:18:49" itemprop="dateCreated datePublished" datetime="2019-11-04T21:18:49+00:00">2019-11-04</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-11-11 12:44:14" itemprop="dateModified" datetime="2019-11-11T12:44:14+00:00">2019-11-11</time>
              </span>
            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="What-is-MVC-framework-Why-we-need"><a href="#What-is-MVC-framework-Why-we-need" class="headerlink" title="What is MVC framework? Why we need?"></a>What is MVC framework? Why we need?</h1><p>MVC 架構是為了讓複雜程式碼能夠根據各自負責的功能目的做區分而出現的開發設計模式，分別是 modle、view、controller 三個部分，在權責區分清楚的情況下，可以有更好的擴充性和維護性。</p>
<p>modle 代表邏輯處理，view 負責 UI 的呈現，controller 則串連 modle 和 view，作為程式的流程控制。</p>
<p>舉例：</p>
<p>使用者造訪一個部落格網站，點擊文章列表頁面，瀏覽器發出 request 給伺服器，server side 處理 request；將請求丟給對應的 controller，controller 向 model 存取資料，model 回應傳回資料並 render html 交給 controller，controller 再回傳一整份 html 檔給瀏覽器，瀏覽器顯示包含資料內容的 html 畫面。</p>
<h1 id="前後端分離"><a href="#前後端分離" class="headerlink" title="前後端分離"></a>前後端分離</h1><p>後端專注在提供資料，前端專注在顯示資料，把 data 跟 view 完全切開來，這樣要替換語言或框架時也比較方便，後端只要確保 API 接口一致，就不會影響前端，反之也是一樣。</p>
<p>假如 server 有一天掛了，API 也跟著掛了，使用者依然可以造訪網頁，只是看不到資料而已，或者是你可以顯示出一個錯誤的圖案。但如果是舊的那種綁在一起的架構，server 一旦掛掉，你連畫面都渲染不出來。</p>
<p>而這樣的做法會讓前端自己管理 URL 的狀態，去決定現在要顯示哪一個頁面。</p>
<h1 id="SSR-Sever-side-Rendering"><a href="#SSR-Sever-side-Rendering" class="headerlink" title="SSR(Sever-side Rendering)"></a>SSR(Sever-side Rendering)</h1><p>view 的畫面是在後端動態產生 html，render 完成再 response 給前端（瀏覽器），本質上是「每一個不同頁面就回傳一份不同的 html 檔案」，每一個頁面之間的狀態不會互相干擾。</p>
<h1 id="CSR-Client-side-Rendering"><a href="#CSR-Client-side-Rendering" class="headerlink" title="CSR(Client-side Rendering)"></a>CSR(Client-side Rendering)</h1><p>view 的畫面當前端拿到資料以後，才用 JavaScript 動態的產生，把內容填到網頁上面，並且需要管理不同頁面，根據路徑或用 hashtag 管理畫面切換。<br>前端 render 的難題在：「要怎麼只更新部分畫面，而不是暴力的每次都砍掉重練」。</p>
<h1 id="SPA-Single-Page-Application"><a href="#SPA-Single-Page-Application" class="headerlink" title="SPA(Single-Page-Application)"></a>SPA(Single-Page-Application)</h1><p>所有個內容都由前端用 JavaScript 動態產生，用 AJAX 拿資料並搭配 JavaScript 來做畫面上的處理。<br>與之對應的概念是 MPA，Multiple Page Application。</p>
<ul>
<li><p>前端、後端各自有 MVC 框架<br>前端如果利用 SPA 來實作的話，會把原本應該是後端處理的一部份職責給搬到前端去，例如說狀態的管理跟路由；以往 Server 根據不同的路徑對應到不同的 Controller，進而渲染出不同的 View，可是現在 Server 無論什麼路徑都會輸出同一個檔案（index.html），所以你在前端也要判斷現在的網址是哪個，才能決定在前端應該渲染出哪個畫面，因此前端也開始需要 MVC 架構了，也就是由 router 去分類路徑並交給 controller 去分別連接 model 和 view。<br>藉由前後端各自的架構，後端只負責輸出資料，前端來負責抓資料跟渲染畫面。把前後端完完全全的切開了，就算後端壞掉，前端還是看得到畫面（只是可能會顯示個錯誤畫面之類的）；前端壞掉，後端還是能安穩的輸出資料供其他服務使用。</p>
</li>
<li><p>SEO 問題<br>由於 SPA 是由前端的 JavaScript 動態產生內容，因此如果你對 SPA 的網站按下右鍵 -&gt; 檢視原始碼，只會看到空蕩蕩的一片，只看得到一個 JavaScript 檔案跟一些最基本的 tag，這對於 SEO 的影響而言是不好的。<br>強大的 Google 的爬蟲其實支援執行 JavaScript，所以他依然會 index 你在前端渲染之後的頁面，但還有其他很多搜尋引擎，有些可能沒有像 Google 這麼強大，碰到 SPA 就只能索引空蕩蕩的 HTML，內容幾乎空白。<br>既然問題出在「第一次渲染」，在第一次渲染的時候把該輸出的資料都輸出(運用 server-side rendering)，對使用者來說還是一個 SPA，差別在於使用者接收到 HTML 的時候，就已經有完整的資料了，第一個頁面由 Server side render，之後的操作還是由 Client side render。</p>
</li>
</ul>
<h1 id="Flux"><a href="#Flux" class="headerlink" title="Flux"></a>Flux</h1><p>Flux 是一種架構設計模式，幫助你撰寫有條理的前端架構，用於管理控制應用程式中資料的流向，確保資料是 one-way data flow，資料的定義不限於指來自 server 的邏輯資料，也包括 view 的變化等。 在 flux 的架構中，Store基本上是你唯一可以操作資料與儲存資料的地方。</p>
<p>Flux Pattern 是這樣的：</p>
<pre class="mermaid">graph LR;
A(Action) --> B(Dispatcher);
B --> C(Store);
C --> D(View);</pre>

<ul>
<li>Flux 中有四位主要角色：</li>
</ul>
<ol>
<li>Action：規範所有改變資料的動作，讓你可以快速掌握整個 App 的行為。</li>
<li>Dispatcher：將目前發生的行為，告知給所有已註冊的 Store。</li>
<li>Store：存放資料和業務邏輯，並且只提供 getter API 讓人取得資料。</li>
<li>View：根據資料渲染 UI 和傾聽使用者的操作事件。</li>
</ol>
<p>當 action 被觸發後，View 就會透過 Dispatcher dispatch 出一個 Action，該 Action 可以包含一個 payload，說明你想做什麼事情以及你需要操作什麼資料，在 Store 資料做完更新後，要告訴前端頁面去刷新視圖(view)。</p>
<ul>
<li>Flux 的特性：</li>
</ul>
<ol>
<li>單向資料流：改變資料的行為都必須經過 Action、Dispatcher，再到 Store。</li>
<li>Single Source of Truth：資料統一存放於 Store，View 要資料都需跟 Store 拿。</li>
</ol>
<ul>
<li>Flux 的優點：<br>用更清晰的模式，規範資料和頁面複雜互動情境下的資料流。</li>
</ul>
<p>事實上，MVC 跟 Flux 都只是一個概念，因此有各種不同的實作，加上MVC在資料流的處理上，並不像Flux一般有較為明確的定義，多數時候Model的更動與View的刷新可能會透過Controller來管理，讓Model單純存放data。</p>
<p>如此一來，假若今天 View 的操作更動了 Model，而 Model 的變化又刷新了 View，在系統龐大的時候，一來一往，就會讓資料與頁面狀態變得非常複雜，要追蹤某個頁面的變動到底是誰觸發的，或是哪個資料改變了，必須從 Controller 去慢慢 trace。而若是遵照 Flux 的流程，任何 View 的 update 都只要去追蹤其 State 的來源 Store 即可，有一個明確的 flow 可以遵循，並且每個 View 所需要監聽的資料來源，可以依照 Store 來區分，資料流不會互相干擾，而且 Flux 能夠更輕鬆的做出更小單元的 Unit test，這是複雜的 Controller 難以達成的。</p>
<h1 id="React-Redux-gt-解決-MVC-架構問題"><a href="#React-Redux-gt-解決-MVC-架構問題" class="headerlink" title="React + Redux =&gt; 解決 MVC 架構問題"></a>React + Redux =&gt; 解決 MVC 架構問題</h1><ul>
<li>React 解決什麼問題？<br>React 是專注在 MVC 架構中的 view，以 state 來管理介面變化的開發框架，透過 virtualDOM 在 state 改變時只重新 render 改變的地方，不需要在頁面切換或資料狀態更新、介面變化時重新 render 整個畫面，有效增進了應用程式的效能和使用者體驗。</li>
</ul>
<p>React 把更改 state 的邏輯寫在各自的 component，然而當項目的邏輯變得越來越複雜的時候，將難以釐清 state 和 view 之間的對應關係：一個 state 的變化可能引起多個 view 的變化，一個 view 上面觸發的事件可能引起多個 state 的改變，需要對所有引起 state 變化的情況進行統一管理，於是就需要 Redux。</p>
<ul>
<li>Redux 解決什麼問題？<br>Redux 受到幾個 Flux Pattern 重要特質的影響，Redux 透過單一的狀態樹將所有 state 存於一個物件中，並由 Store 去管理；一律透過 action 描述更新動作，經過 Reducer 來變更 state。<br>Reducer 根據 action 物件和舊資料回傳新資料，因此你可以紀錄 action，並重新調用 reducer 函數來得到一樣的狀態，幫助我們做可預測的狀態管理，能夠追蹤 state 和資料變化，更好維護而且資料之間不會互相干擾。</li>
</ul>
<p>Redux Pattern:</p>
<pre class="mermaid">graph LR;
A(Action) -- Middleware --> B(Reducer);
B --> C(Store);
C --> D(Make changes);</pre>

<p><strong>所以使用 Redux + React，可以促進維護性和可擴展性。</strong></p>
<p>Redux 和 Flux pattern 不同的地方在於： </p>
<ol>
<li><p>Redux 只有一個 store，業務資料都存於一個狀態物件中，並由 Store 去管理；Flux 裡面會有多個 store，分別管理不同資料。</p>
</li>
<li><p>Redux 中更新的邏輯不在 store 中執行而是由 reducer 負責執行；Flux 在 store 裡面執行更新邏輯，當 store 變化的時候再通知 controller-view 更新自己的數據。</p>
</li>
</ol>
<p>reducer 是一個純函數，這個函數被表述為(previousState, action) =&gt; newState，它根據應用的狀態和當前的 action 推導出新的 state 。 Redux 中有多個 reducer，每個 reducer 負責維護應用整體 state 樹中的某一部分，多個 reducer 可以通過 combineReducers 方法合成一個根 reducer，這個根 reducer 負責維護完整的 state，當一個 action 被觸發，store 會調用 dispatch 方法向某個特定的 reducer 傳遞該 action，reducer 收到 action 之後執行對應的更新邏輯然後返回一個新的 state，state 的更新最終會傳遞到根 reducer 處，返回一個全新的完整的 state，然後傳遞給 view。</p>
<ol start="2">
<li>Redux 沒有 Dispatcher 的概念，它使用 reducer 來進行事件的處理，Store 提供 dispatch API 來傳遞 action 物件；<br>Flux 的 Dispatcher 負責將 action 物件傳遞給每個 Store</li>
</ol>
<p>Redux 和 Flux 之間最大的區別就是對 store/reducer 的抽象，Flux 中 store 是各自為陣的，每個 store 只對對應的 controller-view 負責，每次更新都只通知對應的 controller-view；而 Redux 中各子 reducer 都是由根 reducer 統一管理的，每個子 reducer 的變化都要經過根 reducer 的整合。</p>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="https://medium.com/@hulitw/introduction-mvc-spa-and-ssr-545c941669e9" target="_blank" rel="noopener">跟著小明一起搞懂技術名詞：MVC、SPA 與 SSR 2018</a><br><a href="https://ithelp.ithome.com.tw/articles/10194968" target="_blank" rel="noopener">Node.js-Backend見聞錄(10)：關於後端觀念(六)-關於MVC 2017</a><br><a href="https://blog.techbridge.cc/2017/09/16/frontend-backend-mvc/" target="_blank" rel="noopener">前後端分離與 SPA 2017</a><br><a href="https://blog.techbridge.cc/2016/04/29/introduce-flux-from-flux-and-mvc/" target="_blank" rel="noopener">從 Flux 與 MVC 的差異來簡介 Flux 2016</a><br><a href="http://blog.turn.tw/?p=1539" target="_blank" rel="noopener">MVC是一個巨大誤會 2015</a><br><a href="https://imweb.io/topic/57711e37f0a5487b05f325b5" target="_blank" rel="noopener">浅谈 React、Flux 与 Redux 2016</a><br><a href="https://medium.com/4cats-io/%E6%B7%B1%E5%85%A5%E6%B7%BA%E5%87%BA-redux-7b08403c4957" target="_blank" rel="noopener">深入淺出 Redux 2016</a></p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="https://chinyun.github.io/myblog/myblog/2019/11/04/Knex-js-PostgreSQL/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="chinyun">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/myblog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jinny's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/myblog/2019/11/04/Knex-js-PostgreSQL/" class="post-title-link" itemprop="url">Knex.js+PostgreSQL</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-11-04 16:18:24" itemprop="dateCreated datePublished" datetime="2019-11-04T16:18:24+00:00">2019-11-04</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-11-11 12:44:14" itemprop="dateModified" datetime="2019-11-11T12:44:14+00:00">2019-11-11</time>
              </span>
            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="What-is-Knex-js"><a href="#What-is-Knex-js" class="headerlink" title="What is Knex.js?"></a>What is Knex.js?</h1><p>Knex.js is a tool in the Database Tools category of a tech stack.<br>Knex.js is an open source tool with 10.8K GitHub stars and 1.3K GitHub forks. </p>
<p>Knex.js is a JavaScript query builder for relational databases including PostgreSQL, MySQL, SQLite3, Oracle, MSSQL, MariaDB and Amazon Redshift. It can be used with callbacks and promises. It supports transactions and connection pooling.</p>
<p>可以將操作資料庫的方式分成三種層次： low-level Database Drivers、middle-level Query Builders、high-level ORMs。</p>
<ol>
<li>Database Drivers<br>This is basically as low-level as you can get — short of manually generating TCP packets and delivering them to the database. A database driver is going to handle connecting to a database (and sometimes connection pooling). At this level you’re going to be writing raw SQL strings and delivering them to a database, and receiving a response from the database. In the Node.js ecosystem there are many libraries operating at this layer. Here are three popular libraries:</li>
</ol>
<ul>
<li>mysql: MySQL (13k stars / 330k weekly downloads)</li>
<li>pg: PostgreSQL (6k stars / 520k weekly downloads)</li>
<li>sqlite3: SQLite (3k stars / 120k weekly downloads)</li>
</ul>
<p>Each of these libraries essentially works the same way: take the database credentials, instantiate a new database instance, connect to the database, and send it queries in the form of a string and asynchronously handle the result.</p>
<ol start="2">
<li>Query Builders<br>This is the intermediary level between using the simpler Database Driver module vs a full-fledged ORM. The most notable module which operates at this layer is Knex. This module is able to generate queries for a few different SQL dialects. This module depends on one of the aforementioned libraries — you’ll need to install the particular ones you plan on using with Knex.</li>
</ol>
<ul>
<li>knex: Query Builder (8k stars / 170k weekly downloads)</li>
</ul>
<ol start="3">
<li>ORMs<br>ORMs are powerful tools. The ORMs we’ll be examining in this post are able to communicate with SQL backends such as SQLite, PostgreSQL, MySQL, and MSSQL.<br>This is the highest level of abstraction we’re going to consider. When working with ORMs we typically need to do a lot more configuration ahead of time. The point of an ORM, as the name implies, is to map a record in a relational database to an object (typically, but not always, a class instance) in our application. What this means is that we’re defining the structure of these objects, as well as their relationships, in our application code.<br>Bust there are some reasons that you should be wary of using an ORM:</li>
</ol>
<p>(1) <strong>Take time to learn but it is not SQL.</strong> An ORM is going to be written in the same language as the rest of the application, while SQL is a completely different syntax. A lot of people pick up an ORM because they don’t want to take the time to learn the underlying SQL (Structured Query Language).The syntax for a simple read operation varies greatly between these examples. As the operation you’re trying to perform increases in complexity, such as operations involving multiple tables, the ORM syntax will vary from between implementations even more.</p>
<p>(2) <strong>Complex ORM calls can be Inefficient</strong>: Recall that the purpose of an ORM is to take the underlying data stored in a database and map it into an object that we can interact within our application. This often comes with some inefficiencies when we use an ORM to fetch certain data.</p>
<p>(3) <strong>Not all queries can be represented as an ORM operation</strong>. When we need to generate these queries we have to fall back to generating the SQL query by hand. This often means a codebase with heavy ORM usage will still have a few handwritten queries strewn about it. A common situation which doesn’t work too well with ORMs is when a query contains a subquery. </p>
<h1 id="Why-use-Knex-js"><a href="#Why-use-Knex-js" class="headerlink" title="Why use Knex.js?"></a>Why use Knex.js?</h1><p>與 SQL 原生語法相近，卻更簡潔、容易使用。語法設計讓參數和查詢字串分別傳遞給 database driver，保護查詢不會受到 SQL injection。</p>
<p>One nicety is that you’re able to programmatically generate dynamic queries in a much more convenient way than if you were to concatenate strings together to form SQL (which often introduces security vulnerabilities).</p>
<p>Parameters and query string are passed separately to database driver protecting query from SQL injection. Other query builder methods always uses binding format internally so they are safe too.</p>
<h1 id="How-to-use"><a href="#How-to-use" class="headerlink" title="How to use?"></a>How to use?</h1><p>When creating a Knex instance you provide the connection details, along with the dialect you plan on using and are then able to start making queries. The queries you write will <strong>closely resemble the underlying SQL queries</strong>.<br>詳細的使用說明可以查詢<a href="http://knexjs.org/" target="_blank" rel="noopener">官方文件</a></p>
<p>Here is the example of using knex.js to connect postgreSQL:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// $ npm install pg knex</span><br><span class="line"></span><br><span class="line">const knex = require(&apos;knex&apos;);</span><br><span class="line">const connection = require(&apos;./connection.json&apos;);</span><br><span class="line">const client = knex(&#123;</span><br><span class="line">  client: &apos;pg&apos;,</span><br><span class="line">  connection</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>要小心使用 <code>knex.raw()</code>，避免允許植入 SQL 語句。</p>
<h1 id="What-is-PostgreSQL-compare-with-MySQL"><a href="#What-is-PostgreSQL-compare-with-MySQL" class="headerlink" title="What is PostgreSQL? compare with MySQL?"></a>What is PostgreSQL? compare with MySQL?</h1><p>PostgreSQL 和 MySQL 兩個資料庫之間有許多相似之處和重疊，但也有非常明顯的差異，使用 PostgreSQL 的優點：</p>
<p>-Open Source:<br>PostgreSQL 由 PostgreSQL 全球開發小組（PostgreSQL Global Development Group）開發，PostgreSQL 全球開發組由多個公司和個人貢獻者所組成。它是免費的開源軟體。PostgreSQL 是在 PostgreSQL 使用許可發布的，這是一個自由的開源許可，類似於 BSD 或 MIT 使用許可。</p>
<p>MySQL 開發專案根據 GNU GPL 的條款提供了它的原始碼以及各種各樣的專有協議。它現在由 Oracle 公司擁有，並且提供了幾個商業使用的付費版本。</p>
<ul>
<li>ACID Compliance:<br>ACID（Atomicity，Consistency，Isolation，Durability）是一組資料庫交易安全的特性，ACID 要求確保在單一的資料交易中發生多個更新時也不會在整個系統中遺失數據或發生錯誤。<br>PostgreSQL 完全符合 ACID 特性，並確保滿足所有要求。</li>
</ul>
<p>MySQL 只有在使用 InnoDB 和 NDB 叢集儲存引擎時，才符合ACID 標準。</p>
<ul>
<li>Performance:<br>PostgreSQL 被廣泛應用於讀寫速度至關重要且資料需要驗證的大型系統中。 此外，它在商業解決方案中，還支持各種效能優化，（如地理空間資料支持，不需要讀取鎖定的資料一致性支援，如 Oracle、SQL Server）。 整體來看，PostgreSQL 的效能在需要執行複雜查詢的系統中會得到了最好的展現。 PostgreSQL 在 OLTP / OLAP 系統中運行良好，尤其在需要讀/寫速度和需要大量的資料分析時。 PostgreSQL 也適用於商業智慧應用服務，但更適合需要快速讀/寫速度的資料倉庫和資料分析應用服務。</li>
</ul>
<p>MySQL 被廣泛採用，是由於 Web 應用，只需要一個簡單的資料交易資料庫。然而，在一般的情況下，如果 MySQL 的表現不佳，都是當負載過重或試圖進行複雜查詢的時候。MySQL 在 OLAP / OLTP 系統只需要讀取速度時表現良好。MySQL + InnoDB為 OLTP 場景提供了非常好的讀/寫速度。 整體來說，MySQL在高度資料一致性需求的情況下表現良好。MySQL 是可靠的，並且適用於商業智慧應用服務，因為商業智慧應用服務通常是更重視讀取效能的。</p>
<ul>
<li>Security:<br>PostgreSQL 具有角色並可繼承角色來設定和維護權限。 PostgreSQL 內建支援 SSL連線來加密客戶端/伺服器通訊。 它具有資料列級的安全性。除此之外，PostgreSQL 還附帶了一個名為 SE-PostgreSQL 的增強功能，可以根據 SELinux 安全策略提供額外的存取控制。</li>
</ul>
<p>MySQL 為所有連線、查詢和用戶可能嘗試執行的其他操作實作了存取控制列表（ACL）的安全性。 對 MySQL 客戶端和伺服器之間的 SSL 加密連接也有支援。</p>
<ul>
<li>NoSQL Features/JSON Support:<br>NoSQL 和 JSON 都非常流行，NoSQL資料庫變得越來越普及。JSON 是一種簡單的資料格式，它允許程式設計師儲存和傳遞跨系統的資料內容、資料列表和 key-value 對應。<br>PostgreSQL 支援 JSON 和其他 NoSQL 的功能，如內建 XML 支援和 HSTORE 的 key-value 對應。 它還支援將 JSON 資料索引以加快存取速度。</li>
</ul>
<p>MySQL 具有 JSON 資料類型支援，但沒有其他 NoSQL功能，也不支援 JSON 索引。</p>
<ul>
<li>Programming Languages Support:<br>PostgreSQL 支援各種程式語言，包括：C / C ++，Java，JavaScript，.Net，R，Perl，Python，Ruby，Tcl 等等。 甚至可以在單獨的程序中執行用戶提供的程式（即作為背景執行程式）。</li>
</ul>
<p>MySQL 一些支援伺服器端不可擴展的程式語言。</p>
<ul>
<li>Extensible Type System:<br>PostgreSQL有幾個專用於延伸套件的功能，可以增加新的資料型別、新的函數功能、新的索引類型。</li>
</ul>
<p>MySQL 不支援增加延伸功能。</p>
<p>更多比較可以查看 PostgreSQL官方文件：<a href="https://faq.postgresql.tw/postgresql-vs-mysql" target="_blank" rel="noopener">PostgreSQL vs MySQL</a></p>
<p>PostgreSQL 相對於 MySQL 的優勢：</p>
<p>　　1、在 SQL 的標準實現上要比 MySQL 完善，而且功能實現比較嚴謹；<br>　　2、存儲過程的功能支持要比 MySQL 好，具備本地緩存執行計劃的能力；<br>　　3、對表連接支持較完整，優化器的功能較完整，支持的索引類型很多，復雜查詢能力較強；<br>　　4、PG 主表采用堆表存放，MySQL 采用索引組織表，能夠支持比MySQL更大的數據量。<br>　　5、PG 的主備復制屬於物理復制，相對於 MySQL 基於 binlog 的邏輯復制，數據的一致性更加可靠，復制性能更高，對主機性能的影響也更小。<br>　　6、MySQL 的存儲引擎插件化機制，存在鎖機制復雜影響並發的問題，而 PG 不存在。</p>
<p>　　MySQL 相對於 PG 的優勢：</p>
<p>　　1、innodb 的基於回滾段實現的 MVCC 機制，相對 PG 新老數據一起存放的基於 XID 的 MVCC 機制，是占優的。新老數據一起存放，需要定時觸發 VACUUM，會帶來多余的 IO和數據庫對象加鎖開銷，引起數據庫整體的並發能力下降。而且 VACUUM清理不及時，還可能會引發數據膨脹；<br>　　2、MySQL采用索引組織表，這種存儲方式非常適合基於主鍵匹配的查詢、刪改操作，但是對表結構設計存在約束；<br>　　3、MySQL的優化器較簡單，系統表、運算符、數據類型的實現都很精簡，非常適合簡單的查詢操作；<br>　　4、MySQL分區表的實現要優於PG的基於繼承表的分區實現，主要體現在分區個數達到上千上萬後的處理性能差異較大。<br>　　5、MySQL的存儲引擎插件化機制，使得它的應用場景更加廣泛，比如除了innodb適合事務處理場景外，myisam適合靜態數據的查詢場景。</p>
<p>總體上來說，開源數據庫都不是很完善，商業數據庫oracle在架構和功能方面都還是完善很多的。從應用場景來說，PG更加適合嚴格的企業應用場景（比如金融、電信、ERP、CRM），而MySQL更加適合業務邏輯相對簡單、數據可靠性要求較低的互聯網場景（比如Google、facebook、alibaba）。</p>
<p>雖然有不同的歷史、引擎與工具，不過並沒有明確的參考能夠表明這兩個數據庫哪一個能夠適用於所有情況。很多組織喜歡使用PostgreSQL，因為它的可靠性好，在保護數據方面很擅長，而且是個社區項目，不會陷入廠商的牢籠之中。MySQL更加靈活，提供了更多選項來針對不同的任務進行裁剪。很多時候，對於一個組織來說，對某個軟件使用的熟練程度要比特性上的原因更重要。</p>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="https://blog.logrocket.com/why-you-should-avoid-orms-with-examples-in-node-js-e0baab73fa5/" target="_blank" rel="noopener">Why you should avoid ORMs (with examples in Node.js)</a><br><a href="http://knexjs.org/" target="_blank" rel="noopener">Knex.js</a><br><a href="https://faq.postgresql.tw/postgresql-vs-mysql" target="_blank" rel="noopener">PostgreSQL vs MySQL</a><br><a href="https://www.itread01.com/articles/1502570301.html" target="_blank" rel="noopener">PostgreSQL 與 MySQL的比較</a></p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="https://chinyun.github.io/myblog/myblog/2019/11/02/HTTPS-HTTP-JSON-AJAX/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="chinyun">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/myblog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jinny's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/myblog/2019/11/02/HTTPS-HTTP-JSON-AJAX/" class="post-title-link" itemprop="url">HTTPS/HTTP/JSON/AJAX/RestfulAPI</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-11-02 23:52:26" itemprop="dateCreated datePublished" datetime="2019-11-02T23:52:26+00:00">2019-11-02</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-11-11 12:44:14" itemprop="dateModified" datetime="2019-11-11T12:44:14+00:00">2019-11-11</time>
              </span>
            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="How-is-the-Internet-work"><a href="#How-is-the-Internet-work" class="headerlink" title="How is the Internet work?"></a>How is the Internet work?</h1><p>現代網路運作的基礎主要由瀏覽器、伺服器以及網路資料的傳遞組成，在網路世界中，最小的資訊單位是 bit，遍佈世界的光纖纜線以光速傳輸資訊，所以當我們用 wifi 上網時，就像用電台傳送廣播一樣，將資訊波段以無線的方式傳送 wifi路由器，再透過電纜運送連結到世界上的任何一處。<br>當使用者在自己電腦透過瀏覽器瀏覽網頁時，會從瀏覽器發出造訪某網頁網址的請求，而該網址所屬的網站伺服器接收到請求內容後，返回包含了 HTML、CSS、JavaScript 等的檔案，瀏覽器接到回應之後將網站呈現在畫面上，上述這個瀏覽器發出請求(request)、伺服器給予回應(response)的過程就是一般我們在瀏覽器輸入網址後，到瀏覽器渲染出頁面之間發生的事情，而這個過程其實仰賴許多機制共同建立，包括：</p>
<ul>
<li><p><strong>域名系統 - DNS (Domain Name System)</strong>：由於我們平常用的網址是 Domain，而電腦都是用 IP 在溝通的，DNS 會負責將網址分析為 IP 位址，回報給本地電腦，本地電腦獲得 IP 位址，就能成功連上對方主機並請求主機回傳網頁資料。</p>
</li>
<li><p><strong>資料傳輸的單位 - 封包 (packet)</strong>：封包帶有起始和終點的 IP 位址資訊，網路傳輸時會將資料拆分成多個封包傳遞；若某網路定義的封包大小為 1500 bytes，一部影音為 500MB 的資料就會被拆為 35萬個左右的封包發送至目的地 IP 位址。（1MB = 1,048,576 bytes）</p>
</li>
<li><p><strong>指引封包走對的路線 - 路由器 (router)</strong>：一種專門電腦，根據纜線的「交通狀況」幫封包選擇最易通行、最省時且風險最低的路徑，確保網路傳輸可靠度。</p>
</li>
<li><p><strong>確保資料完整抵達 - 傳輸控制協定 (TCP-Transmission Control Protocol)</strong>：在資料送達時，根據 IP 封包裡的資訊檢查是否有全部送達，只有全數送達時才會簽收，若發現資料短少就會通知伺服器主機要求重新發送資料。</p>
</li>
<li><p><strong>通訊協定：伺服器和瀏覽器的對話 - HTTP</strong>：通訊協定事電腦之間互相索取資料的溝通語言，設計 HTTP 的最初目的是發布和接收 HTML 頁面。</p>
</li>
</ul>
<p>透過以上的機制維持網路的運作，我們可以在自家電腦使用瀏覽器發送請求以連上世界各地的網站，獲得世界各地主機的資料。</p>
<p>事實上，網路除了瀏覽器和伺服器，根據網路的架構還可以將網路運作分為四個層級：應用層、傳送層、網路層、鏈結層，可以對應到 OSI 七層級，如下表：</p>
<table>
<thead>
<tr>
<th>OSI 七層級</th>
<th>TCP/IP 模型</th>
<th>相關通訊協定和標準</th>
</tr>
</thead>
<tbody><tr>
<td>應用層、表現層、會談層</td>
<td>應用層</td>
<td>HTTP/FTP/SMTP/DNS/SSH</td>
</tr>
<tr>
<td>傳送層</td>
<td>傳送層</td>
<td>TCP</td>
</tr>
<tr>
<td>網路層</td>
<td>網路層</td>
<td>IP</td>
</tr>
<tr>
<td>資訊鏈結層、實體層</td>
<td>鏈結層</td>
<td>LAN/WAN</td>
</tr>
</tbody></table>
<p>TCP/IP 模型由 OSI(open system interconnecttion)模型簡化而來，OSI是由 ISO組織制定，作為制定網路標準的參考，依網路運作方式將網路架構分為七個層次。<br><strong>鏈結層</strong>將數位訊號組成符合邏輯的傳輸資料(資訊框 data frame)，定義網路裝置之間的位元資料傳輸，主要跟硬體有關。<br><strong>網路層</strong>定義網路路由、定址功能，IP(Internet Protocol)會將 IP 位址加入傳輸資料內，並將資料組成封包。<br><strong>傳送層</strong>負責資料傳輸和控制，將大型資料切割成適合傳輸的大小型式，替應用層提供流量管制及錯誤控制。<br><strong>應用層</strong>建立網路連線、將ASCII編碼轉成應用層可用資料，負責加密、解密資料等，連結瀏覽器和伺服器之間的溝通。</p>
<h1 id="HTTP-vs-HTTPS"><a href="#HTTP-vs-HTTPS" class="headerlink" title="HTTP vs. HTTPS"></a>HTTP vs. HTTPS</h1><p>現代網路資料傳遞的原則有：</p>
<ol>
<li>標準化的內容格式</li>
<li>資料結構分為 header 和 body</li>
<li>使用狀態碼 HTTP Status Code 標準化傳輸結果<ul>
<li>HTTP Status Code<ul>
<li>2XX 成功：<ul>
<li>200 ok</li>
<li>204 no content</li>
</ul>
</li>
<li>3xx 重新導向:<ul>
<li>301 永久搬遷</li>
<li>302 暫時搬遷</li>
</ul>
</li>
<li>4xx 用戶端錯誤:<ul>
<li>404 Not Found</li>
<li>401 Unauthorized：未認證，表示 client-side 沒有必要的憑證或伺服器拒絕了 client-side 提供的憑證。</li>
<li>403 Forbidden：伺服器理解請求，但是拒絕執行，表示 client-side 沒有權限。</li>
</ul>
</li>
<li>5xx 伺服器端錯誤<br>502 Bad Gateway：表示伺服器的某個服務沒有正確執行，可能是處理請求的時間太長或伺服器主機問題。</li>
</ul>
</li>
</ul>
</li>
</ol>
<blockquote>
<p><a href="https://noob.tw/http-status-code/" target="_blank" rel="noopener">常見與不常見的 HTTP Status Code</a></p>
</blockquote>
<ol start="4">
<li><p>用動詞 HTTP Method 標準化動作： GET、POST、DELETE、PUT、PATCH</p>
<ul>
<li>HTTP Method<ul>
<li>GET：透過 API 把資料內容撈出來，這些內容通常是可以對外公布，不需要密碼帳號就可以取得的資料。</li>
<li>POST：新增一筆資料</li>
<li>DELETE：刪除資料</li>
<li>PUT：更新一筆資料，如果存在這筆資料就會覆蓋過去</li>
<li>PATCH：部分更新資料</li>
</ul>
</li>
</ul>
</li>
<li><p>protocol 通訊協定：定義資料交換的格式，標準化促成規模化 ex: HTTP、HTTPS</p>
<ul>
<li><p>HTTP(Hyper Text Transfer Protocol) 超文本傳輸協定<br>In 1989 Tim Berners-Lee invented the World Wide Web and built the HTTP for transferring HTML document around the world. HTTP is a protocol or the rules that we use over the wires. It is a foundation of any data exchange on the web.</p>
</li>
<li><p>HTTPS(Hyper Text Transfer Protocol Secure) 超文本安全傳輸協定<br>HTTPS(Hyper Text Transfer Protocol Secure) use TLS and SSL technology to encrypt the information that transported. Only the server or client web could have the secret key to read the message.</p>
</li>
</ul>
<p>主要是由網景公司(Netscape)開發並內建於其瀏覽器中，之後廣泛發展於網際網路上，用於對資料進行壓縮傳輸及傳輸後解壓縮回正確資訊的操作。隨著網路的發達，資訊技術越來越透明，HTTP 的開放明文顯得在網際網路中，不再是這麼安全的傳送協定，知名企業網站及全球級大型網站 Google、Facebook 等皆採用 HTTPS 加密，作為預設連線方式，因此有使用者登入系統或或存取到機密敏感資料頁面等有建立會員、購物車、金流、刷卡機制服務的網站選擇使用HTTPS的傳送協定。HTTPS 其實就是在原本的 HTTP 協定中延伸加入 SSL(Secure Sockets Layer,傳輸層安全協議) 或 TLS(Transport Layer Security，傳輸層安全) 憑證的安全連線技術。</p>
<p>SSL/TLS 憑證是網頁伺服器和瀏覽器之間以加解密方式溝通的安全技術標準，透過憑證內的公開金鑰加密資料傳輸至伺服器端，伺服器端用私密金鑰解密來證明自己的身份，取得有效憑證後在網際網路上傳輸加密過的資料以達到資安的目的。當您在伺服器與連線至伺服器的瀏覽器上安裝 SSL 憑證時，SSL 憑證的存在會觸發 SLL (或 TLS) 協議，這將加密伺服器與瀏覽器之間 (或伺服器之間) 發送的資訊；詳細資料顯然更加複雜一些。</p>
<p>運作流程：</p>
<ol>
<li>SSL 在 TCP 連線建立後開始運作，啟動 SSL信號交換。</li>
<li>伺服器發送憑證至使用者，同時附上大量規格 (包括哪個版本的 SSL/TLS 以及使用哪個加密方法等。)</li>
<li>使用者檢查憑證的有效性，選擇雙方都支援的最高等級的加密，並使用這些方法啟動安全的工作階段。有很多組方法可用優勢各異，被稱為密碼組。</li>
<li>為了確保所有傳輸訊息的完整性與真實性，SSL 與 TLS 協議也包括使用訊息驗證程式碼的驗證程序。<br>這些方法聽上去冗長又複雜，但在現實生活中是瞬間實現的。<br>SSL 直接在傳輸控制協議之上 (TCP) 運作，像安全感毛毯一樣有效。其允許最高的協議層不變，同時仍然提供安全連線。所以在 SSL 層下，其他協議層可以照常運作。若 SSL 憑證使用正確，所有攻擊者將看到哪個 IP 與通訊埠已連線以及大概在發送多少資料。他們或許可以終止連線，但是伺服器與使用者可以知道這是由第三方造成的。但是，他們無法攔截任何資料，所以使攻擊從根本上變得無效。</li>
</ol>
<p>取得SSL憑證的方法就是向憑證廠商購買，SSL憑證費用依照加密的等級、販售廠商而有所不同，可以依照網站性質與企業規模選擇SSL的加密程度以及衡量費用支出。一般來說，SSL憑證的發行廠商是不會影響搜尋排名，但是Google Chrome於2017年公布賽門鐵克(Symantec)發行的SSL視為無效化，並於2018/3/7公布Chrome 66連上賽門鐵克的SSL時呈現的警告畫面，被Chrome 視為無效的SSL憑證發行商名單:Thawte、VeriSign、Equifax、GeoTrust、RapidSSL、Symantec。</p>
</li>
</ol>
<h1 id="AJAX-and-JSON"><a href="#AJAX-and-JSON" class="headerlink" title="AJAX and JSON"></a>AJAX and JSON</h1><p>AJAX (<strong>Asynchronous JavaScript And XML/JSON</strong>) 非同步的 JavaScript 與 XML 技術，這是在2005年由Jesse James Garrett所發明的術語，描述一個使用多種既有技術的新方法。這些技術包括 HTTPS/HTTP 通訊協定、發 HTTP Request 方法(例如 fetch api)、XHR(XMLHttpRequest)或 JSON。使用 AJAX 能使網頁應用程式更快速、即時的更動介面內容，而不需要刷新整個頁面，讓程式更快回應使用者的操作，可以在網頁操作過程當中，不用刷新網頁就可以得到新的資訊。</p>
<ul>
<li><p>JavaScript：在 AJAX 技術裡，使用 JavaScript 將所有技術串連，當 server 回傳對應的資料給 client 時，我們可以透過 JavaScript 去解析和拆解這些資料，並使用 DOM 提供的方法把資料放進網頁。</p>
</li>
<li><p>非同步的 JavaScript：使用非同步的請求和回應，這表示當使用者點擊網頁中的一個連結時，即使該操作還未結束，仍可以對網頁做其他操作，同步的話則無法。</p>
</li>
</ul>
<blockquote>
<p>非同步 Asynchronous：指可以同時進行多件任務，而不需等待前一任務結束。同步 Synchronous:必須等待上一任務完成才能進行下一個。</p>
</blockquote>
<ul>
<li>XML/JSON：<ul>
<li>XML(Extensible Markup Language)：可延伸標記式語言是一種標記式語言，設計用來傳輸和儲存 data。標記指電腦所能理解的資訊符號，通過此種標記，電腦之間可以處理包含各種資訊的文章等。如何定義這些標記，既可以選擇國際通用的標記式語言，比如HTML，也可以使用像XML這樣由相關人士自由決定的標記式語言，這就是語言的可延伸性。XML是從標準通用標記式語言中簡化修改出來的。</li>
<li>JSON(JavaScript Object Notation)：是一種由道格拉斯·克羅克福特構想和設計、輕量級的資料交換語言，將結構化資料 (structured data) 呈現為 JavaScript 物件的標準格式，常用於網站上的資料呈現、傳輸 (例如將資料從伺服器送至用戶端，以利顯示網頁) JSON 可能是物件或字串，當你想從 JSON中讀取資料時，JSON可作為物件；當要跨網路傳送 JSON 時，就會是字串，因為 JSON 可以通過一個標準的 JS 函數解析(JSON.parse()將接收到的 JSON 內容解析成 JavaScript Object、JSON.stringfy()將 Object 轉成 sever 可以傳輸的 JSON string)，我們可以將任何 Object 轉換成 JSON，並使用 JSON 和 server 溝通，再由 JSON 轉換收到的訊息成 JavaScript Object。</li>
</ul>
</li>
</ul>
<p>兩者都是以讓人閱讀的文字為基礎，可以被轉譯成程式語言使用，讓文件能夠很容易地讓人去閱讀，同時又很容易讓電腦程式去辨識的語言格式和語法，不過 XML 相較之下更難被解析(parse)，須使用專屬的解析器，而 JSON 不須使用 end tag，JSON is parse into a ready-to-use JS Object，讀寫更簡潔、快速，可以使用 arrays(objects)格式來儲存資料，雖然 JSON 是以 JavaScript 語法為基礎，但可獨立使用，且許多程式設計環境亦可讀取 (剖析) 並產生 JSON。所以現在多使用 JSON 格式來傳輸資料。</p>
<ul>
<li><p>XHR(XMLHttpRequest)：是一個 JavaScript 物件，他的功能是用來向 server 發送非同步請求，在 XHR 技術剛被開發出來時，<br>使用 XML 作為請求、回應的資料格式，因此被稱為 XMLHttpRequest。現今提到 XMLHttpRequest 時已經不限於使用 XML 資料格式，也可以傳遞 XML、JSON、String 等多種資料格式。</p>
</li>
<li><p>AJAX 進化史：</p>
<ul>
<li>XHR(XMLHttpRequest) 大約10幾年前</li>
<li>XHR(XMLHttpRequest) v2 大約10年前</li>
<li>jQuery + XHR</li>
<li>現在：Fetch API、Axios、Request、SuperAgent、Supertest等<ul>
<li>Fetch：由 Mozilla 和 Google browser 在 2015年3月發佈實作的消息，它有不同於XHR思考角度的設計，基於 promise 的語法結構，而且設計足夠低階所以有更多彈性可擴展設定。目前不同瀏覽器版本還有不完全支援的，所以需要安裝 polyfill 當作暫時的解決方案。</li>
<li>Axios：Promise-based HTTP library for performing HTTP requests on both Node.js and Browser. It supports all mordern browser, even an included support for IE 8+. It’s built on top of XMLHttpRequest for making AJAX calls. It lets you make HTTP requests from both the browser and the server. <ul>
<li>Intercept requests and responses before they are carried out.</li>
<li>Transform request and response data using promises.</li>
<li>Automatically transforms JSON data.</li>
<li>Cancel live requests.</li>
<li>可以對 response setTimeout</li>
<li>Support protection against CSRF.</li>
<li>Has support for upload progress.</li>
</ul>
</li>
<li>Request - A Simplified HTTP Client：The Request library is one of the simplest ways to make HTTP calls. The structure and syntax are very similar to that of how requests are handled in Node.js.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var request = require(&apos;request&apos;);</span><br><span class="line">request(&apos;http://www.google.com&apos;, function (error, response, body) &#123;</span><br><span class="line">  console.log(&apos;error:&apos;, error); // Print the error if one occurred</span><br><span class="line">  console.log(&apos;statusCode:&apos;, response &amp;&amp; response.statusCode); // Print the response status code if a response was received</span><br><span class="line">  console.log(&apos;body:&apos;, body); // Print the HTML for the Google homepage.</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>Making HTTP calls from the client-side wasn’t this easy a decade ago. A front-end developer would have to rely on XMLHttpRequest which was hard to use and implement. The modern libraries and HTTP clients make the front-end features like user interactions, animations, asynchronous file uploads, etc., easier. </p>
<h1 id="RESTful-API"><a href="#RESTful-API" class="headerlink" title="RESTful API"></a>RESTful API</h1><ul>
<li>API (Application Programming Interface) 應用程式介面<br>是一種廣義的稱呼，主要是指 Application 與資料庫的互動介面。透過這個介面，開發者可以了解如何和提供這個介面的 Application 互動。<br>其中一種 API 又可以稱作 Web API，也是現在最廣泛出現的，他是指程式開發者提供一個網址 url 來讓其他開發者訪問，並提供使用這個 API 的文件（說明書），這樣其他開發者就可以閱讀文件了解如何使用這個 API 來存取所需的資料。</li>
</ul>
<p>串接 API 指的就是在開發時透過程式介面操作資料；一個應用程式通常會開發其程式介面提供串接、讀取資料或應用服務，提供一套標準讓任何想接入應用程式服務的開發者，可以遵循規範、根據介面的設計撰寫程式碼，來得到想要的服務或資料。串接 API 的本質就是交換資料，通常我們會根據文件說明來使用他人寫好的 API，若要主動提供 API 時則需定義要給什麼資料。</p>
<ul>
<li>Web API 或 HTTP API<br>透過 HTTP 協定的 API，也就是用 HTTP 格式來提供資料的 API 可以稱為 Web API/HTTP API。根據 HTTP 規範，伺服器端和客戶端進行請求和回應時，會使用定義明確的請求格式(request format)和回應格式(response format)，request format 指的是 client-side 需使用特定的 HTTP verb 對 url 發出請求，response format 則是指 server-side 回應時採用的資料格式，有可能是 XML、JSON等。</li>
</ul>
<p>HTTP 的組成元素：</p>
<table>
<thead>
<tr>
<th>HTTP request</th>
<th>HTTP response</th>
</tr>
</thead>
<tbody><tr>
<td>HTTP Method</td>
<td>Response Status</td>
</tr>
<tr>
<td>HTTP Headers</td>
<td>Response Headers</td>
</tr>
<tr>
<td>Request Body</td>
<td>Response Body</td>
</tr>
</tbody></table>
<p>HTTP URL 組成：例如<code>https://www.example.com/photos?page=1</code><br>通訊協定 <code>https://</code>、網域名稱 DNS <code>www.example.com</code>、路徑 path <code>/photos</code>、參數 parameter<code>?page=1</code>(又稱 query string)</p>
<ul>
<li><p>RESTful API<br>RESTful 風格也是一種格式(format)，<strong>RESTful API 就是指一種寫 API 格式的風格建議，目的是讓大家的寫法更有一致性。</strong></p>
<ul>
<li>REST<br>REST 是 Representational State Transfer 的縮寫，由 Roy Fielding 博士在 2000 年的博士論文中所提出。他同時也是 HTTP 規範的主要作者之一。REST 是一種軟體架構風格（並非標準），目的是幫助在世界各地不同軟體、程式在網際網路中能夠互相傳遞訊息。而每一個網頁都可視為一個資源（resource）提供使用者使用，以資源操作的概念(指的是對某項資源，譬如 User、Post 等，指派 Show、Edit 等動作)，結合 URL path 與 HTTP Method ，目的是使 URL path 更為簡潔、容易被理解，除了介面簡潔之外，尚有增加快取 cache 效率、提升 api 活用性等優點。換句話說， REST 風格可以單從 HTTP request 就能看出如何操作伺服器的資料。</li>
</ul>
<p>REST 的一個最重要的觀念就是 resources (特定資訊的資源)，每一個 resource 由一個 global identifier (即 URL)所表示。為了操作這些 resources，網路的 components (client 跟 server) 透過標準化的介面 (HTTP) 來溝通並交換這些 resources 的 representations (實際上傳達資訊的文件)。<br>任意數量的 connectors (如 clients, servers, caches, tunnels 等) 可以居中 request，但是都不可以 “seeing past” (不需要其他layer層)。這樣的應用程式跟一個 resource 互動根據兩件事情: resource 的 URL 跟要做的動作 — 它不需要知道是否有 caches, proxies, gateways, firewalls, tunnels, 或其他任何藏在 sever 之間的東西。這個應用程式只需要知道資訊的格式 (representation)，通常是 HTML 或 XML 或圖片什麼的。</p>
<ul>
<li>RESTful<br>設計為 REST 的系統稱為 RESTful。RESTful 路由便是充分應用 REST 風格的路由設置。而你可以透過 HTTP URL(Uniform Resource Locator)，也就是這些資源的地址(俗稱網址)，來取得這些資源並在你的瀏覽器上使用。<br>RESTful API 建議我們使用 Standard HTTP Verb 來撰寫 API，並根據 API 接口的提供目的規劃 URL，例如 /resouces、/resouces/:id 來代表 resource collection 以及 individual resource 的 path 來規劃 API 介面。<br>路由(routing)是指定義 app 如何將 client requset 指向一個正確的接口(endpoint)並做出相應的後續處理(給予 response)，一個 route 通常由下組成：<br><code>app.METHOD(PATH, HANDLER)</code><br>METHOD means HTTP request method, PATH is a path on the server and the HANDLER is the function executed when the routes is matched. PATH 是開放給 client 的 route，透過不同 path 導向不同動作。<br>舉例：一個簡單的 route based on express.js：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">app.get(&apos;/&apos;, function(req, res)&#123;</span><br><span class="line">  res.send(&apos;hello world&apos;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><code>&#39;/&#39;</code>表示根目錄(root route)</p>
</li>
</ul>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="https://dzone.com/articles/top-javascript-libraries-for-making-ajax-calls" target="_blank" rel="noopener">Top JavaScript Libraries for Making AJAX Calls</a><br><a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API" target="_blank" rel="noopener">Fetch API</a><br><a href="https://www.awoo.com.tw/blog/https-seo/" target="_blank" rel="noopener">HTTPS的威力？「S」對SEO與網站經營的四大重要性</a><br><a href="https://www.websecurity.digicert.com/zh/hk/security-topics/what-is-ssl-tls-https" target="_blank" rel="noopener">SSL 憑證</a><br><a href="https://progressbar.tw/posts/98" target="_blank" rel="noopener">為何HTTPS憑證有貴有便宜還更可以免費？讓我們從CA原理開始講起。</a></p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="https://chinyun.github.io/myblog/myblog/2019/11/02/CORS/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="chinyun">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/myblog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jinny's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/myblog/2019/11/02/CORS/" class="post-title-link" itemprop="url">CORS</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-11-02 21:00:05" itemprop="dateCreated datePublished" datetime="2019-11-02T21:00:05+00:00">2019-11-02</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-11-11 12:44:14" itemprop="dateModified" datetime="2019-11-11T12:44:14+00:00">2019-11-11</time>
              </span>
            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="什麼是-CORS"><a href="#什麼是-CORS" class="headerlink" title="什麼是 CORS?"></a>什麼是 CORS?</h1><p>Cross-Origin Resource Sharing 跨來源資源共享，這是由 W3C 頒布的一種瀏覽器技術規範，透過傳輸 HTTP Header 判斷阻擋或允許不同來源網域的資源存取。</p>
<p>當使用者請求一個不是目前文件來源，例如不同網域(domain/host)、通訊協定(protocol)或通訊埠(port)的資源時，會建立一個<strong>跨來源 HTTP 請求</strong>(cross-origin http request)。</p>
<p>而瀏覽器基於安全性考量，程式碼所發出的跨來源 HTTP 請求會受到限制，若不受限制的話，駭客可以透過撰寫程式碼跨域撈資料來進行跨站腳本攻擊(XSS)，而這個限制只有在瀏覽器上，若在本機使用 node.js 則沒有限制。</p>
<h2 id="同源政策（same-origin-policy）"><a href="#同源政策（same-origin-policy）" class="headerlink" title="同源政策（same-origin policy）"></a>同源政策（same-origin policy）</h2><p>在同源政策（same-origin policy）中規範了那寫資源可以跨源存取，哪些會受到限制。<br>同源的定義簡單如下：</p>
<ul>
<li>不同網域（Domain）</li>
<li>不同通訊協定：HTTP, HTTPS, FTP</li>
<li>不同連接埠號（Port）</li>
</ul>
<p>只要瀏覽器發的 request 與 server 所屬不同源，request 就會被瀏覽器阻擋。不過即便擋下來，其實 request 已經發出去，server 也確實給予瀏覽器 response，只是瀏覽器基於同源政策，因此不把拿到的回應給你的 JavaScript 去做進一步的處理。</p>
<p>一般來說跨來源寫（Cross-origin writes）、跨來源嵌入（Cross-origin embedding）是被允許的，而跨來源讀取（Cross-origin reads）是受限制的。</p>
<ol>
<li>受同源政策管理的跨來源請求：<br>XMLHttpRequest 及 Fetch 都遵守同源政策(same-origin policy)，<strong>這代表網路應用程式所使用的 API 除非使用 CORS 標頭否則只能請求與應用程式相同網域的 HTTP 資源</strong>。<br>如果想開啟跨來源 HTTP 請求的話， server 必須在 response 的 header 加上 <code>Access-Control-Allow-Origin: *</code>表示接受所有不同來源的跨域請求，或者可以指定接受特定網址的跨域請求：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Origin: http://foo.example</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>其他方法還有：</p>
<ul>
<li>Access-Control-Allow-Headers：指定哪些 HTTP 標頭可以於實際請求中使用。</li>
<li>Access-Control-Allow-Methods：GET, POST, PUT，存取資源所允許的方法，用來回應預檢請求。</li>
<li>Access-Control-Expose-Headers：瀏覽器能夠存取伺服器回應當中哪些標頭。</li>
<li>Access-Control-Max-Age：預檢請求之結果可以被快取的秒數。</li>
<li>Access-Control-Allow-Credentials：用於驗證請求中，用來告知瀏覽器是否允許 client-side 向 server-side 傳送 cookie，默認為 false：CORS 規範會阻止跨域 AJAX 向 server-side 發送 cookie。</li>
</ul>
<ol start="2">
<li>不受同源政策管理的 html tags 包括：<code>&lt;script src=&#39;&#39; /&gt;</code>、<code>&lt;img/&gt;</code>、<code>&lt;video/&gt;</code>、<code>&lt;audio/&gt;</code>、<code>&lt;iframe/&gt;</code>、<code>&lt;link rel=&#39;stylesheet&#39; href /&gt;</code> 這些資源本來就能夠跨域存取。</li>
</ol>
<h2 id="JSON-with-Padding-JSONP"><a href="#JSON-with-Padding-JSONP" class="headerlink" title="JSON with Padding(JSONP)"></a>JSON with Padding(JSONP)</h2><p>JSONP 是一個利用 script tag 不受同源政策限制的特性，直接載入帶參數的 js 程式碼的跨來源請求實作方法，實務上在操作 JSONP 的時候，Server 通常會提供一個callback的參數讓 client 端帶過去。</p>
<p>Twitch API 有提供 JSONP 的版本，我們可以直接來看範例：</p>
<p>URL: <a href="https://api.twitch.tv/kraken/games/top?client_id=xxx&amp;callback=receiveData&amp;limit=1" target="_blank" rel="noopener">https://api.twitch.tv/kraken/games/top?client_id=xxx&amp;callback=receiveData&amp;limit=1</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">receiveData(&#123;&quot;_total&quot;:1067,&quot;_links&quot;:&#123;&quot;self&quot;:&quot;https://api.twitch.tv/kraken/games/top?limit=1&quot;,&quot;next&quot;:&quot;https://api.twitch.tv/kraken/games/top?limit=1\u0026offset=1&quot;&#125;,&quot;top&quot;:[&#123;&quot;game&quot;:&#123;&quot;name&quot;:&quot;Dota 2&quot;,&quot;popularity&quot;:63361,&quot;_id&quot;:29595,&quot;giantbomb_id&quot;:32887,&quot;box&quot;:&#123;&quot;large&quot;:&quot;https://static-cdn.jtvnw.net/ttv-boxart/Dota%202-272x380.jpg&quot;,&quot;medium&quot;:&quot;https://static-cdn.jtvnw.net/ttv-boxart/Dota%202-136x190.jpg&quot;,&quot;small&quot;:&quot;https://static-cdn.jtvnw.net/ttv-boxart/Dota%202-52x72.jpg&quot;,&quot;template&quot;:&quot;https://static-cdn.jtvnw.net/ttv-boxart/Dota%202-&#123;width&#125;x&#123;height&#125;.jpg&quot;&#125;,&quot;logo&quot;:&#123;&quot;large&quot;:&quot;https://static-cdn.jtvnw.net/ttv-logoart/Dota%202-240x144.jpg&quot;,&quot;medium&quot;:&quot;https://static-cdn.jtvnw.net/ttv-logoart/Dota%202-120x72.jpg&quot;,&quot;small&quot;:&quot;https://static-cdn.jtvnw.net/ttv-logoart/Dota%202-60x36.jpg&quot;,&quot;template&quot;:&quot;https://static-cdn.jtvnw.net/ttv-logoart/Dota%202-&#123;width&#125;x&#123;height&#125;.jpg&quot;&#125;,&quot;_links&quot;:&#123;&#125;,&quot;localized_name&quot;:&quot;Dota 2&quot;,&quot;locale&quot;:&quot;zh-tw&quot;&#125;,&quot;viewers&quot;:65622,&quot;channels&quot;:376&#125;]&#125;)</span><br></pre></td></tr></table></figure>

<p>結合起來就是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;https://api.twitch.tv/kraken/games/top?client_id=xxx&amp;callback=receiveData&amp;limit=1&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  function receiveData (response) &#123;</span><br><span class="line">    console.log(response);</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>利用 JSONP 也可以存取跨來源的資料。但 JSONP 的缺點就是你要帶的那些參數永遠都只能用附加在網址上的方式（GET）帶過去，沒辦法用 POST。</p>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="https://blog.techbridge.cc/2017/05/20/api-ajax-cors-and-jsonp/" target="_blank" rel="noopener">輕鬆理解 Ajax 與跨來源請求</a><br><a href="https://pjchender.github.io/2018/08/20/%E5%90%8C%E6%BA%90%E6%94%BF%E7%AD%96%E8%88%87%E8%B7%A8%E4%BE%86%E6%BA%90%E8%B3%87%E6%BA%90%E5%85%B1%E7%94%A8%EF%BC%88cors%EF%BC%89/" target="_blank" rel="noopener">[JS] 同源政策與跨來源資源共用（CORS）</a></p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="https://chinyun.github.io/myblog/myblog/2019/11/02/CSRF-XSS-SQL-injection/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="chinyun">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/myblog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jinny's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/myblog/2019/11/02/CSRF-XSS-SQL-injection/" class="post-title-link" itemprop="url">CSRF, XSS, SQL injection</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-11-02 20:32:24" itemprop="dateCreated datePublished" datetime="2019-11-02T20:32:24+00:00">2019-11-02</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-11-11 12:44:14" itemprop="dateModified" datetime="2019-11-11T12:44:14+00:00">2019-11-11</time>
              </span>
            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Web Security 網頁安全泛指針對網頁、網站上的資訊安全，涵蓋程式漏洞、邏輯漏洞、資訊洩漏等。</p>
<p>#Cross Site Request Forgery(XSRF or CSRF)</p>
<p>指在受害者不知情狀況下，被其他網域借用身份來完成未經同意的 HTTP Request。<br>當網站使用 cookie-based authentication，會把 session id 和 session data 存在 cookie 中，剛使用者曾在其他網站登入而未登出，並且進入惡意網站操作時，攻擊者利用可以進行跨域 http 請求的 http tag(ex: img、iframe等)埋入惡意的 request 程式碼，觸發後因為使用者未登出，因此攻擊者獲得 cookie 資料，攻擊者得以冒用使用者身份通過驗證。得以任意改變使者者在資料庫的資料。</p>
<p>同源政策對於連結(links)、重新導向(redirect)、表單(form)等的跨來源存取都是寬鬆的，因此駭客利用此特性做 CSRF 攻擊。</p>
<p>如何防範：</p>
<ol>
<li>使用 token-based authentication</li>
<li>使用 HttpOnly 來防止 Cookie 被 JavaScript 讀取</li>
<li>目前各大成熟的框架，都有針對傳遞資料做 CSRF 驗證，網站會產生的一組密碼，並在請求送出時，檢查那組密碼是否正確。</li>
</ol>
<p>Cross Site Request Forgery attacks are not an issue if you are using JWT with local storage. On the other hand, if your use case requires you to store the JWT in a cookie, you will need to protect against XSRF. XSRF are not as easily understood as XSS attacks. Explaining how XSRF attacks work can be time-consuming, so instead, check out this really good guide that explains in-depth how XSRF attacks work. Luckily, preventing XSRF attacks is a fairly simple matter. To over-simplify, protecting against an XSRF attack, your server, upon establishing a session with a client will generate a unique token (note this is not a JWT). Then, anytime data is submitted to your server, a hidden input field will contain this token and the server will check to make sure the tokens match. Again, as our recommendation is to store the JWT in <strong>local storage</strong>, you probably will not have to worry about XSRF attacks.</p>
<p>One of the best ways to protect your users and servers is to have a <strong>short expiration time</strong> for tokens. That way, even if a token is compromised, it will quickly become useless. Additionally, you may maintain a blacklist of compromised tokens and not allow those tokens access to the system. Finally, the nuclear approach would be to change the signing algorithm, which would invalidate all active tokens and require all of your users to log in again. This approach is not easily recommended, but is available in the event of a severe breach.</p>
<h1 id="Cross-Site-Scripting-XSS"><a href="#Cross-Site-Scripting-XSS" class="headerlink" title="Cross Site Scripting(XSS)"></a>Cross Site Scripting(XSS)</h1><p>「XSS攻擊通常指的是通過利用網頁開發時留下的漏洞，通過巧妙的方法注入惡意指令程式碼到網頁，使用戶載入並執行攻擊者惡意製造的網頁程式。 這些惡意網頁程式通常是JavaScript，但實際上也可以包括Java，VBScript，ActiveX，Flash或者甚至是普通的HTML。」–wikipedia</p>
<p>使用者以為安全進入網站後反而被導向到釣魚網站、甚至被竊取帳號密碼、個人資料。<br>目前 XSS 攻擊的種類大致可以分成以下幾種類型：</p>
<ul>
<li><p>Stored XSS (儲存型)：<br>會被保存在伺服器資料庫中的 JavaScript 代碼引起的攻擊即為 Stored XSS，最常見的就是論壇文章、留言板等等，因為使用者可以輸入任意內容，若沒有確實檢查，那使用者輸入如 ｀<code>&lt;script&gt;</code> 等關鍵字就會被當成正常的 HTML 執行，標籤的內容也會被正常的作為 JavaScript 代碼執行。</p>
</li>
<li><p>Reflected XSS (反射型)：<br>由網頁後端直接嵌入由前端使用者所傳送過來的內容造成的，最常見的就是以 GET 方法傳送資料給伺服器時，伺服器未檢查就將內容回應到網頁上所產生的漏洞。</p>
</li>
<li><p>DOM-Based XSS (基於 DOM 的類型):<br>網頁上的 JavaScript 在執行過程中，沒有詳細檢查，輸入任意的內容都會被建立成有效的 DOM 物件，包含嵌入的代碼也會被執行，使得操作 DOM 的過程代入了惡意指令。但這樣的攻擊除非攻擊者親自到受害者電腦前輸入，否則不可能讓受害者輸入這種惡意代碼，通常需要搭配前兩個手法；讓內容保存在伺服器資料庫中、或是以反射型的方式製造出內容，再藉由JavaScript 動態產生有效的 DOM 物件來運行惡意代碼。</p>
</li>
</ul>
<p>如何防範：</p>
<ol>
<li><p>前兩種 Stored、Reflected 的類型都必須由後端進行防範，除了必要的 HTML 代碼，任何允許使用者輸入的內容都需要檢查，刪除所有「<code>&lt;script&gt;</code>」、「 <code>onerror=</code>」及其他任何可能執行代碼的字串。</p>
</li>
<li><p>DOM-Based 則必須由前端來防範，但基本上還是跟前面的原則相同。<br>另外不同的一點就是應該選擇正確的方法、屬性來操作 DOM，譬如<code>document.getElementById(&#39;show_name&#39;).innerHTML = name;</code> 中的<code>innerHTML</code>屬性代表插入的內容是合法的 HTML 字串，所以字串會解析成 DOM 物件，此處使用<code>innerText</code>會被保證作為純粹的文字，也就不可能被插入惡意代碼執行了。</p>
</li>
</ol>
<p>Cross Site Scripting attacks occur when an outside entity is able to execute code within your website or app. The most common attack vector here is if your website allows <strong>inputs</strong> that are not properly sanitized. <strong>If an attacker can execute code on your domain, your JWT tokens are vulnerable.</strong> Our CTO has argued in the past that XSS attacks are much easier to deal with compared to XSRF attacks because they are generally better understood. <strong>Many frameworks, including Angular, automatically sanitize inputs and prevent arbitrary code execution.</strong> If you are not using a framework that sanitizes input/output out-of-the-box, you can look at plugins like caja developed by Google to assist. Sanitizing inputs is a solved issue in many frameworks and languages and I would recommend using a framework or plugin vs building your own.</p>
<h1 id="SQL-injection"><a href="#SQL-injection" class="headerlink" title="SQL injection"></a>SQL injection</h1><p>「Injection 是一種駭客常用的攻擊概念，透過注入惡意的程式碼的方式，破壞原本程式碼的語意，來達到攻擊的效果。SQL 是網站常用來取得資料的程式語法，SQL Injection 便是駭客透過修改 SQL 語句，改變他的語意，達成竊取資料/破壞資料的行為。」<br>–<a href="https://medium.com/@jaydenlin/淺談駭客攻擊-網站安全-一次看懂-sql-injection-的攻擊原理-b1994fd2392a" target="_blank" rel="noopener">一次看懂 SQL Injection 的攻擊原理</a></p>
<p>「在輸入的字串之中夾帶SQL指令，在設計不良的程式當中忽略了字元檢查，那麼這些夾帶進去的惡意指令就會被資料庫伺服器誤認為是正常的SQL指令而執行，因此遭到破壞或是入侵。」<br>–wikipedia</p>
<p>「在 SQL 語法中常會出現攻擊者可以透過更改語法邏輯或加入特殊指令的方式，在未設定過濾惡意程式碼的情況下，資料庫伺服器（DataBase）會直接接收使用者所輸入的 SQL 指令並執行攻擊代碼，使攻擊者能夠取得最高權限，得以擅自竊取、修改、挪動或刪除資料的可能。此類漏洞無疑的會對公司或商號造成相當大的損傷。」<br>–<a href="https://ithelp.ithome.com.tw/articles/10189201" target="_blank" rel="noopener">攻擊行為－SQL 資料隱碼攻擊 SQL injection</a></p>
<p>常見攻擊手法：</p>
<ul>
<li>Authorization Bypass（略過權限檢查）</li>
<li>Injecting SQL Sub-Statements into SQL Queries（注入 SQL 子語法）</li>
<li>Exploiting Stored Procedures（利用預存程序）</li>
</ul>
<p>防範手法：</p>
<ul>
<li>使用 SQL query builder for JavaScript - knex.js：</li>
</ul>
<p>Read carefully from knex documentation how to pass values to knex raw (<a href="http://knexjs.org/#Raw" target="_blank" rel="noopener">http://knexjs.org/#Raw</a>).</p>
<p>If you are passing values as parameter binding to raw like:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">knex.raw(&apos;select * from foo where id = ?&apos;, [1])</span><br></pre></td></tr></table></figure>

<p>In that case parameters and query string are passed separately to database driver protecting query from SQL injection.</p>
<p>Other query builder methods always uses binding format internally so they are safe too.</p>
<p>Biggest mistake that one can do with knex raw queries is to use javascript template string and interpolate variables directly to SQL string format like:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">knex.raw(`select * from foo where id = $&#123;id&#125;`) // NEVER DO THIS</span><br></pre></td></tr></table></figure>

<p>One thing to note is that knex table/identifier names cannot be passed as bindings to driver, so with those one should be extra careful to not read table / column names from user and use them without properly validating them first.</p>
<p>Refer from:<a href="https://stackoverflow.com/questions/49665023/does-knex-js-prevent-sql-injection/49665379" target="_blank" rel="noopener">Does Knex.js prevent sql injection?</a></p>
<ul>
<li><p>使用 ORM(object relational mapping)：<br>在資料庫和 model資料容器之間的框架，他可以幫助開發者更簡便安全的去資料庫讀取資料，透過 ruby, java 等程式語言，去操作資料庫語言。同時因為是操作程式語言，若 query 中的值不符合預期格式，框架會自動擋掉而不會讓 SQL injection 成功。目前大部分的網站都是使用框架來開發，而這些框架都是使用 ORM 來處理他們的資料庫，因此在 ORM 的保護下，不是我們預期的資料格式，而是 SQL 語法的話，具有基本的保護能力。</p>
</li>
<li><p>參數化查詢（parameterized query 或 parameterized statement）：<br>是指在設計與資料庫連結並存取資料時，在需要填入數值或資料的地方，使用參數（parameter）來給值，這個方法目前已被視為最有效可預防SQL注入攻擊的攻擊手法的防禦方式。 – <a href="https://www.wikiwand.com/zh-tw/%E5%8F%83%E6%95%B8%E5%8C%96%E6%9F%A5%E8%A9%A2" target="_blank" rel="noopener">參數化查詢</a></p>
</li>
<li><p>使用 Regular expression 驗證過濾輸入值與參數中惡意代碼，將輸入值中的單引號置換為雙引號。</p>
</li>
<li><p>限制輸入字元格式並檢查輸入長度。</p>
</li>
<li><p>資料庫設定使用者帳號權限，限制某些管道使用者無法作資料庫存取。</p>
</li>
</ul>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="https://www.gnucitizen.org/blog/csrf-demystified/" target="_blank" rel="noopener">CSRF</a><br><a href="https://forum.gamer.com.tw/Co.php?bsn=60292&sn=11267" target="_blank" rel="noopener">網頁安全】給網頁開發新人的 XSS 攻擊 介紹與防範</a><br><a href="https://ithelp.ithome.com.tw/articles/10209227" target="_blank" rel="noopener">資安常見攻擊( Web ) 與學習方法</a></p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
  </div>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/myblog/page/2/">2</a><a class="page-number" href="/myblog/page/3/">3</a><a class="extend next" rel="next" href="/myblog/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>


          </div>
          

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">chinyun</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        
          <a href="/myblog/archives/">
        
          <span class="site-state-item-count">22</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
    
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">chinyun</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> v3.9.0</div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.4.1</div>
  <script src='https://unpkg.com/mermaid@7.1.2/dist/mermaid.min.js'></script>
  <script>
    if (window.mermaid) {
      mermaid.initialize("");
    }
  </script>

        












        
      </div>
    </footer>
  </div>

  
  <script src="/myblog/lib/anime.min.js?v=3.1.0"></script>
  <script src="/myblog/lib/velocity/velocity.min.js?v=1.2.1"></script>
  <script src="/myblog/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
<script src="/myblog/js/utils.js?v=7.4.1"></script><script src="/myblog/js/motion.js?v=7.4.1"></script>
<script src="/myblog/js/schemes/pisces.js?v=7.4.1"></script>
<script src="/myblog/js/next-boot.js?v=7.4.1"></script>



  

















<script>
if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.initialize({
      theme: 'forest',
      logLevel: 3,
      flowchart: { curve: 'linear' },
      gantt: { axisFormat: '%m/%d/%Y' },
      sequence: { actorMargin: 50 }
    });
  }, window.mermaid);
}
</script>




  

  

  

</body>
</html>
