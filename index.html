<!DOCTYPE html>





<html lang="zh-tw">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.9.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/myblog/images/apple-touch-icon-next.png?v=7.4.1">
  <link rel="icon" type="image/png" sizes="32x32" href="/myblog/images/favicon-32x32-next.png?v=7.4.1">
  <link rel="icon" type="image/png" sizes="16x16" href="/myblog/images/favicon-16x16-next.png?v=7.4.1">
  <link rel="mask-icon" href="/myblog/images/logo.svg?v=7.4.1" color="#222">

<link rel="stylesheet" href="/myblog/css/main.css?v=7.4.1">


<link rel="stylesheet" href="/myblog/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/myblog/',
    scheme: 'Pisces',
    version: '7.4.1',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: 'Copy',
      copy_success: 'Copied',
      copy_failure: 'Copy failed'
    },
    sidebarPadding: 40
  };
</script>

  <meta name="keywords" content="JavaScript, React, d3, NodeJS, Web">
<meta property="og:type" content="website">
<meta property="og:title" content="Jinny&#39;s blog">
<meta property="og:url" content="https://chinyun.github.io/myblog/index.html">
<meta property="og:site_name" content="Jinny&#39;s blog">
<meta property="og:locale" content="zh-tw">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Jinny&#39;s blog">
  <link rel="canonical" href="https://chinyun.github.io/myblog/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false,
    isPage: false,
    isArchive: false
  };
</script>

  <title>Jinny's blog</title>
  








  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-tw">
  <div class="container use-motion">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/myblog/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Jinny's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">Writing For Sharing</p>
      
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
      
      
      
        
        <li class="menu-item menu-item-home">
      
    

    <a href="/myblog/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-archives">
      
    

    <a href="/myblog/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
            

          <div id="content" class="content">
            
  <div id="posts" class="posts-expand">
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="https://chinyun.github.io/myblog/myblog/2019/11/13/JS-Shallow-Copy-Deep-Copy/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="chinyun">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/myblog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jinny's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/myblog/2019/11/13/JS-Shallow-Copy-Deep-Copy/" class="post-title-link" itemprop="url">JS-Shallow Copy & Deep Copy</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-11-13 19:12:02 / Modified: 12:13:55" itemprop="dateCreated datePublished" datetime="2019-11-13T19:12:02+00:00">2019-11-13</time>
            </span>
          
            

            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="為什麼會有深淺拷貝的差異？"><a href="#為什麼會有深淺拷貝的差異？" class="headerlink" title="為什麼會有深淺拷貝的差異？"></a>為什麼會有深淺拷貝的差異？</h1><p>因為 JavaScript 中，基本型別(primitve)與物件型別(object)的值的賦予方式不同，基本型別是 pass by value，物件型別是 pass by sharing。相關介紹可看：<a href="https://chinyun.github.io/myblog/2019/11/13/JS-pass-by-value-or-reference/">JS-pass by value or reference</a></p>
<p>因為值賦予方式的差異，在複製物件例如 object, array 等資料類型時，根據拷貝資料的形式，可以分為淺拷貝(shallow copy)及深拷貝(deep copy)。<br>對淺拷貝來說，只是複製 collection structure，而不是 element，With a shallow copy, two collections now share the individual elements. Collections can be diverse data structures which stores multiple data items.<br>因此對於基本型別來說，淺拷貝(用等號賦值)會傳值，但對物件型別來說，淺拷貝是傳遞 reference，讓兩者可以共用一個記憶體的物件資料，這樣的話在指派物件型別的資料的第二層或更深層內容時，會同時影響兩個地方。</p>
<p>淺拷貝只複製指向某個物件的指標，而不複製物件本身，新舊物件還是共用同一塊記憶體。<br>而深拷貝是整個複製，包含element，會另外創造一個一模一樣的物件，新物件跟原物件不共用記憶體，修改新物件不會改到原物件。所以當我們在使用有多層結構的物件資料時，要盡量用深拷貝。<br>一般物件如果用等號賦值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var obj1 = &#123; a: 10, b: 20, c: 30 &#125;;</span><br><span class="line">var obj2 = obj1;</span><br><span class="line">obj2.b = 100;</span><br><span class="line"></span><br><span class="line">console.log(obj1); // &#123; a: 10, b: 100, c: 30 &#125; &lt;-- b 被改到了</span><br><span class="line">console.log(obj2); // &#123; a: 10, b: 100, c: 30 &#125;</span><br></pre></td></tr></table></figure>

<h1 id="如何進行淺拷貝、深拷貝？"><a href="#如何進行淺拷貝、深拷貝？" class="headerlink" title="如何進行淺拷貝、深拷貝？"></a>如何進行淺拷貝、深拷貝？</h1><p>一般而言 基本型別的拷貝方法就是用 等號賦值，而物件型別例如 array 或 object等就有很多方式，依照拷貝的層次深度可以分為淺拷貝和深拷貝：如果物件中屬性的值也是物件，只能複製到<strong>第一層</strong>物件的屬性，而無法複製到屬性值的物件(第二層)，就無法達到實際的複製，而是會與舊物件一起共用同一塊記憶體；這樣的複製方法稱為「淺拷貝」。相反地，深拷貝會另外創造一個一模一樣的物件，新物件跟原物件不共用記憶體，修改新物件不會改到原物件。</p>
<ul>
<li><p>淺拷貝方法</p>
<ul>
<li><p><strong>Array.concat</strong>：一般Array.concat的用法是合併兩個陣列</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  var alpha = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;],</span><br><span class="line">    numeric = [1, 2, 3];</span><br><span class="line">  var alphaNumeric = alpha.concat(numeric);</span><br><span class="line">​  console.log(alphaNumeric); // [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, 1, 2, 3]</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Array.slice</strong>：一般Array.slice()的方法是複製一個新的陣列，可帶入參數 <code>Array.slice(start, end)</code>，當不輸入參數值的話會直接複製一個。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var animals = [&apos;ant&apos;, &apos;bison&apos;, &apos;camel&apos;, &apos;duck&apos;, &apos;elephant&apos;];</span><br><span class="line">console.log(animals.slice(2));</span><br><span class="line">// Array [&quot;camel&quot;, &quot;duck&quot;, &quot;elephant&quot;]</span><br><span class="line">​</span><br><span class="line">console.log(animals.slice(2, 4));</span><br><span class="line">// Array [&quot;camel&quot;, &quot;duck&quot;]</span><br><span class="line">​</span><br><span class="line">console.log(animals.slice());</span><br><span class="line">// Array [&apos;ant&apos;, &apos;bison&apos;, &apos;camel&apos;, &apos;duck&apos;, &apos;elephant&apos;];</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>手動複製</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var obj1 = &#123; a: 10, b: 20, c: 30 &#125;;</span><br><span class="line">var obj2 = &#123; a: obj1.a, b: obj1.b, c: obj1.c &#125;;</span><br><span class="line">obj2.b = 100;</span><br><span class="line"></span><br><span class="line">console.log(obj1); // &#123; a: 10, b: 20, c: 30 &#125; &lt;-- 沒被改到</span><br><span class="line">console.log(obj2); // &#123; a: 10, b: 100, c: 30 &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Object.assign</strong>：用來合併物件，用法為 <code>Object.assign(target, ...source)</code>若目標物件為空物件則可視為複製一個source的物件。<br><code>Object.assign({}, obj1)</code>的意思是先建立一個空物件{}，接著把obj1中所有的屬性複製過去，因為Object.assign跟我們手動複製的效果相同，所以一樣<strong>只能處理深度只有一層的物件</strong>，沒辦法做到真正的 Deep Copy，不過如果要複製的物件只有一層的話可以使用他。</p>
</li>
<li><p><strong>展開運算子(Spread Operator)</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let obj = &#123;name: &apos;王康寶&apos;, age:&#123;child: 18&#125;&#125;</span><br><span class="line">let copy = &#123;...obj&#125;;</span><br><span class="line"></span><br><span class="line">copy.name = &apos;盧卡斯&apos;;</span><br><span class="line">copy.age.child = 99;</span><br><span class="line"></span><br><span class="line">console.log(obj);  //&#123;name: &quot;王康寶&quot;, age:&#123;child: 99&#125;&#125;</span><br><span class="line">console.log(copy); //&#123;name: &quot;盧卡斯&quot;, age:&#123;child: 99&#125;&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>深拷貝方法</p>
<ul>
<li><strong>JSON.parse(JSON.stringify(object_array))</strong>:<ul>
<li>JSON.parse():把字串轉成物件</li>
<li>JSON.stringify():把物件轉成字串<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">  let obj1 = &#123; a:&#123;b:10&#125; &#125;;</span><br><span class="line">  let obj2_string = JSON.stringify(obj1);</span><br><span class="line">  console.log(obj2_string); //&quot;&#123;&quot;a&quot;:&#123;&quot;b&quot;:10&#125;&#125;&quot;;</span><br><span class="line">​</span><br><span class="line">  let obj2 = JSON.parse(obj2_string);</span><br><span class="line">  console.log(obj2); //&#123;a:&#123;b:10&#125;&#125;</span><br><span class="line">​</span><br><span class="line">  obj2.a.b = 20;</span><br><span class="line">  console.log(obj1); //&#123;a:&#123;b:10&#125;&#125;</span><br><span class="line">  console.log(obj2); //&#123;a:&#123;b:20&#125;&#125;</span><br><span class="line">  ``` </span><br><span class="line">  只有可以轉成JSON格式的物件才可以這樣用，像 function、Set、Map..等型態就沒辦法轉成 JSON。</span><br><span class="line"></span><br><span class="line">  - **jQuery `$.extend`**</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<p>var $ = require(‘jquery’);</p>
<p>var obj1 = {<br>  a: 1,<br>  b: { f: { g: 1 } },<br>  c: [1, 2, 3]<br>};</p>
<p>var obj2 = $.extend(true, {}, obj1);<br>console.log(obj1.b.f === obj2.b.f); // false</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- **lodash `_.cloneDeep`**</span><br></pre></td></tr></table></figure>

<p>var _ = require(‘lodash’);<br>var obj1 = {<br>  a: 1,<br>  b: { f: { g: 1 } },<br>  c: [1, 2, 3]<br>};</p>
<p>var obj2 = _.cloneDeep(obj1);<br>console.log(obj1.b.f === obj2.b.f); // false</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- **自己寫**</span><br><span class="line">例如下面這個在 react app 裡面用 slice() 和 Object.assign(target, ...sources) 來改變深層結構資料的方法：</span><br><span class="line">[GitHub Repo:Tripper-app](https://github.com/chinyun/Tripper-app/blob/master/src/containers/App.js)</span><br></pre></td></tr></table></figure>

<p>updateBudgets = (journey, journeyId) =&gt; {<br>  const index = this.state.journeyList.findIndex(item =&gt; item.id === journeyId);<br>  if (index !== -1) {</p>
<pre><code>this.setState({
  journeys: [
    ...this.state.journeys.slice(0, index),
    Object.assign({}, this.state.journeys[index], journey[0]),
    ...this.state.journeys.slice(index + 1)
  ]
})</code></pre><p>  }<br>};</p>
<pre><code></code></pre></li>
</ul>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="https://dustinhsiao21.com/2018/01/07/javascript-shallow-copy-and-deep-copy/" target="_blank" rel="noopener">關於JAVASCRIPT中的SHALLOW COPY(淺拷貝)及DEEP COPY(深拷貝)</a><br><a href="https://larry850806.github.io/2016/09/20/shallow-vs-deep-copy/" target="_blank" rel="noopener">[Javascript] 關於 JS 中的淺拷貝和深拷貝</a></p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="https://chinyun.github.io/myblog/myblog/2019/11/13/JS-pass-by-value-or-reference/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="chinyun">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/myblog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jinny's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/myblog/2019/11/13/JS-pass-by-value-or-reference/" class="post-title-link" itemprop="url">JS-pass by value or reference</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-11-13 17:35:56 / Modified: 12:13:55" itemprop="dateCreated datePublished" datetime="2019-11-13T17:35:56+00:00">2019-11-13</time>
            </span>
          
            

            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>問題：JavaScript 的 Object 到底是 pass by value 還是 pass by referece？</p>
<p>根據 JavaScript 的資料型態，可以分為兩大類：基本型別 primitive 和 物件型別 object。<br>基本型別的資料以 純值的形態存在，例如：number、string、boolean、null、undefined、symbol，而 object 的資料可能為 純值或多種不同型別組合而成的物件。</p>
<h1 id="基本型別的傳值-pass-by-value-vs-object型別的傳址-pass-by-referece"><a href="#基本型別的傳值-pass-by-value-vs-object型別的傳址-pass-by-referece" class="headerlink" title="基本型別的傳值 pass by value  vs. object型別的傳址 pass by referece"></a>基本型別的傳值 pass by value  vs. object型別的傳址 pass by referece</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var a = 10;</span><br><span class="line">var b = a;</span><br><span class="line">console.log(a === b); //true</span><br><span class="line"></span><br><span class="line">var c = 5;</span><br><span class="line">var d = 5;</span><br><span class="line">console.log(c === d); //true</span><br></pre></td></tr></table></figure>

<p><code>var b = a;</code> 表面上看起來變數 b 的內容是透過複製變數 a 而來，實際上變數 b 是去建立了一個新的值，然後將變數 a 的內容複製了一份存放到記憶體， a 和 b 其實是存在於兩個不同的記憶體位置，因此變數 a 和變數 b 彼此獨立互不相干，即使更改 a 的內容， b 的值也不會變：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a + 2;</span><br><span class="line">console.log(a); //12</span><br><span class="line">console.log(b); //10</span><br><span class="line">``` </span><br><span class="line">像這種情況，我們通常會稱作「傳值」 (pass by value)。</span><br><span class="line"></span><br><span class="line">如果是物件型別的資料：</span><br></pre></td></tr></table></figure>

<p>var obj1 = { a: 10 };<br>var obj2 = { a: 10 };<br>console.log(obj1 === obj2); //false</p>
<p>var obj3 = { b: 20 };<br>var obj4 = obj3;<br>console.log(obj3 === obj4); //true</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">「物件」這類資料型態，在 JavaScript 中是透過「引用」的方式傳遞資料的。</span><br><span class="line">當建立起一個新的物件並賦值給一個變數(`var obj3 = &#123; b: 20 &#125;;`)的時候，JavaScript 會在記憶體的某處存放這個物件(`&#123; b: 20 &#125;`)，再將變數(`obj3`)指向這個物件的存放位置，因此當`var obj4 = obj3;`的時候，其實是將 obj4 這個變數也指向了 `&#123; b: 20 &#125;`這個實體。</span><br><span class="line">這種透過引用的方式來傳遞資料，接收的其實是引用的「參考」而不是值的副本時，</span><br><span class="line">我們通常會稱作「傳址」 (pass by reference)。</span><br><span class="line"></span><br><span class="line"># 例外情況： pass by sharing</span><br></pre></td></tr></table></figure>

<p>var coin1 = { value: 10 };</p>
<p>function changeValue(obj) {<br>  obj = { value: 123 };<br>}</p>
<p>changeValue(coin1);<br>console.log(coin1.value);   // ？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">答案會是 10，因為當coin1指向的資料被做為 function 的參數傳入 function 時，即使資料在 function 內部被重新賦值，外部變數的內容都不會被影響。</span><br><span class="line">在這種情況底下，就代表你要讓這個 obj 指向一個新的 object`&#123; value: 123 &#125;`。因此不會影響到外部的 coin1 指向的位址的物件內容。</span><br><span class="line"></span><br><span class="line">但是如果不是重新賦值而是直接修改傳入的內容：</span><br></pre></td></tr></table></figure>

<p>var coin1 = { value: 10 };</p>
<p>function changeValue(obj) {<br>  obj.value = 123;<br>}</p>
<p>changeValue(coin1);<br>console.log(coin1.value);   // 123</p>
<pre><code>答案是 123。此時變數 coin1 所指向的資料內容被改變，代表你要讓 function 裡面的那個 obj 跟外面的 coin1「共享」同一個 object，所以透過裡面的 obj，你可以去修改「共享到的那個 object」的資料。

# 小結

在 JavaScript 中的物件類型(object)是可變的 (mutable)，**當物件更新時，會影響到所有引用這個物件的變數與其副本，修改時會變動到原本的參考，但當賦與新值時，會產生新的實體參考**。

而基本型別(primitive)則是不可變的 (immutable)，當你更新了某個基本型別的值時，與那個值的副本完全無關。

# 垃圾回收 Garbage collection

對於開發者來說，JavaScript 的內存管理是自動的、無形的。我們創建的原始值、對象、函數……這一切都會佔用內存。當某個東西我們不再需要時會發生什麼？ JavaScript 引擎如何發現它、清理它？
JavaScript 中主要的內存管理概念是**可達性 Reachability**，簡言之，可達值是那些以某種方式可訪問或可用的值，它們保證存儲在內存中。
這裡列出固有的可達值基本集合，這些值明顯不能被釋放：

1. 當前函數的局部變數和參數。Local variables and parameters of the current function.
2. 嵌套調用時，當前調用鏈上所有函數的變量與參數。Variables and parameters for other functions on the current chain of nested calls.
3. 全局變數。Global variables.
4. 還有一些其他的內部變數。(there are some other, internal ones as well)

這些值被稱作根 root。

如果一個值可以通過 引用 或 引用鏈，從根值訪問到，則認為這個值是 可達的。
比方說，如果局部變量中有一個對象，並且該對象具有引用另一個對象的 property，則該對像被認為是可達的。而且它引用的內容也是可達的。

在 JavaScript 引擎中有一個被稱作垃圾回收器(garbage collector)的東西在後台執行。它監控著所有對象的狀態，並刪除掉那些已經不可達的。

# Reference

[深入探討 JavaScript 中的參數傳遞：call by value 還是 reference？](https://blog.techbridge.cc/2018/06/23/javascript-call-by-value-or-reference/)
[重新認識 JavaScript: Day 05 JavaScript 是「傳值」或「傳址」？](https://ithelp.ithome.com.tw/articles/10191057)
[Garbage collection](https://zh.javascript.info/garbage-collection)
[[筆記] 談談 JavaScript 中 by reference 和 by value 的重要觀念](https://pjchender.blogspot.com/2016/03/javascriptby-referenceby-value.html)</code></pre>
        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="https://chinyun.github.io/myblog/myblog/2019/11/12/JS-hoisting-scope-closure/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="chinyun">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/myblog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jinny's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/myblog/2019/11/12/JS-hoisting-scope-closure/" class="post-title-link" itemprop="url">JS hoisting,scope,closure</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-11-12 19:59:07" itemprop="dateCreated datePublished" datetime="2019-11-12T19:59:07+00:00">2019-11-12</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-11-13 12:13:55" itemprop="dateModified" datetime="2019-11-13T12:13:55+00:00">2019-11-13</time>
              </span>
            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Hoisting、Scope 和 Closure 在 JavaScript 中是很重要的觀念，因爲會影響我們如何撰寫 JavaScript。了解這三個概念可以幫助我們了解 JaveScript 在內文執行的運作原理，尤其是在創建和執行階段，JaveScript 的執行機制會如何理解我們寫的程式碼，並跑出我們想要的結果。</p>
<h1 id="Hoisting"><a href="#Hoisting" class="headerlink" title="Hoisting"></a>Hoisting</h1><p>在執行任何程式碼前，JavaScript 會把變數和函數的宣告在編譯階段就放入記憶體，如此即便我們先寫調用某一函式的程式碼，再寫該函式的內容，JavaScript 也還是可以知道這段程式碼的意義：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">catName(&quot;Chloe&quot;);</span><br><span class="line"></span><br><span class="line">function catName(name) &#123;</span><br><span class="line">  console.log(&quot;My cat&apos;s name is &quot; + name);</span><br><span class="line">&#125;</span><br><span class="line">/*上面程式的結果是: &quot;My cat&apos;s name is Chloe&quot;*/</span><br></pre></td></tr></table></figure>

<p>即使我們函式的程式碼之前就先呼叫它，程式碼仍然可以運作。這是出於 JavaScript 內文執行的運作原理。<br>提升也適用於其他型別和變數。變數可以在宣告之前進行初始化和使用，但如果沒有初始化，就不能使用它們。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">num = 6;</span><br><span class="line">num + 7;</span><br><span class="line">var num; </span><br><span class="line">/* 只要 num 有被宣告，就不會有錯誤 */</span><br></pre></td></tr></table></figure>

<p>JavaScript 僅提升宣告的部分，而不是初始化。如果在使用該變數後才宣告和初始化，那麼該值將是 undefined。以下兩個範例顯示了這個特性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var x = 1; // 初始化 x</span><br><span class="line">console.log(x + &quot; &quot; + y);  // &apos;1 undefined&apos;</span><br><span class="line">var y = 2;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var x = 1; // 初始化 x</span><br><span class="line">var y; // 宣告 y</span><br><span class="line">console.log(x + &quot; &quot; + y);  // &apos;1 undefined&apos;</span><br><span class="line">y = 2; // 初始化 y</span><br></pre></td></tr></table></figure>

<p>函數宣告的優先權比變數宣告高，如果 function 調用時有傳參數進來，就會宣告該參數代表的變數意義並賦值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function test(v) &#123;</span><br><span class="line">  var v</span><br><span class="line">  console.log(v)</span><br><span class="line">  v = 3</span><br><span class="line">&#125;</span><br><span class="line">test(10) // 10</span><br></pre></td></tr></table></figure>

<p>需要注意的是，只有 declaration 宣告式的 function (ex:<code>function func(){...}</code>)會被在編譯階段提升，而 expression 表達式宣告的 function (ex:<code>let func = function(){...}</code>)會在執行階段才被存放到記憶體中。</p>
<h1 id="Scope-作用域"><a href="#Scope-作用域" class="headerlink" title="Scope 作用域"></a>Scope 作用域</h1><ul>
<li>Execution Context 執行環境<br>要了解 Scope 須先知道 <strong>Execution Context 執行環境</strong> 的概念。<br>Execution Context is a fancy word for describing the environment in which your Javascript code runs.</li>
</ul>
<p>當 JavaScript engine start up 程式碼準備好開始運行時，就會先建立 <strong>global execution context全域執行環境</strong>，然後建立一個 global object 和 this，在 browser 的環境中，global object 是 window， this === window，在 node.js 環境中， global object 是 global，this === global。<br>我們可以 assign variable、function 到 global object 中。</p>
<p>執行環境在建立時會經歷兩個階段，分別是 ：</p>
<ul>
<li>Creation Phase 創造階段：變數宣告和函數宣告提升，自動跳過函式裡的程式碼。</li>
<li>Execution Phase 執行階段：由上到下、一行一行地執行程式</li>
</ul>
<p>當 JavaScript engine 看到 function name() 函數被執行，就會創建一個 function name() execution context，新的 function execution context 會被加入到<strong>Execution stack 執行堆疊</strong>，並依序執行(Javascript 是單一執行緒，一次只能做一件事)，執行環境 的堆疊過程是具有 順序性 的：first in last out。</p>
<ul>
<li>Scope 作用域是什麼？</li>
</ul>
<p>Scope is where can I access the variable where’s that variable in my code. It just defines the accessibility, of variables and functions in the code.</p>
<p>Scope 可以說是一個變數的生存範圍，出了這個範圍就無法存取到。在 JavaScript 裡面，可以分為兩種 Scope 作用域：</p>
<ul>
<li>Global Scope：表示全域、任何地方都能存取得到</li>
<li>Lexical Scope：variable 被寫下來的那個地方，就是作用域<ul>
<li>function scope</li>
<li>block scope<br>it means that only by looking at the source code we can determine which environment the variables in data are avaliable in.<br>這與 Lexical Environment 有關，在物理上我們將 code 寫在哪裡，那就是該 variable 或 function 的 Lexical Environment。 In JS our lexical scope (avalible data + variables where the function was defined) determines our avalible variables. Not the function is called.(相反地，有一種叫做 Dynamic scope 的作用域機制 就是在程式執行時才動態決定的) </li>
</ul>
</li>
</ul>
<ul>
<li>Scope Chain<br>透過程式碼層層的包裹，由內而外，直到 global scope 的這一條 scope chain，可以幫助找到要找的對象(通常是 variables)被寫下的地方(lexical environment)。</li>
</ul>
<p>在 ES6 以前，唯一產生作用域的方法就是 function，每一個 function 都有自己的作用域，在作用域外面你就存取不到這個 function 內部所定義的變數，然而 ES6 的時候引入了 let 跟 const，多了 block-scope 的概念。<br>延伸：<a href="https://cythilya.github.io/2016/10/28/es6-let-const-block-level-scope/" target="_blank" rel="noopener">ES6: let, const, Block-Level Scope</a></p>
<p>因應ES6的出現，使用上建議大家不要再用var來宣告變數，改用let與const，而且優先使用const。<br>因為const在宣告時必須給定值，並且不能再被更改，這可以有效降低出現錯誤的機會。<br>同理，如果是需要變更的數值則改用作用範圍較小的let做宣告，來減少錯誤出現的機率，Ex: for迴圈。<br>– <a href="https://www.iware.com.tw/blog-JavaScript%20%E5%AE%A3%E5%91%8A:%20var%E3%80%81let%E3%80%81const.html" target="_blank" rel="noopener">JavaScript 宣告: var、let、const</a></p>
<h1 id="Closure-閉包"><a href="#Closure-閉包" class="headerlink" title="Closure 閉包"></a>Closure 閉包</h1><p>「閉包（英語：Closure），又稱詞法閉包（Lexical Closure）或函式閉包（function closures），是參照了自由變數的函式。這個被參照的自由變數將和這個函式一同存在，即使已經離開了創造它的環境也不例外。閉包是由函式和與其相關的參照環境組合而成的實體。」–wiki<br>每個宣告的 function 都會儲存著[[Scope]]，而這個資訊裡面就是參照的環境。<br>「that all functions, independently from their type: anonymous, named, function expression or function declaration, because of the scope chain mechanism, are closures.</p>
<p>from the theoretical viewpoint: all functions, since all they save at creation variables of a parent context. Even a simple global function, referencing a global variable refers a free variable and therefore, the general scope chain mechanism is used;<br>from the practical viewpoint: those functions are interesting which:</p>
<ul>
<li>continue to exist after their parent context is finished, e.g. inner functions returned from a parent function;</li>
<li>use free variables.」–<a href="http://dmitrysoshnikov.com/ecmascript/chapter-6-closures/" target="_blank" rel="noopener">ECMA-262-3 in detail. Chapter 6. Closures.</a></li>
</ul>
<p>scopeChain 把每一層的 AO 和 VO 記錄下來，而變數就紀錄在AO 或 VO 裡，也因為 return 才把 AO 和 VO 保留下來。<br>closure 其實就是因為 scopeChain 有 reference 到其他 Execution Context 的 AO(active object) 或是 VO(variable object)，所以在離開之後還是可以存取到上層的變數，如果你是以會記住上層資訊的角度來看 closure，那所有的 function 都是 closure</p>
<ul>
<li><p>閉包是函式記得並存取 Lexical Scope 語彙範疇的能力，可說是指向特定 scope 的參考，因此當函式是在其宣告的 Lexical Scope 語彙範疇之外執行時也能正常運作。</p>
</li>
<li><p>迴圈與閉包搭配使用時的謬誤與陷阱。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for (var i = 1; i &lt;= 5; i++) &#123;</span><br><span class="line">  setTimeout(function timer() &#123;</span><br><span class="line">    console.log(i);</span><br><span class="line">  &#125;, i * 1000 );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由於 console.log(i) 中的 i 會存取的範疇是 for 所在的範疇（目前看起來是全域範疇，因為 var 宣告的變數不具區塊範疇的特性），因此當 1 秒、2 秒…5 秒後執行 console.log(i) 時，就會去取 i 的值，而此時 for 迴圈已跑完，i 變成 6，因此就會每隔一秒印出一個「6」。<br>解決方法可以利用 IIFE（Immediately Invoked Function Expression）把一個 function 包起來並傳入 i 立即執行，所以迴圈每跑一圈其實就會立刻呼叫一個新的 function，因此就產生了新的作用域。如果你都覺得太麻煩不想用，恭喜，在 ES6 裡面有了 block scope 以後，你只要簡單地把迴圈裡面用的 var 改成 let 就行了：因為 let 的特性，所以其實迴圈每跑一圈都會產生一個新的作用域，因此 alert 出來的值就會是你想要的那個值。</p>
</li>
<li><p>模組模式可經由建立一個模組實體來調用內層函式，而內層函式由於具有閉包的特性，因此可存取外層的變數和函式。透過模組模式，可隱藏私密資訊，並選擇對外公開的 API。</p>
</li>
<li><p>利用模組依存性載入器或管理器或 ES6 模組來管理模組。</p>
</li>
</ul>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="https://developer.mozilla.org/zh-TW/docs/Glossary/Hoisting" target="_blank" rel="noopener">提升（Hoisting）</a><br><a href="https://github.com/aszx87410/blog/issues/34#" target="_blank" rel="noopener">我知道你懂 hoisting，可是你了解到多深？</a><br><a href="https://medium.com/%E9%AD%94%E9%AC%BC%E8%97%8F%E5%9C%A8%E7%A8%8B%E5%BC%8F%E7%B4%B0%E7%AF%80%E8%A3%A1/%E6%B7%BA%E8%AB%87-javascript-%E5%9F%B7%E8%A1%8C%E7%92%B0%E5%A2%83-2976b3eaf248" target="_blank" rel="noopener">秒懂！JavaSript 執行環境與堆疊</a><br><a href="https://github.com/aszx87410/blog/issues/35" target="_blank" rel="noopener">所有的函式都是閉包：談 JS 中的作用域與 Closure</a><br><a href="https://cythilya.github.io/2018/10/22/closure/" target="_blank" rel="noopener">你懂 JavaScript 嗎？#15 閉包（Closure）</a><br><a href="https://github.com/healthyspi/weekly-notes/issues/8" target="_blank" rel="noopener">[2019-10-12] 進階 JavaScript - Closure </a><br><a href="https://openhome.cc/Gossip/JavaScript/Closure.html" target="_blank" rel="noopener">閉包（Closure）</a></p>
<blockquote>
<p>閉包也會用來作為物件私用（private）的模擬，以及名稱空間的管理等</p>
</blockquote>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="https://chinyun.github.io/myblog/myblog/2019/11/11/JS-this/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="chinyun">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/myblog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jinny's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/myblog/2019/11/11/JS-this/" class="post-title-link" itemprop="url">JS this</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-11-11 23:25:13" itemprop="dateCreated datePublished" datetime="2019-11-11T23:25:13+00:00">2019-11-11</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-11-13 12:13:55" itemprop="dateModified" datetime="2019-11-13T12:13:55+00:00">2019-11-13</time>
              </span>
            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="this"><a href="#this" class="headerlink" title="this"></a>this</h1><p>在物件導向程式語言裡面，this 概念指的是 instance 本身。<br>舉例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Car &#123;</span><br><span class="line">  setName(name) &#123;</span><br><span class="line">    this.name = name</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  getName() &#123;</span><br><span class="line">    return this.name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">const myCar = new Car()</span><br><span class="line">myCar.setName(&apos;hello&apos;)</span><br><span class="line">console.log(myCar.getName()) // hello</span><br></pre></td></tr></table></figure>

<p>然而和一般物件導向的程式語言 Java 或 C++ 等不同，在 JavaScript 裡面，你在任何地方都可以存取到 this，所以在 JavaScript 裡的 this 跟其他程式語言慣用的那個 this 有了差異，這就是為什麼 this 難懂的原因。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function hello()&#123;</span><br><span class="line">  console.log(this)</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">hello()</span><br></pre></td></tr></table></figure>

<p>一旦脫離了物件導向，也就是在 class 外面的 this，其實沒有太大的意義。<br>在這種很沒意義的情況下，this 的值在瀏覽器底下就會是 <code>window</code>，在 node.js 底下會是 <code>global</code>，如果是在嚴格模式，this 的值就會是 <code>undefined</code>。這個規則就是所謂的「預設綁定」。</p>
<h2 id="this-值的改變"><a href="#this-值的改變" class="headerlink" title="this 值的改變"></a>this 值的改變</h2><ul>
<li>可以用 call、apply 與 bind 改變 this 的值：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&apos;use strict&apos;;</span><br><span class="line">function hello(a, b) &#123;</span><br><span class="line">  console.log(this, a, b)</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">hello.call(&apos;yo&apos;, 1, 2) // yo 1 2</span><br><span class="line">hello.apply(&apos;hihihi&apos;, [1, 2]) // hihihi 1 2</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>call 跟 apply 的差別就是 apply 在傳參數時要用 array 包起來。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Car &#123;</span><br><span class="line">  hello() &#123;</span><br><span class="line">    console.log(this)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">const myCar = new Car()</span><br><span class="line">myCar.hello() // myCar instance</span><br><span class="line">myCar.hello.call(&apos;yaaaa&apos;) // yaaaa</span><br></pre></td></tr></table></figure>

<p>可以把原本的 this 值覆蓋掉。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&apos;use strict&apos;;</span><br><span class="line">function hello() &#123;</span><br><span class="line">  console.log(this)</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">const myHello = hello.bind(&apos;my&apos;)</span><br><span class="line">myHello() // my</span><br><span class="line">myHello.call(&apos;call&apos;) // my</span><br></pre></td></tr></table></figure>

<p>使用 bind 之後，call 方法也沒有辦法覆蓋掉。<br>如果是在<strong>非嚴格模式</strong>底下，無論是用 call、apply 還是 bind，你傳進去的如果是 primitive 都會被轉成 object：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function hello() &#123;</span><br><span class="line">  console.log(this)</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">hello.call(123) // [Number: 123]</span><br><span class="line">const myHello = hello.bind(&apos;my&apos;)</span><br><span class="line">myHello() // [String: &apos;my&apos;]</span><br></pre></td></tr></table></figure>

<ul>
<li>this 是在運行時求值的，可以適用於任何 function，從不同 object 調用同一個 function 可以會有不同 this 的值。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const obj = &#123;</span><br><span class="line">  value: 1,</span><br><span class="line">  hello: function() &#123;</span><br><span class="line">    console.log(this.value)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">obj.hello() // 1</span><br></pre></td></tr></table></figure>

<p>this 的值跟作用域跟程式碼的位置在哪裡完全無關，只跟「你如何呼叫」有關。</p>
<p>作用域的概念舉例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">var a = 10</span><br><span class="line">function test()&#123;</span><br><span class="line">  console.log(a)</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">const obj = &#123;</span><br><span class="line">  a: &apos;ojb&apos;,</span><br><span class="line">  hello: function() &#123;</span><br><span class="line">    test() // 10</span><br><span class="line">  &#125;,</span><br><span class="line">  hello2: function() &#123;</span><br><span class="line">    var a = 200</span><br><span class="line">    test() // 10</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">test() // 10</span><br><span class="line">obj.hello()  </span><br><span class="line">obj.hello2()</span><br></pre></td></tr></table></figure>

<p>無論我在哪裡，無論我怎麼呼叫test這個 function，他印出來的 a 永遠都會是全域變數的那個 a(// 10)，因為作用域就是這樣運作，test 在自己的作用域裡面找不到 a 於是往上一層找，而上一層就是 global scope，這跟你在哪裡呼叫 test 一點關係都沒有。test 這個 function 在宣告的時候就把 scope 給決定好了。</p>
<p>但 this 卻是完全相反，this 的值會根據你怎麼呼叫它而變得不一樣，例如使用 call、apply 跟 bind 可以用不同的方式去呼叫改變 this 的值。如果 function 是在物件下調用，那麼 this 則會指向此物件，無論 function 是在哪裡宣告。使用物件的方法調用時 this 會指向調用的物件。<strong>宣告的位置不重要，重要的是呼叫的方法。</strong></p>
<h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><p><a href="https://wcc723.github.io/javascript/2017/12/12/javascript-this/" target="_blank" rel="noopener">JavaScript 的 this 到底是誰？</a><br><a href="https://blog.techbridge.cc/2019/02/23/javascript-this/" target="_blank" rel="noopener">淺談 JavaScript 頭號難題 this：絕對不完整，但保證好懂</a></p>
<h2 id="補充-在-react-中的-bind-this-用法"><a href="#補充-在-react-中的-bind-this-用法" class="headerlink" title="補充:在 react 中的 bind(this)用法"></a>補充:在 react 中的 bind(this)用法</h2><p><a href="https://stackoverflow.com/questions/42434232/what-is-the-usage-of-this-method-bindthis" target="_blank" rel="noopener">what is the usage of : this.method.bind(this)</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">import React from &apos;react&apos;;</span><br><span class="line"></span><br><span class="line">class App extends React.Component &#123;</span><br><span class="line">   constructor() &#123;</span><br><span class="line">      super();</span><br><span class="line">      this.state = &#123;</span><br><span class="line">         data: []</span><br><span class="line">      &#125;</span><br><span class="line">      this.setStateHandler = this.setStateHandler.bind(this);</span><br><span class="line">   &#125;;</span><br><span class="line"></span><br><span class="line">   setStateHandler() &#123;</span><br><span class="line">      var item = &quot;setState...&quot;</span><br><span class="line">      var myArray = this.state.data;</span><br><span class="line">      myArray.push(item)</span><br><span class="line">      this.setState(&#123;data: myArray&#125;)</span><br><span class="line">   &#125;;</span><br><span class="line"></span><br><span class="line">   render() &#123;</span><br><span class="line">      return (</span><br><span class="line">         &lt;div&gt;</span><br><span class="line">            &lt;button onClick = &#123;this.setStateHandler&#125;&gt;SET STATE&lt;/button&gt;</span><br><span class="line">            &lt;h4&gt;State Array: &#123;this.state.data&#125;&lt;/h4&gt;</span><br><span class="line">         &lt;/div&gt;</span><br><span class="line">      );</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default App;</span><br></pre></td></tr></table></figure>

<p><code>this.setStateHandler().bind(this)</code> sets the context for the function <code>setStateHandler()</code> to be the class object. This is necessary so that you could call <code>this.setState({...})</code> inside the method, because <code>setState()</code> is the method of React.Component. If you do not <code>.bind(this)</code> you would get an error that <code>setState()</code> method is undefined.</p>
<p><a href="https://medium.com/reactmaker/react-%E8%88%87-bind-this-%E7%9A%84%E4%B8%80%E4%BA%9B%E5%BF%83%E5%BE%97-323c8d3d395d" target="_blank" rel="noopener">React 與 bind this 的一些心得</a><br>當使用 extend React.Component 的方式去宣告元件的時候，React 確實會綁定 this 到元件內，但是卻有以下特定的地方才會被綁進去生命周期函式，例如 componentDidMount 等等<br>render 內其他自己定義的 property 就不會被綁入 this ，而且 this 會被指到 windows 這個全域上。</p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="https://chinyun.github.io/myblog/myblog/2019/11/11/JS-prototype/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="chinyun">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/myblog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jinny's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/myblog/2019/11/11/JS-prototype/" class="post-title-link" itemprop="url">JS prototype</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-11-11 21:09:26" itemprop="dateCreated datePublished" datetime="2019-11-11T21:09:26+00:00">2019-11-11</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-11-13 12:13:55" itemprop="dateModified" datetime="2019-11-13T12:13:55+00:00">2019-11-13</time>
              </span>
            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>筆記 JavaScript 中非常重要的概念：繼承 inheritance、原型 prototype 和原型鍊 prototype chain。</p>
<h1 id="Object-oriented-programming-OOP"><a href="#Object-oriented-programming-OOP" class="headerlink" title="Object-oriented programming(OOP)"></a>Object-oriented programming(OOP)</h1><p>JavaScript 並不像 Java、C++ 這些典型的物件導向語言具有「類別」（class）來區分概念與實體（instance）或天生具有繼承的能力，而 JavaScript 只有「物件」，因此只能利用設計模式來模擬這些功能。在 JavaScript 世界中，到底是怎麼實現物件導向的概念的？<br>JavaScript 的物件透過原型 (Prototype) 機制相互繼承功能，與典型的物件導向 (OO) 程式語言相較，其運作方式有所差異。<br>在討論 物件導向 JavaScript 之前，需要先知道物件導向程式設計 (Object-oriented programming；OOP)的意義。<br>OOP 基本概念是：<strong>採用物件（objects）來模塑真實的實物世界</strong>：也就是在程式中的呈現是透過 objects 來塑造其模型，並提供簡單方式存取其「難以或不可能採用的功能」。物件可裝載相關的資料與程式碼，資料部分是你塑造某個模型的資訊，而程式碼部分則用是操作行為(Method)實現。</p>
<p>為了簡化程式撰寫，我們可以為某個複雜東西建立簡單的模型，藉以代表其最重要的概念或特質，且該模型建立方式極易於搭配我們的程式設計用途：譬如用「類別」建立物件實體 Object instance — 該物件包含了類別中所定義的資料與功能。</p>
<p>在根據類別建立物件實體時，就是執行類別的「建構子 Constructor 函式」所建立，而這個「根據類別來建立物件實體」的過程即稱為「實體化 Instantiation」，物件實體就是從類別實體化而來。</p>
<p>我們可根據某一個類別建立許多新的子類別，新的子類別可繼承 (Inherit) 其母類別的資料與程式碼特性。你可重複使用所有物件類型共有的功能，而不需再複製之。若功能需與類別有所差異，則可直接於其上定義特殊功能。</p>
<h1 id="inheritance"><a href="#inheritance" class="headerlink" title="inheritance"></a>inheritance</h1><p>一個物件可以存取其他物件的屬性 properties、方法 methods，就叫做繼承 inheritance。<br>繼承可以分成兩種，一種是 classical inheritance 類別繼承，這種方式用在 C# 或 JAVA 當中；另一種則是 JavaScript 所使用的，是屬於 prototypal inheritance 原型繼承。<br>在「典型 OO」中，你必須定義特定的類別物件，才能定義哪些類別所要繼承的類別，而 JavaScript 使用不同的系統：「繼承」的物件並不會一併複製功能過來，而是透過原型鍊連接其所繼承的功能，亦即所謂的原型繼承 (Prototypal inheritance)。<br>基於 JavaScript 運作的方式 (如原型鍊等)，物件之間的功能共享一般稱為「委託 (Delegation)」，即特定物件將功能委託至通用物件類型。「委託」其實比繼承更精確一點。因為「所繼承的功能」並不會複製到「進行繼承的物件」之上，卻是保留在通用物件之中。</p>
<h1 id="prototype"><a href="#prototype" class="headerlink" title="prototype"></a>prototype</h1><p>Object 之間可以互相成為各自的 Prototype，被繼承的 Object 將會繼承父 Object 的 Prototype 所有屬性。[[Prototype]]，是一個設定（寫入） Object 的 Prototype 的接口，是一個內部屬性(internal property)，它并不允許外部存取。</p>
<p>每個實例對象（object）都有一個私有屬性（稱之為 <code>__proto__</code>）指向它的構造函數的原型對象（prototype）。該原型對像也有一個自己的原型對象(<code>__proto__</code>) ，層層向上直到一個對象的原型對象為 <code>null</code>。根據定義，<code>null</code> 沒有原型，並作為這個原型鏈中的最後一個環節。</p>
<p>幾乎所有 JavaScript 中的對象都是位於原型鏈頂端的 Object 的實例。</p>
<p>prototype 這個屬性，是 JavaScript 中最讓人混淆的名稱之一。你可能會認為<code>this</code>屬性即指目前物件(current object)的原型物件(prototype object)，但它其實不是原型 (應該是可透過 <code>__proto__</code>存取的內部物件(internal object)才對)。prototype是一個物件(object)，內含了你定義所應該繼承的成員。</p>
<p>遵循ECMAScript標準，<code>someObject.[[Prototype]]</code> 符號是用於指向 someObject 的原型。從 ECMAScript 6 開始，[[Prototype]] 可以通過 <code>Object.getPrototypeOf()</code> 和 <code>Object.setPrototypeOf()</code> 訪問器來訪問。這個等同於 JavaScript 的非標準但許多瀏覽器實現的屬性<code>__proto__</code>。</p>
<p><code>__proto__</code> 發音 dunder prototype，最先被 Firefox使用，後來在 ES6 被列為Javascript 的標準內建屬性的。它的出現是為了解決讀寫 <code>Object.prototype</code>的麻煩，提供一個快捷讀寫的 API，而且它是透過連結內部屬性 <code>[[Prototype]]</code> 完成這個功能 (by javascripttutorial)。</p>
<p>但它不應該與構造函數 func 的 prototype 屬性相混淆。被構造函數創建的實例對象的 [[prototype]] 指向 func 的 prototype 屬性。 Object.prototype 屬性表示 Object 的原型對象。</p>
<p>舉例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function Person(name, age) &#123;</span><br><span class="line">  this.name = name;</span><br><span class="line">  this.age = age;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">Person.prototype.log = function () &#123;</span><br><span class="line">  console.log(this.name + &apos;, age:&apos; + this.age);</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">var nick = new Person(&apos;nick&apos;, 18);</span><br><span class="line">console.log(nick.__proto__ === Person.prototype) // true</span><br><span class="line"></span><br><span class="line">var peter = new Person(&apos;peter&apos;, 20);</span><br><span class="line">console.log(nick.log === peter.log) // true</span><br></pre></td></tr></table></figure>

<p>當我在呼叫nick.log()的時候，JavaScript 是怎麼找到這個 function 的？<br>因為 nick 這個 instance 本身並沒有 log 這個 function。但根據 JavaScript 的機制，nick 是 Person 的 instance，所以如果在 nick 本身找不到，它會試著從Person.prototype去找。<br>可是，JavaScript 怎麼知道要到這邊去找？所以一定是 nick 跟 Person.prototype 會透過某種方式連接起來，才知道說要往哪邊去找 log 這個 function。<br>而這個連接的方式，就是<code>__proto__</code>。<br>（附註：其實比較好的方式是用<code>Object.getPrototypeOf()</code>，但這邊為了方便起見，還是使用比較常見的<code>__proto__</code>，更詳細的說明可參考：<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/proto" target="_blank" rel="noopener">MDN: Object.prototype.proto</a>）<br><code>nick.__proto__</code> 會指向 <code>Person.prototype</code>，<code>Person.prototype</code> 和 <code>nick.__proto__</code>是兩個不同的概念：當一個 Person 的物件被創建，被創建物建 nick 的 api 街口 <code>nick.__proto__</code> 會被指向到 <code>Person.prototype</code> 指向的物建。</p>
<p>假如Person.prototype還是沒找到 log，那就繼續依照這個規則，去看<code>Person.prototype.__proto__</code>裡面有沒有 log 這個 method，就這樣一直不斷找下去，直到找到某個東西的<code>__proto__</code>是 null 為止，就表示這邊是最上層了，而這一個透過<code>__proto__</code>不斷串起來的鍊，就叫做原型鍊。透過原型鍊可以達成類似繼承的功能，呼叫自己 parent class 的 method。</p>
<h1 id="prototype-chain"><a href="#prototype-chain" class="headerlink" title="prototype chain"></a>prototype chain</h1><p>新的物件實例透過建構子函式 constructor() 產生後，其核心將透過一種稱為原型鏈 Prototype chain 的機制傳遞，由 prototype 定義的參照鏈連在一起。</p>
<p>常有人說 JavaScript 是原型架構的程式語言 — 各個物件均具備 1 組原型物件作為範本物件，用以繼承函式與屬性。物件的原型物件可能也具備原型物件，並繼承了其上的函式與屬性。這就是我們所謂的「原型鍊 (Prototype chain)」，同時正好說明為何 A 物件的屬性與函式是透過 B 物件的屬性與函式所定義。</p>
<p>精確點說，<strong>這些屬性與函式都是透過物件的建構子函式所定義，並非物件實例本身</strong>。</p>
<p>傳統的 OOP 都是先定義了類別，接著在建立物件實例之後，在類型上定義的所有屬性與函式均複製到此實例。但 JavaScript 不會複製這些屬性與函式，卻是在物件實例與其建構子之間設定連結 (原型鍊中的連結)，只要順著原型鍊就能在建構子之中找到屬性與函式。</p>
<p>繼承的成員是在一個物件的 prototype 屬性 (你也能稱之為子命名空間 sub namespace) 中定義的成員，也就是以「<code>Object.prototype.</code>」開頭的成員；並非只以「<code>Object.</code>」開頭的成員。prototype 屬性值就是 1 個物件，基本上儲存了許多我們想「讓原型鍊上的物件一路繼承下去」的屬性與函式。<br>在 JavaScript 主控台中輸入 <code>Object.prototype.</code> 會看到 Object 的 prototype 屬性中所定義的許多函式，而繼承自 Object 的物件也能找到這些函式。只要試著尋找如 String、Date、Number、Array 等全域物件的原型上定義的函式與屬性，就會看到 JavaScript 中的其他原型鍊繼承範例。</p>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="https://pjchender.blogspot.com/2016/06/javascriptprototypeprototype.html" target="_blank" rel="noopener">了解 JavaScript 中，繼承 inheritance、原型 prototype 和原型鍊 prototype chain 的概念</a><br><a href="https://cythilya.github.io/2018/10/26/prototype/" target="_blank" rel="noopener">你懂 JavaScript 嗎？#19 原型（Prototype）</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Inheritance_and_the_prototype_chain" target="_blank" rel="noopener">MDN Web Docs:继承与原型链</a><br><a href="https://blog.techbridge.cc/2017/04/22/javascript-prototype/" target="_blank" rel="noopener">該來理解 JavaScript 的原型鍊了</a><br>[Javascripter 必須知道的繼承 prototype, [[prototype]], <code>__proto__</code>](<a href="https://medium.com/@peterchang_82818/javascripter-%E5%BF%85%E9%A0%88%E7%9F%A5%E9%81%93%E7%9A%84%E7%B9%BC%E6%89%BF%E5%9B%A0%E5%AD%90-prototype-prototype-proto-object-class-inheritace-nodejs-%E7%89%A9%E4%BB%B6-%E7%B9%BC%E6%89%BF-54102240a8b4" target="_blank" rel="noopener">https://medium.com/@peterchang_82818/javascripter-%E5%BF%85%E9%A0%88%E7%9F%A5%E9%81%93%E7%9A%84%E7%B9%BC%E6%89%BF%E5%9B%A0%E5%AD%90-prototype-prototype-proto-object-class-inheritace-nodejs-%E7%89%A9%E4%BB%B6-%E7%B9%BC%E6%89%BF-54102240a8b4</a>)</p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="https://chinyun.github.io/myblog/myblog/2019/11/11/JS-Class/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="chinyun">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/myblog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jinny's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/myblog/2019/11/11/JS-Class/" class="post-title-link" itemprop="url">JS Class</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-11-11 18:30:54" itemprop="dateCreated datePublished" datetime="2019-11-11T18:30:54+00:00">2019-11-11</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-11-13 12:13:55" itemprop="dateModified" datetime="2019-11-13T12:13:55+00:00">2019-11-13</time>
              </span>
            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="JavaScript-Class"><a href="#JavaScript-Class" class="headerlink" title="JavaScript Class"></a>JavaScript Class</h1><p>In Object-oriented programming, a class is an extensible program-code-template for creating objects, providing initial values for state(member variables) and implementations of behavior(member functions or methods).class 是一種可以拓展的編程模板，用來創建對象(object)，提供狀態初始值(變量)和行為實現(函數或方法)。</p>
<p>JavaScript 雖然具有物件導向程式語言的特性，但與 Java、C++ 等以類別為基礎的程式設計規範不同，JavaScript 是一種以原型(prototype-based)為基礎的語言。</p>
<p>由於開發上經常需要創建許多相似類型的對象(object)，例如針對 users、goods等。在 JavaScript 中，可以用構造函數(Constructor)和 operator “new” 來達成這個使用目的，但在 ES6 中有一個更進階的用法叫做 “Class”。</p>
<p>ECMAScript 6 中引入了類別 (class) 作為 JavaScript 現有原型程式(prototype-based)繼承的語法糖。語法糖可以讓現有語法操作變得更容易。類別 (class)語法並不是要引入新的物件導向繼承模型到 JavaScript 中，而是提供一個更簡潔的語法來建立物件和處理繼承。</p>
<p>Class 允許使用更簡潔的結構語法來定義 prototype-based 的類別。在 prototype-based 類別中，所有 methods 都存在 prototype 屬性中，藉以與其他延伸出去的類別共用，如此可以節省 memory 空間。<br>比較傳統原型繼承的寫法和使用 class 的寫法會發現，class 省略了 prototype chaining 並且整個 class 的宣告定義集中描述在 class 區塊內，幫助讀者了解這段程式的作用範圍，使 class 的目的更為清楚。</p>
<ul>
<li><p>Constructor 構造函數</p>
<ul>
<li>是一種常規函數，函數名稱首字必須大寫</li>
<li>創建時必須使用 new 來操作</li>
<li>需在 prototype 物件上定義方法</li>
<li>示範：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function User(name) &#123;</span><br><span class="line">  this.name = name;</span><br><span class="line">  this.isAdmin = false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">User.prototype.sayHi = function() &#123;</span><br><span class="line">  console.log(this.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let user = new User(&quot;Jack&quot;); // 創建一個 User Constructor</span><br><span class="line"></span><br><span class="line">alert(user.name); -&gt; Jack</span><br><span class="line">alert(user.isAdmin); -&gt; false</span><br><span class="line">user.sayHi() -&gt; Jack</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>當一個函數作為 new User(…)執行時，它執行以下步驟：</p>
<ol>
<li>一個新的空對像被創建並分配給 this。</li>
<li>函數體執行。通常它會修改 this，為其添加新的屬性。</li>
<li>返回 this 的值。<br>所以 new User(“Jack”) 的结果是相同的對象。</li>
</ol>
</li>
</ul>
<ul>
<li><p>Class</p>
<ul>
<li>使用 constructor() 建構子來定義初始狀態，而且創建時也必須使用 new 來操作。<br>建構子(constructor)方法是一個特別的方法，用來建立和初始化一個類別的物件，一個類別只能有一個建構子(constructor)。<br>Class 的 constructor()函數是默認的 method，即使沒有寫出來也會自動生成一個默認的空構造函數，並加入到 class.prototype上。<br>class syntax：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class User &#123;</span><br><span class="line">  constructor(name) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  sayHi() &#123;</span><br><span class="line">    alert(this.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">let user = new User(&quot;John&quot;);</span><br><span class="line">user.sayHi();</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>此時 User.prototype 包括 constructor 和 sayHi 兩個 methods。</p>
<ul>
<li><p>class expression 像一般 function 一樣，也可以寫作沒有名稱的表達式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">let User = class &#123;</span><br><span class="line">  sayHi() &#123;</span><br><span class="line">    alert(&quot;Hello&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function makeClass(phrase) &#123;</span><br><span class="line">  // 返回並宣告一個 class</span><br><span class="line">  return class &#123;  </span><br><span class="line">    sayHi() &#123;</span><br><span class="line">      alert(phrase);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">let User = makeClass(&quot;Hello&quot;);</span><br><span class="line"></span><br><span class="line">new User().sayHi(); // Hello</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 extend() 以及 super()來繼承父類的參數給子類。<br>關鍵字 extends 是在類別宣告或是類別敘述中建立子類別的方法。若在子類別中有建構子(constructor)，要使用this前則必須先呼叫super()函式：在子類別建構子中用關鍵字 super 來呼叫父類別的建構子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const createPersonClass = name =&gt; class extends User &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    super(name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>內部 method 之間不用逗號區分，與一般物件不同，可以避免我們描述二者時產生混淆</p>
</li>
<li><p>class 結構中的 code 都自動開啟了嚴格模式(use strict)</p>
</li>
<li><p>class 的宣告不會被 hoisting 提升到最高作用區，與函式宣告式不同，編譯器尚未抵達和執行 class 宣告之前無法建立或存取class</p>
</li>
<li><p>Just like literal objects, classes may include getters/setters, computed properties etc.</p>
</li>
</ul>
</li>
</ul>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="https://javascript.info/class" target="_blank" rel="noopener">javascript.info</a><br><a href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Classes" target="_blank" rel="noopener">mozilla.org - MDN Web Docs</a></p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="https://chinyun.github.io/myblog/myblog/2019/11/11/JS-Data-Type/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="chinyun">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/myblog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jinny's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/myblog/2019/11/11/JS-Data-Type/" class="post-title-link" itemprop="url">JS Data Type</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-11-11 17:50:01" itemprop="dateCreated datePublished" datetime="2019-11-11T17:50:01+00:00">2019-11-11</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-11-13 12:13:55" itemprop="dateModified" datetime="2019-11-13T12:13:55+00:00">2019-11-13</time>
              </span>
            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="JavaScript-Data-Type"><a href="#JavaScript-Data-Type" class="headerlink" title="JavaScript Data Type"></a>JavaScript Data Type</h1><p>JavaScript 的資料類型總共有七種，其中 6 種被稱為 <strong>原始型別 primitive data types</strong>: string, number, boolean, null, undefined, symbol (new in ECMAScript 2015)，以及最後一種 Object 對象資料型別。</p>
<ul>
<li><strong>number</strong>：number for numbers of any kind: integer or floating-point.</li>
<li><strong>string</strong>：string for strings. A string may have one or more characters, there’s no separate single-character type.</li>
<li><strong>boolean</strong>：boolean for true/false.</li>
<li><strong>null</strong>：null for unknown values – a stand alone type that has a single value null.</li>
<li><strong>indefined</strong>：undefined for unassigned values – a standalone type that has a single value undefined.</li>
<li><strong>object</strong>：object for more complex data structures. 包括 function<code>function(){}</code>, array<code>[]</code>, object<code>{key:value}</code>等不同對象物件資料類型。</li>
<li><strong>symbol</strong>：symbol for unique identifiers.</li>
</ul>
<p>JavaScript 是弱型別，也能說是動態的程式語言，這代表不必特別宣告變數的型別，程式在運作時，型別會自動轉換，這也代表可以用不同的型別使用同一個變數。<br>A variable in JavaScript can contain any data. A variable can at one moment be a string and at another be a number:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let message = &quot;hello&quot;;</span><br><span class="line">message = 123456;</span><br><span class="line">&lt;!-- no error --&gt;</span><br></pre></td></tr></table></figure>

<p>Programming languages that allow such things are called “dynamically typed”, meaning that there are data types, but variables are not bound to any of them.</p>
<h1 id="JavaScript-Equals"><a href="#JavaScript-Equals" class="headerlink" title="JavaScript Equals"></a>JavaScript Equals</h1><p>在 JavaScript 語法中，比較值是否相等有分為一般相等比較和嚴格相等比較兩種：</p>
<ul>
<li>Double Equals == 一般相等比較，若等號兩邊的資料類型不同，會轉換為相同類型再比較</li>
<li>Triple Equals === 嚴格相等比較，若類型不同即為不相等</li>
</ul>
<p>字串的比較：依字典順序，按字母逐個進行比較</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">alert(&apos;Z&apos;&gt;&apos;A&apos;) -&gt; true</span><br><span class="line">alert(&apos;Bee&apos;&gt;&apos;Be&apos;) -&gt; true</span><br><span class="line">alert(&apos;Glow&apos;&gt;&apos;Glee&apos;) -&gt; true</span><br><span class="line">alert(&apos;a&apos;&lt;&apos;A&apos;) -&gt; false；在 unicode 中 小寫 a 大於 大寫 A</span><br></pre></td></tr></table></figure>

<p>若為不同類型比較會先轉換為數字(number)在判定大小：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">alert(&apos;2&apos;&gt;1) -&gt; ture</span><br><span class="line">alert(&apos;01&apos;== 1) -&gt; true</span><br><span class="line">alert(&apos;2&apos;&gt;&apos;12&apos;) -&gt; true</span><br><span class="line">alert(0 == &apos;&apos;) -&gt; true</span><br><span class="line">alert(true == 1) -&gt; true</span><br><span class="line">alert(false == 0) -&gt; true</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let a = 0;</span><br><span class="line">alert(Boolean(a)) -&gt; false</span><br><span class="line">let b = &apos;0&apos;;</span><br><span class="line">alert(Boolean(b)) -&gt; true</span><br><span class="line">alert(a == b) -&gt; true</span><br></pre></td></tr></table></figure>

<h1 id="Type-Conversions-類型轉換"><a href="#Type-Conversions-類型轉換" class="headerlink" title="Type Conversions 類型轉換"></a>Type Conversions 類型轉換</h1><ul>
<li><p>String()</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let value = true;</span><br><span class="line">alert(typeof value);  -&gt; boolean</span><br><span class="line">value = String(value); -&gt; &quot;true&quot;</span><br><span class="line">alert(typeof value); -&gt; string</span><br></pre></td></tr></table></figure>
</li>
<li><p>Number()</p>
<ul>
<li>undefined -&gt; NaN</li>
<li>null -&gt; 0</li>
<li>true 和 false -&gt; 1 and 0</li>
<li>string  <ul>
<li>“按原樣讀取”字符串，兩端的空白會被忽略。空字符串變成 0。轉換出錯則輸出 NaN。</li>
<li>幾乎所有的算術運算符都將值轉換為數字進行運算，加號 + 是個例外：如果其中一個運算元是字符串，則另一個也會被轉換為字符串。<br><code>alert( 1 + &#39;2&#39; ); -&gt; &#39;12&#39;</code></li>
</ul>
</li>
</ul>
</li>
<li><p>Boolean()</p>
<ul>
<li>0, null, undefined, NaN, “”  -&gt; false</li>
<li>1, 其他值  -&gt; true</li>
</ul>
</li>
<li><p>總結注意點：</p>
<ul>
<li>當用 Number() 轉換型別成 number 時，須注意 “” 空字符會轉為 0，undefined 會變成 NaN。</li>
<li>用 Boolean() 轉換型別成 boolean 時， 0 為 false；1 為 true，而 null, undefined, NaN 及 “” 都會是 false。</li>
</ul>
</li>
<li><p>補充：</p>
<ul>
<li>強制轉型 Coercion：<br>強制轉型（coercion）分為兩種，分別是「明確的」強制轉型（explicit coercion）和「隱含的」強制轉型（implicit coercion），「明確的」強制轉型是程式碼中刻意寫出來的型別轉換的動作，例如<code>String(), Number()</code>。反之，在程式碼中沒有明確指出要轉換型別卻轉型的，就是隱含的強制轉型，例如 ＋運算子串接 數字和文字時</li>
<li>舉例： <code>[]+{}</code>和<code>{}+[]</code>的結果？<ul>
<li><code>[] + {}</code> 中，[] 會轉為空字串<code>&quot;&quot;</code>，而 {} 會轉為字串 <code>&quot;[object Object]&quot;</code>。</li>
<li><code>{} + []</code> 中，{} 被當成空區塊而無作用，+[] 被當成強制轉型為數字 Number([]) （由於陣列是物件，中間會先使用 toString 轉成字空串，導致變成 Number(‘’)）而得到 <code>0</code>。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="null-NaN-undefined"><a href="#null-NaN-undefined" class="headerlink" title="null, NaN, undefined"></a>null, NaN, undefined</h1><ul>
<li>null 表示無、空值，未知的特殊值，typeof(null) -&gt; object，這是一個誤解，因為 typeof 用型別標籤來辨別，null的型別標籤為 000，符合 object 的 type 所以會產生這個結果，這可以說是一種 bug，詳見:<a href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Operators/typeof" target="_blank" rel="noopener">typeof</a></li>
<li>NaN 表示不是一個數字(not a number)，typeof(NaN) -&gt; number</li>
<li>undefined 表示未被賦值，有宣告但未給予數值、字串等值，typeof(undefined) -&gt; undefined，不等於 not defined，not defined 是沒有宣告系統不認得的意思</li>
</ul>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="https://zh.javascript.info/type-conversions" target="_blank" rel="noopener">javascript.info:type-conversions</a><br><a href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Data_structures" target="_blank" rel="noopener">JavaScript 的資料型別與資料結構</a><br><a href="https://cythilya.github.io/2018/10/24/object/" target="_blank" rel="noopener">型別（Type）</a><br><a href="https://cythilya.github.io/2018/10/15/coercion/" target="_blank" rel="noopener">強制轉型（Coercion）</a></p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="https://chinyun.github.io/myblog/myblog/2019/11/09/DOM-Event/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="chinyun">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/myblog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jinny's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/myblog/2019/11/09/DOM-Event/" class="post-title-link" itemprop="url">DOM Event</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-11-09 16:48:30" itemprop="dateCreated datePublished" datetime="2019-11-09T16:48:30+00:00">2019-11-09</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-11-13 12:13:55" itemprop="dateModified" datetime="2019-11-13T12:13:55+00:00">2019-11-13</time>
              </span>
            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="DOM-Document-Object-Model"><a href="#DOM-Document-Object-Model" class="headerlink" title="DOM (Document Object Model)"></a>DOM (Document Object Model)</h1><p>W3C(World Wide Web Consortium) 全球資訊網協會訂定了 DOM 的標準，將 DOM 區分為三部分：core DOM、XML DOM、HTML DOM。HTML DOM 是用來取得、修改、新增、刪除 HTML 元素，有了明確的標準不同瀏覽器才能提供一套相同的操作方式給開發者使用。<br>DOM 的樹狀結構是一種有階層(父子關係)的資料結構，以節點(node)代表一個物件，物件本身具有屬性和方法，上層的節點為父節點(parent)下層節點為子節點(child)，一個父節點可能有很多個子節點，但子節點只會有一個父節點。<br>在 document 之上其實還有一個 window 物件，它不屬於 DOM 但實作時經常會使用到 window 提供的屬性及方法，例如： setInterval, clearIntervel, confirm, alert, location</p>
<h1 id="DOM-事件傳遞機制"><a href="#DOM-事件傳遞機制" class="headerlink" title="DOM 事件傳遞機制"></a>DOM 事件傳遞機制</h1><p>事件在 DOM 裡面有既定的傳遞順序，假設你有一個 ul 元素，底下有很多 li ，代表不同的 item，當你點擊任何一個 li 的時候，其實也點擊了 ul，因為 ul 把所有的 li 都包住了。假如我在兩個元素上面都加了eventListener，哪一個會先執行？這時候知道事件的執行順序就很重要。</p>
<p>DOM 事件觸發有三個階段，例如：當點擊事件發生時，會先從 window 開始往下傳遞，一直傳到被點擊的該物件為止，到這邊就叫做 CAPTURING_PHASE 捕獲階段，接著事件傳遞到物件本身，這時候叫做 AT_TARGET，最後事件會從物件一路傳回去 window，這時候叫做 BUBBLING_PHASE 冒泡階段。</p>
<ul>
<li><p>先捕獲(capturing)再冒泡(bubbling)，當事件傳到 target 本身，沒有分捕獲跟冒泡:<br>一般而言是先捕獲再冒泡，但是當事件傳遞到點擊的真正對象，也就是 event.target 的時候，無論你使用 addEventListener 的第三個參數是 true 還是 false，這邊的 event.eventPhase 都會變成 AT_TARGET，既然這邊已經變成 AT_TARGET ，自然就沒有什麼捕獲跟冒泡之分，所以執行順序就會根據 addEventListener 的順序而定，先添加的先執行，後添加的後執行。</p>
</li>
<li><p>事件註冊，加上監聽機制的方法：<code>target.addEventListener(type, listener[, useCapture]);</code><br>addEventListener 函數的第三個參數是 boolean 值，可以決定事先採取被觸發事件的動作反應，還是其外部元素的觸發動作。設定為 true 代表把這個 listener 添加到捕獲階段，false 代表把這個 listener 添加到冒泡階段，預設為false、在冒泡階段 listen 事件觸發。一個 element可以有多個 eventlistener，監聽不同事件(event)，設置指定動作(function)。</p>
</li>
</ul>
<h1 id="stopPropagation-amp-preventDefault"><a href="#stopPropagation-amp-preventDefault" class="headerlink" title="stopPropagation &amp; preventDefault"></a>stopPropagation &amp; preventDefault</h1><ul>
<li><p>stopPropagation：取消事件繼續往下傳遞。加在哪邊，事件的傳遞就斷在哪裡，不會繼續往下傳遞給下一個節點。<br>用法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$list.addEventListener(&apos;click&apos;, (e) =&gt; &#123;</span><br><span class="line">  console.log(&apos;list capturing&apos;);</span><br><span class="line">  e.stopPropagation();</span><br><span class="line">&#125;, true)</span><br></pre></td></tr></table></figure>

<p>儘管已經用e.stopPropagation，但對於同一個層級，剩下的 listener 還是會被執行到，若是你想要讓其他同一層級的 listener 也不要被執行，可以改用 e.stopImmediatePropagation();</p>
</li>
<li><p>preventDefault：取消瀏覽器的預設行為。最常見的例子是阻止點擊<code>&lt;a&gt;</code>時新開分頁、跳轉或<code>&lt;form&gt;</code> submit action。<br>preventDefault 跟事件傳遞「一點關係都沒有」，事件還是會繼續往下傳遞。有一個特別值得注意的地方是 W3C 的文件裡面有寫到：Once preventDefault has been called it will remain in effect throughout the remainder of the event’s propagation. 意思就是說一旦 call 了 preventDefault，在之後傳遞下去的事件裡面也會有效果。<br>用法舉例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">form.addEventListener(&apos;submit&apos;,e=&gt;&#123;</span><br><span class="line">  e.preventDefault(); // 把原生的 Form submit 跳轉行為停掉</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="Event-Delegation"><a href="#Event-Delegation" class="headerlink" title="Event Delegation"></a>Event Delegation</h1><p>事件代理機制是將許多事件綁定在同一節點，透過該節點使下層的子節點都可以觸發事件，因為只要綁定一個地方不需要每個子節點或後來新增的節點都綁定所以叫做事件代理。</p>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="https://medium.com/@realdennis/javascript-%E4%BA%8B%E4%BB%B6-event-da8104c5c98c" target="_blank" rel="noopener">事件 (Event) 的註冊、觸發與傳遞</a><br><a href="https://blog.techbridge.cc/2017/07/15/javascript-event-propagation/" target="_blank" rel="noopener">DOM 的事件傳遞機制：捕獲與冒泡</a></p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="https://chinyun.github.io/myblog/myblog/2019/11/08/css-pseudo-class-pseudo-element/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="chinyun">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/myblog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jinny's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/myblog/2019/11/08/css-pseudo-class-pseudo-element/" class="post-title-link" itemprop="url">css pseudo class & pseudo element</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-11-08 18:39:38" itemprop="dateCreated datePublished" datetime="2019-11-08T18:39:38+00:00">2019-11-08</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-11-13 12:13:55" itemprop="dateModified" datetime="2019-11-13T12:13:55+00:00">2019-11-13</time>
              </span>
            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>單冒號 (:) 是用在偽類<br>雙冒號 (::) 則是用在偽元素<br>偽類 (pseudo class) 就是在選已經存在的東西，比方說 <code>a:hover</code> 就是選了已經存在的 <code>&lt;a&gt;</code> 的某一個狀態<br>偽元素 (pseudo element) 就是在創造一個新的假元素，因為他不在 DOM 裡面，而是創造的了一個我們看不見的元素。比如說 <code>::first-line</code>，第一行並沒有被任何的 tag 包住，所以在選取的過程就像是用了一個看不到的 tag 把第一行包起來，所以才選得到這行。</p>
<p>使用偽類元素，一方面可以減少頁面中的節點元素，加速頁面渲染速度，另一方面可以為設計動畫提供很多新思維。</p>
<h1 id="pseudo-class"><a href="#pseudo-class" class="headerlink" title="pseudo class"></a>pseudo class</h1><p>Pseudo-classes are used to provide styles not for elements, but for various states of elements. The pseudo-class concept is introduced to permit selection based on information that lies outside of the document tree or that cannot be expressed using the other <em>simple selectors</em>.<br>用於定義元素的特殊狀態，為了選擇 DOM tree 之外的信息，或者使用其他簡單選擇器不能表達的信息，不會出現在 DOM tree。</p>
<p>Simple selectors includes:</p>
<ul>
<li>type selector (<code>h1, p, div</code>)</li>
<li>universal selector (<code>*</code>)</li>
<li>attribute selector (<code>img[alt]</code>)</li>
<li>class selector (<code>.class</code>)</li>
<li>ID selector (<code>#id</code>)</li>
<li>pseudo-class (<code>:</code>) <ul>
<li><strong>:active</strong> </li>
<li><strong>:hover</strong> 設定滑鼠滑過的樣式</li>
<li><strong>:visited</strong> 被訪問過的連結的樣式</li>
<li><strong>:link</strong></li>
<li><strong>:nth-child()</strong></li>
<li><strong>:checked</strong></li>
</ul>
</li>
</ul>
<p>狀態不存在 DOM 裡面，或是這幾種 simple selectors 選不到的東西，就是 pseudo-class 要去解決的問題。</p>
<h1 id="pseudo-element"><a href="#pseudo-element" class="headerlink" title="pseudo element"></a>pseudo element</h1><p>Pseudo elements differ from pseudo-classes in that they don’t select states of elements; they select parts of an element. 用於選擇元素的指定部分，創造一個關於 DOM tree 的抽象內容，提供一種方法來引用源文檔中不存在的內容，創造之後會出現在 DOM tree，偽元素也會「繼承」原本元素的屬性。</p>
<ul>
<li><strong>::first-line</strong> 選取第一行</li>
<li><strong>::first-letter</strong> 選取第一個字</li>
<li><strong>::before</strong> 在原本的元素「之前」加入內容</li>
<li><strong>::after</strong> 在原本的元素「之後」加入內容</li>
<li><strong>::selection</strong> 選取文字反白後</li>
</ul>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="https://stringpiggy.hpd.io/pseudo-element-pseudo-class-difference/" target="_blank" rel="noopener">偽元素 (pseudo element) 和偽類 (pseudo class) 差在哪？</a><br><a href="https://www.itread01.com/content/1549211047.html" target="_blank" rel="noopener">css偽類元素的運用以及相應的hover的使用</a><br><a href="https://ithelp.ithome.com.tw/articles/10196924" target="_blank" rel="noopener">CSS 偽類 與 偽元素</a><br><a href="http://csscoke.com/2013/09/21/%E4%BD%BF%E7%94%A8css3-nth-childn-%E9%81%B8%E5%8F%96%E5%99%A8%E8%A9%B3%E8%A7%A3/" target="_blank" rel="noopener">使用CSS3 :nth-child(n) 選取器教學</a><br><a href="https://www.oxxostudio.tw/articles/201405/css-selector.html" target="_blank" rel="noopener">CSS 偽類 child 和 of-type</a><br><a href="https://www.oxxostudio.tw/articles/201706/pseudo-element-1.html" target="_blank" rel="noopener">CSS 偽元素 ( before 與 after )</a></p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="https://chinyun.github.io/myblog/myblog/2019/11/05/Redux-connect-Redux-part-to-React/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="chinyun">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/myblog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jinny's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/myblog/2019/11/05/Redux-connect-Redux-part-to-React/" class="post-title-link" itemprop="url">Connect Redux part to React</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-11-05 16:13:00" itemprop="dateCreated datePublished" datetime="2019-11-05T16:13:00+00:00">2019-11-05</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-11-13 12:13:55" itemprop="dateModified" datetime="2019-11-13T12:13:55+00:00">2019-11-13</time>
              </span>
            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>以下筆記如何在 react app 中引入 redux：<br>示範 code 專案：<a href="https://github.com/chinyun/Tripper-app-redux/blob/master/src/index.js" target="_blank" rel="noopener">Tripper-app-redux</a></p>
<h1 id="程式碼"><a href="#程式碼" class="headerlink" title="程式碼"></a>程式碼</h1><p>in Tripper-app-redux’s index.js:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import React from &apos;react&apos;;</span><br><span class="line">import ReactDOM from &apos;react-dom&apos;;</span><br><span class="line">import &#123; Provider &#125; from &apos;react-redux&apos;;</span><br><span class="line">import &#123; createStore, applyMiddleware, combineReducers &#125; from &apos;redux&apos;;</span><br><span class="line">import &#123; createLogger &#125; from &apos;redux-logger&apos;;</span><br><span class="line">import thunkMiddleware from &apos;redux-thunk&apos;;</span><br><span class="line">import &#123; requestLogIn, routeChange, requestData &#125; from &apos;./reducers&apos;;</span><br><span class="line">import App from &apos;./containers/App&apos;;</span><br><span class="line"></span><br><span class="line">const logger = createLogger();</span><br><span class="line"></span><br><span class="line">const rootReducer = combineReducers(&#123;requestLogIn, routeChange, requestData&#125;);</span><br><span class="line">const store = createStore(rootReducer, applyMiddleware(thunkMiddleware, logger));</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;Provider store=&#123;store&#125;&gt;</span><br><span class="line">    &lt;App/&gt;</span><br><span class="line">  &lt;/Provider&gt;, document.getElementById(&apos;root&apos;));</span><br></pre></td></tr></table></figure>

<p>in Tripper-app-redux’s App.js:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">import &#123; connect &#125; from &apos;react-redux&apos;;</span><br><span class="line">import &#123; routeChange &#125; from &apos;../actions&apos;;</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">const mapStateToProps = (state) =&gt; &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    user: state.requestData.user,</span><br><span class="line">    journeys: state.requestData.journeys,</span><br><span class="line">    initialJourney: state.requestData.initialJourney,</span><br><span class="line">    journeyList: state.requestData.journeyList,</span><br><span class="line">    route: state.routeChange.route,</span><br><span class="line">    isSignedIn: state.requestLogIn.isSignedIn</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const mapDispatchToProps = (dispatch) =&gt; &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    onRouteChange: (route) =&gt; dispatch(routeChange(route))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line"></span><br><span class="line">export default connect(mapStateToProps, mapDispatchToProps)(App);</span><br></pre></td></tr></table></figure>

<h1 id="Redux-Store-and-Provider"><a href="#Redux-Store-and-Provider" class="headerlink" title="Redux Store and Provider"></a>Redux Store and Provider</h1><p><code>&lt;Provider&gt;&lt;/Provider&gt;</code>包住<code>&lt;App&gt;</code>他會把 store 用 props 傳給所有 App 包含的子組件。<br>The logger will catch the actions and console.log() the action that is going to go to the reducer.</p>
<p>Store binds together the 3 principles fo Redux:</p>
<ol>
<li>The entire state of the application will be represented by one JavaScript Object. -&gt;  Store holds the current application state object. </li>
<li>The state is read only, and can only be modified by dispatching actions. -&gt; Store allows you to dispatch actions.</li>
<li>To specify how actions change state tree, the reducers should be pure functions. -&gt; When you create the Store, <strong>you need to specify the Reducer that tells how states updated with actions.</strong></li>
</ol>
<p>Store 有三個重要的 methods:</p>
<ol>
<li>getState(): run console.log(store.getState()) =&gt; get the current state of the Redux Store.</li>
<li><strong>dispatch(): dispatch actions to change the state of the application.</strong></li>
<li>subscribe(): register a callback that the redux store will call any time an action has been dispatched. So you can update the UI of application to reflect the current application’s state.</li>
</ol>
<p>運用 <code>combineReducers()</code> method 將多個 reducer 綁在一起變成一個，<code>createStore()</code>則負責建立 store，接受兩個參數：要監聽的 reducer、用 applyMiddleware() 加入要使用的 middleware。</p>
<h1 id="Connect"><a href="#Connect" class="headerlink" title="Connect"></a>Connect</h1><p><code>connect()</code> are those which one of these components we want to be smart or be aware that the redux library exists and they subscribe to the changes. The connect function is optimized in order for us to avoid using somthing called <code>store.subscribe()</code>. It is a higher order function, means that a function that return another function. Through connect function, App component now could listen to the states that <code>mapStateToProps</code> gives and interested in actions that <code>mapDispatchToProps</code> gives to the component.</p>
<h1 id="Redux-Middleware"><a href="#Redux-Middleware" class="headerlink" title="Redux Middleware"></a>Redux Middleware</h1><p>Middleware is the suggested way to extend Redux with custom functionality. Middleware lets you wrap the store’s dispatch method for fun and profit. The key feature of middleware is that it is composable. Multiple middleware can be combined together, where each middleware requires no knowledge of what comes before or after it in the chain.<br>Middleware 就像一個 tunnel，在 action 到 reducer 的階段之間建立通道，在 dispatch actions 時適時採取相應的行為。 Middleware helps us to handle side effects, monitor each one of our actions. We can listen to what logging output each one of these actions happen. It provides a third-party extension point between dispatching an action, and the moment it reaches the reducer.</p>
<p>Redux Pattern:</p>
<pre class="mermaid">graph LR;
A(Action) -- Middleware --> B(Reducer);
B --> C(Store);
C --> D(Make changes);</pre>
<p>在 Action 和 Reducer 之間的 Middleware 作用是輔助處理，當 dispatch action 的時候透過 middleware 進行額外動作。<br>常用的 Middleware 例如：</p>
<ul>
<li>redux-logger：監聽 actions，在 console 印出 action type、以及更新前、後的狀態</li>
<li>redux-thunk：額外或是非同步的 dispatch</li>
<li>redux-observable、redux-saga：複雜邏輯 dispatch</li>
</ul>
<p>使用的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const store = createStore(rootReducer, applyMiddleware(thunkMiddleware, logger));</span><br></pre></td></tr></table></figure>

<p>在建立 store 的時候一併設定，透過 applyMiddleware() 放入多個 middleware，表示當 action dispatch時會依序經過 thunkMiddleware、logger 這些 middleware，然後再到 reducer。</p>
<h1 id="Asynchronous-Redux"><a href="#Asynchronous-Redux" class="headerlink" title="Asynchronous Redux"></a>Asynchronous Redux</h1><p>The redux-thunk package that provides a getState and dispatch functions that are passed on. <strong>Redux-thunk can handle asynchronous actions like AJAX calls.</strong> How does this middleware work? Thunk middleware is waiting for a function, it waits and sees if any actions return a function instead of an object. And if it is a function, <strong>give a dispatch so we can call the actions to run</strong> the function as we thought.  </p>
<p>Asynchronous Action 可以寫作這樣：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">export const editBudgets = (data, id, index) =&gt; (dispatch) =&gt; &#123;</span><br><span class="line">  dispatch(&#123; type: REQUEST_DATA_FAILED &#125;);</span><br><span class="line">  fetch(`$&#123;Url&#125;/journeys_budgets/$&#123;id&#125;`, &#123;</span><br><span class="line">    method: &apos;PATCH&apos;,</span><br><span class="line">    headers: &#123;&apos;Content-Type&apos;: &apos;application/json&apos;&#125;,</span><br><span class="line">    body: JSON.stringify(data)</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(response =&gt; response.json())</span><br><span class="line">  .then(journey =&gt; &#123;</span><br><span class="line">    if (journey) &#123;</span><br><span class="line">      dispatch(&#123;</span><br><span class="line">        type: REQUEST_UPDATE_BUDGETS_SUCCESS,</span><br><span class="line">        payload: &#123;</span><br><span class="line">          data: journey,</span><br><span class="line">          index: index</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      alert(&apos;unable to edit budget&apos;)</span><br><span class="line">    &#125;    </span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(err =&gt; dispatch(&#123; type: REQUEST_DATA_FAILED, payload: err &#125;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中 <code>const editBudgets = (data, id, index) =&gt; (dispatch) =&gt; {...}</code> 表示 A function that return another function, redux wouldn’t understand it. Because it’s not an object, as it expects for an action. With the redux-thunk middleware, now we’re listening to actions. Anytime the actions get triggered it’s going to return a function and trigger redux-thunk and redux-thunk is going to know whether it is a function or not then give it a dispatch to call action to run.</p>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="https://redux.js.org/introduction/getting-started" target="_blank" rel="noopener">redux 官方</a></p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
  </div>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/myblog/page/2/">2</a><a class="page-number" href="/myblog/page/3/">3</a><a class="extend next" rel="next" href="/myblog/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>


          </div>
          

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">chinyun</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        
          <a href="/myblog/archives/">
        
          <span class="site-state-item-count">27</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
    
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">chinyun</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> v3.9.0</div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.4.1</div>
  <script src='https://unpkg.com/mermaid@7.1.2/dist/mermaid.min.js'></script>
  <script>
    if (window.mermaid) {
      mermaid.initialize("");
    }
  </script>

        












        
      </div>
    </footer>
  </div>

  
  <script src="/myblog/lib/anime.min.js?v=3.1.0"></script>
  <script src="/myblog/lib/velocity/velocity.min.js?v=1.2.1"></script>
  <script src="/myblog/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
<script src="/myblog/js/utils.js?v=7.4.1"></script><script src="/myblog/js/motion.js?v=7.4.1"></script>
<script src="/myblog/js/schemes/pisces.js?v=7.4.1"></script>
<script src="/myblog/js/next-boot.js?v=7.4.1"></script>



  

















<script>
if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.initialize({
      theme: 'forest',
      logLevel: 3,
      flowchart: { curve: 'linear' },
      gantt: { axisFormat: '%m/%d/%Y' },
      sequence: { actorMargin: 50 }
    });
  }, window.mermaid);
}
</script>




  

  

  

</body>
</html>
