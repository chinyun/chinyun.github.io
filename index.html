<!DOCTYPE html>





<html lang="zh-tw">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.9.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/myblog/images/apple-touch-icon-next.png?v=7.4.1">
  <link rel="icon" type="image/png" sizes="32x32" href="/myblog/images/favicon-32x32-next.png?v=7.4.1">
  <link rel="icon" type="image/png" sizes="16x16" href="/myblog/images/favicon-16x16-next.png?v=7.4.1">
  <link rel="mask-icon" href="/myblog/images/logo.svg?v=7.4.1" color="#222">

<link rel="stylesheet" href="/myblog/css/main.css?v=7.4.1">


<link rel="stylesheet" href="/myblog/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/myblog/',
    scheme: 'Pisces',
    version: '7.4.1',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: 'Copy',
      copy_success: 'Copied',
      copy_failure: 'Copy failed'
    },
    sidebarPadding: 40
  };
</script>

  <meta name="keywords" content="JavaScript, React, d3, NodeJS, Web">
<meta property="og:type" content="website">
<meta property="og:title" content="Jinny&#39;s blog">
<meta property="og:url" content="https://chinyun.github.io/myblog/index.html">
<meta property="og:site_name" content="Jinny&#39;s blog">
<meta property="og:locale" content="zh-tw">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Jinny&#39;s blog">
  <link rel="canonical" href="https://chinyun.github.io/myblog/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false,
    isPage: false,
    isArchive: false
  };
</script>

  <title>Jinny's blog</title>
  








  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-tw">
  <div class="container use-motion">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/myblog/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Jinny's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">Writing For Sharing</p>
      
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
      
      
      
        
        <li class="menu-item menu-item-home">
      
    

    <a href="/myblog/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-archives">
      
    

    <a href="/myblog/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
            

          <div id="content" class="content">
            
  <div id="posts" class="posts-expand">
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="https://chinyun.github.io/myblog/myblog/2019/11/05/Redux-connect-Redux-part-to-React/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="chinyun">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/myblog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jinny's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/myblog/2019/11/05/Redux-connect-Redux-part-to-React/" class="post-title-link" itemprop="url">Connect Redux part to React</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-11-05 16:13:00" itemprop="dateCreated datePublished" datetime="2019-11-05T16:13:00+00:00">2019-11-05</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-11-07 14:21:10" itemprop="dateModified" datetime="2019-11-07T14:21:10+00:00">2019-11-07</time>
              </span>
            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>以下筆記如何在 react app 中引入 redux：<br>示範 code 專案：<a href="https://github.com/chinyun/Tripper-app-redux/blob/master/src/index.js" target="_blank" rel="noopener">Tripper-app-redux</a></p>
<h1 id="程式碼"><a href="#程式碼" class="headerlink" title="程式碼"></a>程式碼</h1><p>in Tripper-app-redux’s index.js:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import React from &apos;react&apos;;</span><br><span class="line">import ReactDOM from &apos;react-dom&apos;;</span><br><span class="line">import &#123; Provider &#125; from &apos;react-redux&apos;;</span><br><span class="line">import &#123; createStore, applyMiddleware, combineReducers &#125; from &apos;redux&apos;;</span><br><span class="line">import &#123; createLogger &#125; from &apos;redux-logger&apos;;</span><br><span class="line">import thunkMiddleware from &apos;redux-thunk&apos;;</span><br><span class="line">import &#123; requestLogIn, routeChange, requestData &#125; from &apos;./reducers&apos;;</span><br><span class="line">import App from &apos;./containers/App&apos;;</span><br><span class="line"></span><br><span class="line">const logger = createLogger();</span><br><span class="line"></span><br><span class="line">const rootReducer = combineReducers(&#123;requestLogIn, routeChange, requestData&#125;);</span><br><span class="line">const store = createStore(rootReducer, applyMiddleware(thunkMiddleware, logger));</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;Provider store=&#123;store&#125;&gt;</span><br><span class="line">    &lt;App/&gt;</span><br><span class="line">  &lt;/Provider&gt;, document.getElementById(&apos;root&apos;));</span><br></pre></td></tr></table></figure>

<p>in Tripper-app-redux’s App.js:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">import &#123; connect &#125; from &apos;react-redux&apos;;</span><br><span class="line">import &#123; routeChange &#125; from &apos;../actions&apos;;</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">const mapStateToProps = (state) =&gt; &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    user: state.requestData.user,</span><br><span class="line">    journeys: state.requestData.journeys,</span><br><span class="line">    initialJourney: state.requestData.initialJourney,</span><br><span class="line">    journeyList: state.requestData.journeyList,</span><br><span class="line">    route: state.routeChange.route,</span><br><span class="line">    isSignedIn: state.requestLogIn.isSignedIn</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const mapDispatchToProps = (dispatch) =&gt; &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    onRouteChange: (route) =&gt; dispatch(routeChange(route))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line"></span><br><span class="line">export default connect(mapStateToProps, mapDispatchToProps)(App);</span><br></pre></td></tr></table></figure>

<h1 id="Redux-Store-and-Provider"><a href="#Redux-Store-and-Provider" class="headerlink" title="Redux Store and Provider"></a>Redux Store and Provider</h1><p><code>&lt;Provider&gt;&lt;/Provider&gt;</code>包住<code>&lt;App&gt;</code>他會把 store 用 props 傳給所有 App 包含的子組件。<br>The logger will catch the actions and console.log() the action that is going to go to the reducer.</p>
<p>Store binds together the 3 principles fo Redux:</p>
<ol>
<li>The entire state of the application will be represented by one JavaScript Object. -&gt;  Store holds the current application state object. </li>
<li>The state is read only, and can only be modified by dispatching actions. -&gt; Store allows you to dispatch actions.</li>
<li>To specify how actions change state tree, the reducers should be pure functions. -&gt; When you create the Store, <strong>you need to specify the Reducer that tells how states updated with actions.</strong></li>
</ol>
<p>Store 有三個重要的 methods:</p>
<ol>
<li>getState(): run console.log(store.getState()) =&gt; get the current state of the Redux Store.</li>
<li><strong>dispatch(): dispatch actions to change the state of the application.</strong></li>
<li>subscribe(): register a callback that the redux store will call any time an action has been dispatched. So you can update the UI of application to reflect the current application’s state.</li>
</ol>
<p>運用 <code>combineReducers()</code> method 將多個 reducer 綁在一起變成一個，<code>createStore()</code>則負責建立 store，接受兩個參數：要監聽的 reducer、用 applyMiddleware() 加入要使用的 middleware。</p>
<h1 id="Connect"><a href="#Connect" class="headerlink" title="Connect"></a>Connect</h1><p><code>connect()</code> are those which one of these components we want to be smart or be aware that the redux library exists and they subscribe to the changes. The connect function is optimized in order for us to avoid using somthing called <code>store.subscribe()</code>. It is a higher order function, means that a function that return another function. Through connect function, App component now could listen to the states that <code>mapStateToProps</code> gives and interested in actions that <code>mapDispatchToProps</code> gives to the component.</p>
<h1 id="Redux-Middleware"><a href="#Redux-Middleware" class="headerlink" title="Redux Middleware"></a>Redux Middleware</h1><p>Middleware is the suggested way to extend Redux with custom functionality. Middleware lets you wrap the store’s dispatch method for fun and profit. The key feature of middleware is that it is composable. Multiple middleware can be combined together, where each middleware requires no knowledge of what comes before or after it in the chain.<br>Middleware 就像一個 tunnel，在 action 到 reducer 的階段之間建立通道，在 dispatch actions 時適時採取相應的行為。 Middleware helps us to handle side effects, monitor each one of our actions. We can listen to what logging output each one of these actions happen. It provides a third-party extension point between dispatching an action, and the moment it reaches the reducer.</p>
<p>Redux Pattern:</p>
<pre class="mermaid">graph LR;
A(Action) -- Middleware --> B(Reducer);
B --> C(Store);
C --> D(Make changes);</pre>
<p>在 Action 和 Reducer 之間的 Middleware 作用是輔助處理，當 dispatch action 的時候透過 middleware 進行額外動作。<br>常用的 Middleware 例如：</p>
<ul>
<li>redux-logger：監聽 actions，在 console 印出 action type、以及更新前、後的狀態</li>
<li>redux-thunk：額外或是非同步的 dispatch</li>
<li>redux-observable、redux-saga：複雜邏輯 dispatch</li>
</ul>
<p>使用的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const store = createStore(rootReducer, applyMiddleware(thunkMiddleware, logger));</span><br></pre></td></tr></table></figure>

<p>在建立 store 的時候一併設定，透過 applyMiddleware() 放入多個 middleware，表示當 action dispatch時會依序經過 thunkMiddleware、logger 這些 middleware，然後再到 reducer。</p>
<h1 id="Asynchronous-Redux"><a href="#Asynchronous-Redux" class="headerlink" title="Asynchronous Redux"></a>Asynchronous Redux</h1><p>The redux-thunk package that provides a getState and dispatch functions that are passed on. <strong>Redux-thunk can handle asynchronous actions like AJAX calls.</strong> How does this middleware work? Thunk middleware is waiting for a function, it waits and sees if any actions return a function instead of an object. And if it is a function, <strong>give a dispatch so we can call the actions to run</strong> the function as we thought.  </p>
<p>Asynchronous Action 可以寫作這樣：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">export const editBudgets = (data, id, index) =&gt; (dispatch) =&gt; &#123;</span><br><span class="line">  dispatch(&#123; type: REQUEST_DATA_FAILED &#125;);</span><br><span class="line">  fetch(`$&#123;Url&#125;/journeys_budgets/$&#123;id&#125;`, &#123;</span><br><span class="line">    method: &apos;PATCH&apos;,</span><br><span class="line">    headers: &#123;&apos;Content-Type&apos;: &apos;application/json&apos;&#125;,</span><br><span class="line">    body: JSON.stringify(data)</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(response =&gt; response.json())</span><br><span class="line">  .then(journey =&gt; &#123;</span><br><span class="line">    if (journey) &#123;</span><br><span class="line">      dispatch(&#123;</span><br><span class="line">        type: REQUEST_UPDATE_BUDGETS_SUCCESS,</span><br><span class="line">        payload: &#123;</span><br><span class="line">          data: journey,</span><br><span class="line">          index: index</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      alert(&apos;unable to edit budget&apos;)</span><br><span class="line">    &#125;    </span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(err =&gt; dispatch(&#123; type: REQUEST_DATA_FAILED, payload: err &#125;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中 <code>const editBudgets = (data, id, index) =&gt; (dispatch) =&gt; {...}</code> 表示 A function that return another function, redux wouldn’t understand it. Because it’s not an object, as it expects for an action. With the redux-thunk middleware, now we’re listening to actions. Anytime the actions get triggered it’s going to return a function and trigger redux-thunk and redux-thunk is going to know whether it is a function or not then give it a dispatch to call action to run.</p>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="https://redux.js.org/introduction/getting-started" target="_blank" rel="noopener">redux 官方</a></p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="https://chinyun.github.io/myblog/myblog/2019/11/02/HTTPS-HTTP-JSON-AJAX/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="chinyun">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/myblog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jinny's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/myblog/2019/11/02/HTTPS-HTTP-JSON-AJAX/" class="post-title-link" itemprop="url">HTTPS/HTTP/JSON/AJAX/RestfulAPI</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-11-02 23:52:26" itemprop="dateCreated datePublished" datetime="2019-11-02T23:52:26+00:00">2019-11-02</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-11-07 14:21:10" itemprop="dateModified" datetime="2019-11-07T14:21:10+00:00">2019-11-07</time>
              </span>
            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="How-is-the-Internet-work"><a href="#How-is-the-Internet-work" class="headerlink" title="How is the Internet work?"></a>How is the Internet work?</h1><p>現代網路運作的基礎主要由瀏覽器、伺服器以及網路資料的傳遞組成，當使用者在自己電腦透過瀏覽器瀏覽網頁時，會從瀏覽器發出造訪某網頁網址的請求，而該網址所屬的網站伺服器接收到請求內容後，返回包含了 HTML、CSS、JavaScript 等的檔案，瀏覽器接到回應之後將網站呈現在畫面上，上述這個瀏覽器發出請求(request)、伺服器給予回應(response)的過程就是一般我們在瀏覽器輸入網址後，到瀏覽器渲染出頁面之間發生的事情。</p>
<p>網路資料傳遞的原則：</p>
<ol>
<li>有標準化的內容格式</li>
<li>資料結構分為 header 和 body</li>
<li>用狀態碼 http status 標準化傳輸結果</li>
<li>用動詞 http method 標準化動作： GET、POST、DELETE、PUT、PATCH</li>
<li>protocol 協定：定義資料交換的格式，標準化促成規模化 ex: http、https</li>
</ol>
<h1 id="HTTP-vs-HTTPS"><a href="#HTTP-vs-HTTPS" class="headerlink" title="HTTP vs. HTTPS"></a>HTTP vs. HTTPS</h1><ul>
<li><p>HTTP(Hyper Text Transfer Protocol) 超文本傳輸協定<br>In 1989 Tim Berners-Lee invented the World Wide Web and built the HTTP for transferring HTML document around the world. HTTP is a protocol or the rules that we use over the wires. It is a foundation of any data exchange on the web.</p>
<ul>
<li>HTTP Method<ul>
<li>GET：透過 API 把資料內容撈出來，這些內容通常是可以對外公布，不需要密碼帳號就可以取得的資料。</li>
<li>POST：新增一筆資料</li>
<li>DELETE：刪除資料</li>
<li>PUT：更新一筆資料，如果存在這筆資料就會覆蓋過去</li>
<li>PATCH：部分更新資料</li>
</ul>
</li>
</ul>
</li>
<li><p>HTTPS(Hyper Text Transfer Protocol Secure) 超文本安全傳輸協定<br>HTTPS(Hyper Text Transfer Protocol Secure) use TLS and SSL technology to encrypt the information that transported. Only the server or client web could have the secret key to read the message.</p>
</li>
</ul>
<p>主要是由網景公司(Netscape)開發並內建於其瀏覽器中，之後廣泛發展於網際網路上，用於對資料進行壓縮傳輸及傳輸後解壓縮回正確資訊的操作。隨著網路的發達，資訊技術越來越透明，HTTP 的開放明文顯得在網際網路中，不再是這麼安全的傳送協定，知名企業網站及全球級大型網站 Google、Facebook 等皆採用 HTTPS 加密，作為預設連線方式，因此有使用者登入系統或或存取到機密敏感資料頁面等有建立會員、購物車、金流、刷卡機制服務的網站選擇使用HTTPS的傳送協定。</p>
<p>HTTPS 其實就是在原本的 HTTP 協定中延伸加入 SSL(Secure Sockets Layer,傳輸層安全協議) 或 TLS(Transport Layer Security，傳輸層安全) 憑證的安全連線技術。SSL/TLS 憑證是網頁伺服器和瀏覽器之間以加解密方式溝通的安全技術標準，透過憑證內的公開金鑰加密資料傳輸至伺服器端，伺服器端用私密金鑰解密來證明自己的身份，取得有效憑證後在網際網路上傳輸加密過的資料以達到資安的目的。</p>
<p>當您在伺服器與連線至伺服器的瀏覽器上安裝 SSL 憑證時，SSL 憑證的存在會觸發 SLL (或 TLS) 協議，這將加密伺服器與瀏覽器之間 (或伺服器之間) 發送的資訊；詳細資料顯然更加複雜一些。</p>
<p>運作流程：</p>
<ol>
<li>SSL 在 TCP 連線建立後開始運作，啟動 SSL信號交換。</li>
<li>伺服器發送憑證至使用者，同時附上大量規格 (包括哪個版本的 SSL/TLS 以及使用哪個加密方法等。)</li>
<li>然後使用者檢查憑證的有效性，並選擇雙方都支援的最高等級的加密，並使用這些方法啟動安全的工作階段。有很多組方法可用優勢各異，被稱為密碼組。</li>
<li>為了確保所有傳輸訊息的完整性與真實性，SSL 與 TLS 協議也包括使用訊息驗證程式碼的驗證程序。這些方法聽上去冗長又複雜，但在現實生活中是瞬間實現的。</li>
</ol>
<p>SSL 直接在傳輸控制協議之上 (TCP) 運作，像安全感毛毯一樣有效。其允許最高的協議層不變，同時仍然提供安全連線。所以在 SSL 層下，其他協議層可以照常運作。若 SSL 憑證使用正確，所有攻擊者將看到哪個 IP 與通訊埠已連線以及大概在發送多少資料。他們或許可以終止連線，但是伺服器與使用者可以知道這是由第三方造成的。但是，他們無法攔截任何資料，所以使攻擊從根本上變得無效。</p>
<p>取得SSL憑證的方法就是向憑證廠商購買，<br>SSL憑證費用依照加密的等級、販售廠商而有所不同，可以依照網站性質與企業規模選擇SSL的加密程度以及衡量費用支出。一般來說，SSL憑證的發行廠商是不會影響搜尋排名，但是Google Chrome於2017年公布賽門鐵克(Symantec)發行的SSL視為無效化，並於2018/3/7公布Chrome 66連上賽門鐵克的SSL時呈現的警告畫面，被Chrome 視為無效的SSL憑證發行商名單:Thawte、VeriSign、Equifax、GeoTrust、RapidSSL、Symantec。</p>
<h1 id="AJAX-and-JSON"><a href="#AJAX-and-JSON" class="headerlink" title="AJAX and JSON"></a>AJAX and JSON</h1><p>AJAX (<strong>Asynchronous JavaScript And XML/JSON</strong>) 非同步的 JavaScript 與 XML 技術，這是在2005年由Jesse James Garrett所發明的術語，描述一個使用多種既有技術的新方法。這些技術包括 HTTPS/HTTP 通訊協定、發 HTTP Request 方法(例如 fetch api)、XHR(XMLHttpRequest)或 JSON。使用 AJAX 能使網頁應用程式更快速、即時的更動介面內容，而不需要刷新整個頁面，讓程式更快回應使用者的操作，可以在網頁操作過程當中，不用刷新網頁就可以得到新的資訊。</p>
<ul>
<li><p>JavaScript：在 AJAX 技術裡，使用 JavaScript 將所有技術串連，當 server 回傳對應的資料給 client 時，我們可以透過 JavaScript 去解析和拆解這些資料，並使用 DOM 提供的方法把資料放進網頁。</p>
</li>
<li><p>非同步的 JavaScript：使用非同步的請求和回應，這表示當使用者點擊網頁中的一個連結時，即使該操作還未結束，仍可以對網頁做其他操作，同步的話則無法。</p>
</li>
</ul>
<blockquote>
<p>非同步 Asynchronous：指可以同時進行多件任務，而不需等待前一任務結束。同步 Synchronous:必須等待上一任務完成才能進行下一個。</p>
</blockquote>
<ul>
<li>XML/JSON：<ul>
<li>XML(Extensible Markup Language)：可延伸標記式語言是一種標記式語言，設計用來傳輸和儲存 data。標記指電腦所能理解的資訊符號，通過此種標記，電腦之間可以處理包含各種資訊的文章等。如何定義這些標記，既可以選擇國際通用的標記式語言，比如HTML，也可以使用像XML這樣由相關人士自由決定的標記式語言，這就是語言的可延伸性。XML是從標準通用標記式語言中簡化修改出來的。</li>
<li>JSON(JavaScript Object Notation)：是一種由道格拉斯·克羅克福特構想和設計、輕量級的資料交換語言，將結構化資料 (structured data) 呈現為 JavaScript 物件的標準格式，常用於網站上的資料呈現、傳輸 (例如將資料從伺服器送至用戶端，以利顯示網頁) JSON 可能是物件或字串，當你想從 JSON中讀取資料時，JSON可作為物件；當要跨網路傳送 JSON 時，就會是字串，因為 JSON 可以通過一個標準的 JS 函數解析(JSON.parse()將接收到的 JSON 內容解析成 JavaScript Object、JSON.stringfy()將 Object 轉成 sever 可以傳輸的 JSON string)，我們可以將任何 Object 轉換成 JSON，並使用 JSON 和 server 溝通，再由 JSON 轉換收到的訊息成 JavaScript Object。</li>
</ul>
</li>
</ul>
<p>兩者都是以讓人閱讀的文字為基礎，可以被轉譯成程式語言使用，讓文件能夠很容易地讓人去閱讀，同時又很容易讓電腦程式去辨識的語言格式和語法，不過 XML 相較之下更難被解析(parse)，須使用專屬的解析器，而 JSON 不須使用 end tag，JSON is parse into a ready-to-use JS Object，讀寫更簡潔、快速，可以使用 arrays(objects)格式來儲存資料，雖然 JSON 是以 JavaScript 語法為基礎，但可獨立使用，且許多程式設計環境亦可讀取 (剖析) 並產生 JSON。所以現在多使用 JSON 格式來傳輸資料。</p>
<ul>
<li><p>XHR(XMLHttpRequest)：是一個 JavaScript 物件，他的功能是用來向 server 發送非同步請求，在 XHR 技術剛被開發出來時，<br>使用 XML 作為請求、回應的資料格式，因此被稱為 XMLHttpRequest。現今提到 XMLHttpRequest 時已經不限於使用 XML 資料格式，也可以傳遞 XML、JSON、String 等多種資料格式。</p>
</li>
<li><p>AJAX 進化史：</p>
<ul>
<li>XHR(XMLHttpRequest) 大約10幾年前</li>
<li>XHR(XMLHttpRequest) v2 大約10年前</li>
<li>jQuery + XHR</li>
<li>現在：Fetch API、Axios、Request、SuperAgent、Supertest等<ul>
<li>Fetch：由 Mozilla 和 Google browser 在 2015年3月發佈實作的消息，它有不同於XHR思考角度的設計，基於 promise 的語法結構，而且設計足夠低階所以有更多彈性可擴展設定。目前不同瀏覽器版本還有不完全支援的，所以需要安裝 polyfill 當作暫時的解決方案。</li>
<li>Axios：Promise-based HTTP library for performing HTTP requests on both Node.js and Browser. It supports all mordern browser, even an included support for IE 8+. It’s built on top of XMLHttpRequest for making AJAX calls. It lets you make HTTP requests from both the browser and the server. <ul>
<li>Intercept requests and responses before they are carried out.</li>
<li>Transform request and response data using promises.</li>
<li>Automatically transforms JSON data.</li>
<li>Cancel live requests.</li>
<li>可以對 response setTimeout</li>
<li>Support protection against CSRF.</li>
<li>Has support for upload progress.</li>
</ul>
</li>
<li>Request - A Simplified HTTP Client：The Request library is one of the simplest ways to make HTTP calls. The structure and syntax are very similar to that of how requests are handled in Node.js.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var request = require(&apos;request&apos;);</span><br><span class="line">request(&apos;http://www.google.com&apos;, function (error, response, body) &#123;</span><br><span class="line">  console.log(&apos;error:&apos;, error); // Print the error if one occurred</span><br><span class="line">  console.log(&apos;statusCode:&apos;, response &amp;&amp; response.statusCode); // Print the response status code if a response was received</span><br><span class="line">  console.log(&apos;body:&apos;, body); // Print the HTML for the Google homepage.</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>Making HTTP calls from the client-side wasn’t this easy a decade ago. A front-end developer would have to rely on XMLHttpRequest which was hard to use and implement. The modern libraries and HTTP clients make the front-end features like user interactions, animations, asynchronous file uploads, etc., easier. </p>
<h1 id="RESTful-API"><a href="#RESTful-API" class="headerlink" title="RESTful API"></a>RESTful API</h1><ul>
<li><p>API (Application Programming Interface) 應用程式介面<br>串接 API 指的就是在開發時透過程式介面操作資料；一個應用程式通常會開發其程式介面提供串接、讀取資料或應用服務，提供一套標準讓任何想接入應用程式服務的開發者，可以遵循規範、根據介面的設計撰寫程式碼，來得到想要的服務或資料。串接 API 的本質就是交換資料，通常我們會根據文件說明來使用他人寫好的 API，若要主動提供 API 時則需定義要給什麼資料。</p>
</li>
<li><p>Web API 或 HTTP API<br>透過 HTTP 協定的 API，也就是用 HTTP 格式來提供資料的 API 可以稱為 Web API/HTTP API。根據 HTTP 規範，伺服器端和客戶端進行請求和回應時，會使用定義明確的請求格式(request format)和回應格式(response format)，request format 指的是 client-side 需使用特定的 HTTP verb 對 url 發出請求，response format 則是指 server-side 回應時採用的資料格式，有可能是 XML、JSON等。</p>
</li>
</ul>
<p>HTTP 的組成元素：</p>
<table>
<thead>
<tr>
<th>HTTP request</th>
<th>HTTP response</th>
</tr>
</thead>
<tbody><tr>
<td>HTTP Method</td>
<td>Response Status</td>
</tr>
<tr>
<td>HTTP Headers</td>
<td>Response Headers</td>
</tr>
<tr>
<td>Request Body</td>
<td>Response Body</td>
</tr>
</tbody></table>
<p>HTTP URL 組成：例如<code>https://www.example.com/photos?page=1</code><br>通訊協定 <code>https://</code>、網域名稱 DNS <code>www.example.com</code>、路徑 path <code>/photos</code>、參數 parameter<code>?page=1</code>(又稱 query string)</p>
<ul>
<li><p>RESTful API<br>RESTful 風格也是一種格式(format)，<strong>RESTful API 就是指一種寫 API 格式的風格建議，目的是讓大家的寫法更有一致性。</strong></p>
<ul>
<li>REST<br>REST 是 Representational State Transfer 的縮寫，由 Roy Fielding 博士在 2000 年的博士論文中所提出。他同時也是 HTTP 規範的主要作者之一。REST 是一種軟體架構風格（並非標準），目的是幫助在世界各地不同軟體、程式在網際網路中能夠互相傳遞訊息。而每一個網頁都可視為一個資源（resource）提供使用者使用，以資源操作的概念(指的是對某項資源，譬如 User、Post 等，指派 Show、Edit 等動作)，結合 URL path 與 HTTP Method ，目的是使 URL path 更為簡潔、容易被理解，除了介面簡潔之外，尚有增加快取 cache 效率、提升 api 活用性等優點。換句話說， REST 風格可以單從 HTTP request 就能看出如何操作伺服器的資料。</li>
</ul>
<p>REST 的一個最重要的觀念就是 resources (特定資訊的資源)，每一個 resource 由一個 global identifier (即 URL)所表示。為了操作這些 resources，網路的 components (client 跟 server) 透過標準化的介面 (HTTP) 來溝通並交換這些 resources 的 representations (實際上傳達資訊的文件)。<br>任意數量的 connectors (如 clients, servers, caches, tunnels 等) 可以居中 request，但是都不可以 “seeing past” (不需要其他layer層)。這樣的應用程式跟一個 resource 互動根據兩件事情: resource 的 URL 跟要做的動作 — 它不需要知道是否有 caches, proxies, gateways, firewalls, tunnels, 或其他任何藏在 sever 之間的東西。這個應用程式只需要知道資訊的格式 (representation)，通常是 HTML 或 XML 或圖片什麼的。</p>
<ul>
<li>RESTful<br>設計為 REST 的系統稱為 RESTful。RESTful 路由便是充分應用 REST 風格的路由設置。而你可以透過 HTTP URL(Uniform Resource Locator)，也就是這些資源的地址(俗稱網址)，來取得這些資源並在你的瀏覽器上使用。<br>RESTful API 建議我們使用 Standard HTTP Verb 來撰寫 API，並根據 API 接口的提供目的規劃 URL，例如 /resouces、/resouces/:id 來代表 resource collection 以及 individual resource 的 path 來規劃 API 介面。<br>路由(routing)是指定義 app 如何將 client requset 指向一個正確的接口(endpoint)並做出相應的後續處理(給予 response)，一個 route 通常由下組成：<br><code>app.METHOD(PATH, HANDLER)</code><br>METHOD means HTTP request method, PATH is a path on the server and the HANDLER is the function executed when the routes is matched. PATH 是開放給 client 的 route，透過不同 path 導向不同動作。<br>舉例：一個簡單的 route based on express.js：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">app.get(&apos;/&apos;, function(req, res)&#123;</span><br><span class="line">  res.send(&apos;hello world&apos;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><code>&#39;/&#39;</code>表示根目錄(root route)</p>
</li>
</ul>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="https://dzone.com/articles/top-javascript-libraries-for-making-ajax-calls" target="_blank" rel="noopener">Top JavaScript Libraries for Making AJAX Calls</a><br><a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API" target="_blank" rel="noopener">Fetch API</a><br><a href="https://www.awoo.com.tw/blog/https-seo/" target="_blank" rel="noopener">HTTPS的威力？「S」對SEO與網站經營的四大重要性</a><br><a href="https://www.websecurity.digicert.com/zh/hk/security-topics/what-is-ssl-tls-https" target="_blank" rel="noopener">SSL 憑證</a><br><a href="https://progressbar.tw/posts/98" target="_blank" rel="noopener">為何HTTPS憑證有貴有便宜還更可以免費？讓我們從CA原理開始講起。</a></p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="https://chinyun.github.io/myblog/myblog/2019/11/02/CORS/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="chinyun">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/myblog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jinny's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/myblog/2019/11/02/CORS/" class="post-title-link" itemprop="url">CORS</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-11-02 21:00:05" itemprop="dateCreated datePublished" datetime="2019-11-02T21:00:05+00:00">2019-11-02</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-11-07 14:21:10" itemprop="dateModified" datetime="2019-11-07T14:21:10+00:00">2019-11-07</time>
              </span>
            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="什麼是-CORS"><a href="#什麼是-CORS" class="headerlink" title="什麼是 CORS?"></a>什麼是 CORS?</h1><p>Cross-Origin Resource Sharing 跨來源資源共享，這是由 W3C 頒布的一種瀏覽器技術規範，透過傳輸 HTTP Header 判斷阻擋或允許不同來源網域的資源存取。</p>
<p>當使用者請求一個不是目前文件來源，例如不同網域(domain/host)、通訊協定(protocol)或通訊埠(port)的資源時，會建立一個<strong>跨來源 HTTP 請求</strong>(cross-origin http request)。</p>
<p>而瀏覽器基於安全性考量，程式碼所發出的跨來源 HTTP 請求會受到限制，若不受限制的話，駭客可以透過撰寫程式碼跨域撈資料來進行跨站腳本攻擊(XSS)，而這個限制只有在瀏覽器上，若在本機使用 node.js 則沒有限制。</p>
<h2 id="同源政策（same-origin-policy）"><a href="#同源政策（same-origin-policy）" class="headerlink" title="同源政策（same-origin policy）"></a>同源政策（same-origin policy）</h2><p>在同源政策（same-origin policy）中規範了那寫資源可以跨源存取，哪些會受到限制。<br>同源的定義簡單如下：</p>
<ul>
<li>不同網域（Domain）</li>
<li>不同通訊協定：HTTP, HTTPS, FTP</li>
<li>不同連接埠號（Port）</li>
</ul>
<p>只要瀏覽器發的 request 與 server 所屬不同源，request 就會被瀏覽器阻擋。不過即便擋下來，其實 request 已經發出去，server 也確實給予瀏覽器 response，只是瀏覽器基於同源政策，因此不把拿到的回應給你的 JavaScript 去做進一步的處理。</p>
<p>一般來說跨來源寫（Cross-origin writes）、跨來源嵌入（Cross-origin embedding）是被允許的，而跨來源讀取（Cross-origin reads）是受限制的。</p>
<ol>
<li>受同源政策管理的跨來源請求：<br>XMLHttpRequest 及 Fetch 都遵守同源政策(same-origin policy)，<strong>這代表網路應用程式所使用的 API 除非使用 CORS 標頭否則只能請求與應用程式相同網域的 HTTP 資源</strong>。<br>如果想開啟跨來源 HTTP 請求的話， server 必須在 response 的 header 加上 <code>Access-Control-Allow-Origin: *</code>表示接受所有不同來源的跨域請求，或者可以指定接受特定網址的跨域請求：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Origin: http://foo.example</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>其他方法還有：</p>
<ul>
<li>Access-Control-Allow-Headers：指定哪些 HTTP 標頭可以於實際請求中使用。</li>
<li>Access-Control-Allow-Methods：GET, POST, PUT，存取資源所允許的方法，用來回應預檢請求。</li>
<li>Access-Control-Expose-Headers：瀏覽器能夠存取伺服器回應當中哪些標頭。</li>
<li>Access-Control-Max-Age：預檢請求之結果可以被快取的秒數。</li>
<li>Access-Control-Allow-Credentials：用於驗證請求中，用來告知瀏覽器是否允許 client-side 向 server-side 傳送 cookie，默認為 false：CORS 規範會阻止跨域 AJAX 向 server-side 發送 cookie。</li>
</ul>
<ol start="2">
<li>不受同源政策管理的 html tags 包括：<code>&lt;script src=&#39;&#39; /&gt;</code>、<code>&lt;img/&gt;</code>、<code>&lt;video/&gt;</code>、<code>&lt;audio/&gt;</code>、<code>&lt;iframe/&gt;</code>、<code>&lt;link rel=&#39;stylesheet&#39; href /&gt;</code> 這些資源本來就能夠跨域存取。</li>
</ol>
<h2 id="JSON-with-Padding-JSONP"><a href="#JSON-with-Padding-JSONP" class="headerlink" title="JSON with Padding(JSONP)"></a>JSON with Padding(JSONP)</h2><p>JSONP 是一個利用 script tag 不受同源政策限制的特性，直接載入帶參數的 js 程式碼的跨來源請求實作方法，實務上在操作 JSONP 的時候，Server 通常會提供一個callback的參數讓 client 端帶過去。</p>
<p>Twitch API 有提供 JSONP 的版本，我們可以直接來看範例：</p>
<p>URL: <a href="https://api.twitch.tv/kraken/games/top?client_id=xxx&amp;callback=receiveData&amp;limit=1" target="_blank" rel="noopener">https://api.twitch.tv/kraken/games/top?client_id=xxx&amp;callback=receiveData&amp;limit=1</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">receiveData(&#123;&quot;_total&quot;:1067,&quot;_links&quot;:&#123;&quot;self&quot;:&quot;https://api.twitch.tv/kraken/games/top?limit=1&quot;,&quot;next&quot;:&quot;https://api.twitch.tv/kraken/games/top?limit=1\u0026offset=1&quot;&#125;,&quot;top&quot;:[&#123;&quot;game&quot;:&#123;&quot;name&quot;:&quot;Dota 2&quot;,&quot;popularity&quot;:63361,&quot;_id&quot;:29595,&quot;giantbomb_id&quot;:32887,&quot;box&quot;:&#123;&quot;large&quot;:&quot;https://static-cdn.jtvnw.net/ttv-boxart/Dota%202-272x380.jpg&quot;,&quot;medium&quot;:&quot;https://static-cdn.jtvnw.net/ttv-boxart/Dota%202-136x190.jpg&quot;,&quot;small&quot;:&quot;https://static-cdn.jtvnw.net/ttv-boxart/Dota%202-52x72.jpg&quot;,&quot;template&quot;:&quot;https://static-cdn.jtvnw.net/ttv-boxart/Dota%202-&#123;width&#125;x&#123;height&#125;.jpg&quot;&#125;,&quot;logo&quot;:&#123;&quot;large&quot;:&quot;https://static-cdn.jtvnw.net/ttv-logoart/Dota%202-240x144.jpg&quot;,&quot;medium&quot;:&quot;https://static-cdn.jtvnw.net/ttv-logoart/Dota%202-120x72.jpg&quot;,&quot;small&quot;:&quot;https://static-cdn.jtvnw.net/ttv-logoart/Dota%202-60x36.jpg&quot;,&quot;template&quot;:&quot;https://static-cdn.jtvnw.net/ttv-logoart/Dota%202-&#123;width&#125;x&#123;height&#125;.jpg&quot;&#125;,&quot;_links&quot;:&#123;&#125;,&quot;localized_name&quot;:&quot;Dota 2&quot;,&quot;locale&quot;:&quot;zh-tw&quot;&#125;,&quot;viewers&quot;:65622,&quot;channels&quot;:376&#125;]&#125;)</span><br></pre></td></tr></table></figure>

<p>結合起來就是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;https://api.twitch.tv/kraken/games/top?client_id=xxx&amp;callback=receiveData&amp;limit=1&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  function receiveData (response) &#123;</span><br><span class="line">    console.log(response);</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>利用 JSONP 也可以存取跨來源的資料。但 JSONP 的缺點就是你要帶的那些參數永遠都只能用附加在網址上的方式（GET）帶過去，沒辦法用 POST。</p>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="https://blog.techbridge.cc/2017/05/20/api-ajax-cors-and-jsonp/" target="_blank" rel="noopener">輕鬆理解 Ajax 與跨來源請求</a><br><a href="https://pjchender.github.io/2018/08/20/%E5%90%8C%E6%BA%90%E6%94%BF%E7%AD%96%E8%88%87%E8%B7%A8%E4%BE%86%E6%BA%90%E8%B3%87%E6%BA%90%E5%85%B1%E7%94%A8%EF%BC%88cors%EF%BC%89/" target="_blank" rel="noopener">[JS] 同源政策與跨來源資源共用（CORS）</a></p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="https://chinyun.github.io/myblog/myblog/2019/11/02/CSRF-XSS-SQL-injection/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="chinyun">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/myblog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jinny's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/myblog/2019/11/02/CSRF-XSS-SQL-injection/" class="post-title-link" itemprop="url">CSRF, XSS, SQL injection</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-11-02 20:32:24" itemprop="dateCreated datePublished" datetime="2019-11-02T20:32:24+00:00">2019-11-02</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-11-07 14:21:10" itemprop="dateModified" datetime="2019-11-07T14:21:10+00:00">2019-11-07</time>
              </span>
            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Web Security 網頁安全泛指針對網頁、網站上的資訊安全，涵蓋程式漏洞、邏輯漏洞、資訊洩漏等。</p>
<p>#Cross Site Request Forgery(XSRF or CSRF)</p>
<p>指在受害者不知情狀況下，被其他網域借用身份來完成未經同意的 HTTP Request。<br>當網站使用 cookie-based authentication，會把 session id 和 session data 存在 cookie 中，剛使用者曾在其他網站登入而未登出，並且進入惡意網站操作時，攻擊者利用可以進行跨域 http 請求的 http tag(ex: img、iframe等)埋入惡意的 request 程式碼，觸發後因為使用者未登出，因此攻擊者獲得 cookie 資料，攻擊者得以冒用使用者身份通過驗證。得以任意改變使者者在資料庫的資料。</p>
<p>同源政策對於連結(links)、重新導向(redirect)、表單(form)等的跨來源存取都是寬鬆的，因此駭客利用此特性做 CSRF 攻擊。</p>
<p>如何防範：</p>
<ol>
<li>使用 token-based authentication</li>
<li>使用 HttpOnly 來防止 Cookie 被 JavaScript 讀取</li>
<li>目前各大成熟的框架，都有針對傳遞資料做 CSRF 驗證，網站會產生的一組密碼，並在請求送出時，檢查那組密碼是否正確。</li>
</ol>
<p>Cross Site Request Forgery attacks are not an issue if you are using JWT with local storage. On the other hand, if your use case requires you to store the JWT in a cookie, you will need to protect against XSRF. XSRF are not as easily understood as XSS attacks. Explaining how XSRF attacks work can be time-consuming, so instead, check out this really good guide that explains in-depth how XSRF attacks work. Luckily, preventing XSRF attacks is a fairly simple matter. To over-simplify, protecting against an XSRF attack, your server, upon establishing a session with a client will generate a unique token (note this is not a JWT). Then, anytime data is submitted to your server, a hidden input field will contain this token and the server will check to make sure the tokens match. Again, as our recommendation is to store the JWT in <strong>local storage</strong>, you probably will not have to worry about XSRF attacks.</p>
<p>One of the best ways to protect your users and servers is to have a <strong>short expiration time</strong> for tokens. That way, even if a token is compromised, it will quickly become useless. Additionally, you may maintain a blacklist of compromised tokens and not allow those tokens access to the system. Finally, the nuclear approach would be to change the signing algorithm, which would invalidate all active tokens and require all of your users to log in again. This approach is not easily recommended, but is available in the event of a severe breach.</p>
<h1 id="Cross-Site-Scripting-XSS"><a href="#Cross-Site-Scripting-XSS" class="headerlink" title="Cross Site Scripting(XSS)"></a>Cross Site Scripting(XSS)</h1><p>「XSS攻擊通常指的是通過利用網頁開發時留下的漏洞，通過巧妙的方法注入惡意指令程式碼到網頁，使用戶載入並執行攻擊者惡意製造的網頁程式。 這些惡意網頁程式通常是JavaScript，但實際上也可以包括Java，VBScript，ActiveX，Flash或者甚至是普通的HTML。」–wikipedia</p>
<p>使用者以為安全進入網站後反而被導向到釣魚網站、甚至被竊取帳號密碼、個人資料。<br>目前 XSS 攻擊的種類大致可以分成以下幾種類型：</p>
<ul>
<li><p>Stored XSS (儲存型)：<br>會被保存在伺服器資料庫中的 JavaScript 代碼引起的攻擊即為 Stored XSS，最常見的就是論壇文章、留言板等等，因為使用者可以輸入任意內容，若沒有確實檢查，那使用者輸入如 ｀<code>&lt;script&gt;</code> 等關鍵字就會被當成正常的 HTML 執行，標籤的內容也會被正常的作為 JavaScript 代碼執行。</p>
</li>
<li><p>Reflected XSS (反射型)：<br>由網頁後端直接嵌入由前端使用者所傳送過來的內容造成的，最常見的就是以 GET 方法傳送資料給伺服器時，伺服器未檢查就將內容回應到網頁上所產生的漏洞。</p>
</li>
<li><p>DOM-Based XSS (基於 DOM 的類型):<br>網頁上的 JavaScript 在執行過程中，沒有詳細檢查，輸入任意的內容都會被建立成有效的 DOM 物件，包含嵌入的代碼也會被執行，使得操作 DOM 的過程代入了惡意指令。但這樣的攻擊除非攻擊者親自到受害者電腦前輸入，否則不可能讓受害者輸入這種惡意代碼，通常需要搭配前兩個手法；讓內容保存在伺服器資料庫中、或是以反射型的方式製造出內容，再藉由JavaScript 動態產生有效的 DOM 物件來運行惡意代碼。</p>
</li>
</ul>
<p>如何防範：</p>
<ol>
<li><p>前兩種 Stored、Reflected 的類型都必須由後端進行防範，除了必要的 HTML 代碼，任何允許使用者輸入的內容都需要檢查，刪除所有「<code>&lt;script&gt;</code>」、「 <code>onerror=</code>」及其他任何可能執行代碼的字串。</p>
</li>
<li><p>DOM-Based 則必須由前端來防範，但基本上還是跟前面的原則相同。<br>另外不同的一點就是應該選擇正確的方法、屬性來操作 DOM，譬如<code>document.getElementById(&#39;show_name&#39;).innerHTML = name;</code> 中的<code>innerHTML</code>屬性代表插入的內容是合法的 HTML 字串，所以字串會解析成 DOM 物件，此處使用<code>innerText</code>會被保證作為純粹的文字，也就不可能被插入惡意代碼執行了。</p>
</li>
</ol>
<p>Cross Site Scripting attacks occur when an outside entity is able to execute code within your website or app. The most common attack vector here is if your website allows <strong>inputs</strong> that are not properly sanitized. <strong>If an attacker can execute code on your domain, your JWT tokens are vulnerable.</strong> Our CTO has argued in the past that XSS attacks are much easier to deal with compared to XSRF attacks because they are generally better understood. <strong>Many frameworks, including Angular, automatically sanitize inputs and prevent arbitrary code execution.</strong> If you are not using a framework that sanitizes input/output out-of-the-box, you can look at plugins like caja developed by Google to assist. Sanitizing inputs is a solved issue in many frameworks and languages and I would recommend using a framework or plugin vs building your own.</p>
<h1 id="SQL-injection"><a href="#SQL-injection" class="headerlink" title="SQL injection"></a>SQL injection</h1><p>「Injection 是一種駭客常用的攻擊概念，透過注入惡意的程式碼的方式，破壞原本程式碼的語意，來達到攻擊的效果。SQL 是網站常用來取得資料的程式語法，SQL Injection 便是駭客透過修改 SQL 語句，改變他的語意，達成竊取資料/破壞資料的行為。」<br>–<a href="https://medium.com/@jaydenlin/淺談駭客攻擊-網站安全-一次看懂-sql-injection-的攻擊原理-b1994fd2392a" target="_blank" rel="noopener">一次看懂 SQL Injection 的攻擊原理</a></p>
<p>「在輸入的字串之中夾帶SQL指令，在設計不良的程式當中忽略了字元檢查，那麼這些夾帶進去的惡意指令就會被資料庫伺服器誤認為是正常的SQL指令而執行，因此遭到破壞或是入侵。」<br>–wikipedia</p>
<p>「在 SQL 語法中常會出現攻擊者可以透過更改語法邏輯或加入特殊指令的方式，在未設定過濾惡意程式碼的情況下，資料庫伺服器（DataBase）會直接接收使用者所輸入的 SQL 指令並執行攻擊代碼，使攻擊者能夠取得最高權限，得以擅自竊取、修改、挪動或刪除資料的可能。此類漏洞無疑的會對公司或商號造成相當大的損傷。」<br>–<a href="https://ithelp.ithome.com.tw/articles/10189201" target="_blank" rel="noopener">攻擊行為－SQL 資料隱碼攻擊 SQL injection</a></p>
<p>常見攻擊手法：</p>
<ul>
<li>Authorization Bypass（略過權限檢查）</li>
<li>Injecting SQL Sub-Statements into SQL Queries（注入 SQL 子語法）</li>
<li>Exploiting Stored Procedures（利用預存程序）</li>
</ul>
<p>防範手法：</p>
<ul>
<li>使用 SQL query builder for JavaScript - knex.js：</li>
</ul>
<p>Read carefully from knex documentation how to pass values to knex raw (<a href="http://knexjs.org/#Raw" target="_blank" rel="noopener">http://knexjs.org/#Raw</a>).</p>
<p>If you are passing values as parameter binding to raw like:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">knex.raw(&apos;select * from foo where id = ?&apos;, [1])</span><br></pre></td></tr></table></figure>

<p>In that case parameters and query string are passed separately to database driver protecting query from SQL injection.</p>
<p>Other query builder methods always uses binding format internally so they are safe too.</p>
<p>Biggest mistake that one can do with knex raw queries is to use javascript template string and interpolate variables directly to SQL string format like:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">knex.raw(`select * from foo where id = $&#123;id&#125;`) // NEVER DO THIS</span><br></pre></td></tr></table></figure>

<p>One thing to note is that knex table/identifier names cannot be passed as bindings to driver, so with those one should be extra careful to not read table / column names from user and use them without properly validating them first.</p>
<p>Refer from:<a href="https://stackoverflow.com/questions/49665023/does-knex-js-prevent-sql-injection/49665379" target="_blank" rel="noopener">Does Knex.js prevent sql injection?</a></p>
<ul>
<li><p>使用 ORM(object relational mapping)：<br>在資料庫和 model資料容器之間的框架，他可以幫助開發者更簡便安全的去資料庫讀取資料，透過 ruby, java 等程式語言，去操作資料庫語言。同時因為是操作程式語言，若 query 中的值不符合預期格式，框架會自動擋掉而不會讓 SQL injection 成功。目前大部分的網站都是使用框架來開發，而這些框架都是使用 ORM 來處理他們的資料庫，因此在 ORM 的保護下，不是我們預期的資料格式，而是 SQL 語法的話，具有基本的保護能力。</p>
</li>
<li><p>參數化查詢（parameterized query 或 parameterized statement）：<br>是指在設計與資料庫連結並存取資料時，在需要填入數值或資料的地方，使用參數（parameter）來給值，這個方法目前已被視為最有效可預防SQL注入攻擊的攻擊手法的防禦方式。 – <a href="https://www.wikiwand.com/zh-tw/%E5%8F%83%E6%95%B8%E5%8C%96%E6%9F%A5%E8%A9%A2" target="_blank" rel="noopener">參數化查詢</a></p>
</li>
<li><p>使用 Regular expression 驗證過濾輸入值與參數中惡意代碼，將輸入值中的單引號置換為雙引號。</p>
</li>
<li><p>限制輸入字元格式並檢查輸入長度。</p>
</li>
<li><p>資料庫設定使用者帳號權限，限制某些管道使用者無法作資料庫存取。</p>
</li>
</ul>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="https://www.gnucitizen.org/blog/csrf-demystified/" target="_blank" rel="noopener">CSRF</a><br><a href="https://forum.gamer.com.tw/Co.php?bsn=60292&sn=11267" target="_blank" rel="noopener">網頁安全】給網頁開發新人的 XSS 攻擊 介紹與防範</a><br><a href="https://ithelp.ithome.com.tw/articles/10209227" target="_blank" rel="noopener">資安常見攻擊( Web ) 與學習方法</a></p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="https://chinyun.github.io/myblog/myblog/2019/11/01/Cookie-Session-Web-Storage-Token/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="chinyun">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/myblog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jinny's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/myblog/2019/11/01/Cookie-Session-Web-Storage-Token/" class="post-title-link" itemprop="url">Cookie, Session, Web Storage, Token</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-11-01 22:24:34" itemprop="dateCreated datePublished" datetime="2019-11-01T22:24:34+00:00">2019-11-01</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-11-07 14:21:10" itemprop="dateModified" datetime="2019-11-07T14:21:10+00:00">2019-11-07</time>
              </span>
            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>根據 google 開發者指南，選擇正確的網頁存儲機制對本地設備和基於雲端的服務器存儲都很重要，良好的存儲引擎可以確保以可靠的方式保存信息，同時減少佔用的網路頻寬並提升響應能力，正確的存儲緩存策略是實現離線移動網頁體驗的核心構建基礎。<br>–<a href="https://developers.google.com/web/fundamentals/instant-and-offline/web-storage" target="_blank" rel="noopener">Never Load the Same Resource Twice - 網頁存儲概覽</a></p>
<h1 id="Session-是什麼？"><a href="#Session-是什麼？" class="headerlink" title="Session 是什麼？"></a>Session 是什麼？</h1><p>session 可以被翻譯作「一系列動作、具有上下文意義的狀態」或被簡單的翻作「會話」、「工作階段」。<br>由於 http 協定是無狀態(stateless)的設計，server 和 client 不會一直保持連線狀態，也不會有雙方狀態的即時更新，每一次的請求和回應的都是獨立的，沒辦法記憶內容，而 session 就是讓 client 和 server 之間保持狀態的解決方案。<br>session 可以說是一種機制，可以讓伺服器記住訪問者的身份，避免短時間內重複載入，不同程式語言對於 session 機制有不同的實現方法。</p>
<h1 id="Session-機制的實作"><a href="#Session-機制的實作" class="headerlink" title="Session 機制的實作"></a>Session 機制的實作</h1><h3 id="網址"><a href="#網址" class="headerlink" title="網址"></a>網址</h3><p>將 request 內容附加在網址上，server 透過網址資訊判斷 client 狀態。 </p>
<h3 id="Cookies"><a href="#Cookies" class="headerlink" title="Cookies"></a>Cookies</h3><p>cookie 是最常見的方式，可以把資訊記錄在本機端的文檔中，網站只能儲存使用者確實輸入過的內容而無法存取電腦內的資料。<br>cookie 的機制就是當 clinet 發送 request 時，server 收到 request 後透過 Set-Cookie 語法讓瀏覽器儲存一些內容(設置 cookie)，而這些內容會在瀏覽器發送 request 時一併送達 server，server 透過 cookie 內容決定狀態。</p>
<ul>
<li>cookie-based session: 把所有 session 狀態存在 cookie 裡面並且加密</li>
<li>在 cookie 只儲存 session id，其餘狀態(session data)都存在 server，透過 session id 來向 server 請求訪問資料。<blockquote>
<p>但 cookie 的問題是認證不認人，一旦 cookie、session id 被偷走，別人就可以偽造身份來登入，這也就是為什麼有時候如果駭客取得一大串 session id 的時候，有用戶會發現帳戶被系統自動登出，讓該 session id 失效。<br>由於 session 代表意義廣泛、多處有使用到此詞，因此有時候口語中講到 session 也會直接指存在 cookie 中的 session id 和 session data。</p>
</blockquote>
</li>
<li>要注意 HttpOnly 與 Secure 的設定值</li>
</ul>
<p>cookie-based authentication 流程：</p>
<ol>
<li>User enters their login credentials.</li>
<li>Server verifies the credentials are correct and creates a session which is then stored in a database.</li>
<li>A cookie with the session ID is placed in the users browser.</li>
<li>On subsequent requests, the session ID is verified against the database and if valid the request processed.</li>
<li>Once a user logs out of the app, the session is destroyed both client-side and server-side.</li>
</ol>
<h3 id="Token"><a href="#Token" class="headerlink" title="Token"></a>Token</h3><p>Token-based authentication 是無狀態的，server 不會保留有關哪些用戶已登入或已發出哪些 token 的紀錄，取而代之的是，對 server 的每個請求都帶有一個 token，server 使用該 token 來驗證請求的真實性。<br>The token is generally sent as an addition Authorization header in the form of Bearer {JWT}, but can additionally be sent in the body of a POST request or even as a query parameter. </p>
<p>一般 token 的流程如下：</p>
<ol>
<li>User enters their login credentials.</li>
<li>Server verifies the credentials are correct and returns a signed token.</li>
<li>This token is stored client-side, most commonly in local storage - but can be stored in session storage or a cookie as well.</li>
<li>Subsequent requests to the server include this token as an additional Authorization header or through one of the other methods mentioned above.</li>
<li>The server decodes the JWT and if the token is valid processes the request.</li>
<li>Once a user logs out, the token is destroyed client-side, no interaction with the server is necessary.</li>
</ol>
<p>Token 優於傳統 cookie-based 方法的原因為：</p>
<ul>
<li>Stateless, Scalable, and Decoupled，<br>使用 token-based appoarch，後端不需要保存 token 的紀錄，每個 token 包含驗證所需的資訊，server的工作只要給予成功登入的請求 signed token，並且驗證後續的 token 是否一致。 Third party services such as <strong>Auth0</strong> can handle the issuing of tokens and then the server only needs to verify the validity of the token.</li>
<li>Cross Domain and CORS，不同於 cookies 只能在單網域或子網域中運作，token-based approach with CORS enabled 所以可以被不同 services 和 domains 訪問。</li>
</ul>
<h3 id="JWT-JSON-Web-Token"><a href="#JWT-JSON-Web-Token" class="headerlink" title="JWT (JSON Web Token)"></a>JWT (JSON Web Token)</h3><p>A JSON Web Token is comprised of three parts: the header, payload, and signature.<br>Header:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &apos;typ&apos;: &apos;JWT&apos;, # 聲明類型</span><br><span class="line">  &apos;alg&apos;: &apos;HS256&apos; # 加密的方法: HMAC、SHA256、RSA 進行 Base64 編碼</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Payload: 用來放用來放必要的資料(通常是用來認證使用者的資料)或額外的資料(metadata)，存放溝通訊息。<br>Signature: 由三個部分組成，加密後的 header、加密後的 payload以及 secret，secret 要保存在 server 端，JWT 的簽發驗證都必須使用這個 secret，當其他人得知這個 secret 就表示 client-side 可以自己簽發 JWT，因此任何場景都不應該外流。</p>
<p>Tokens Are Signed, Not Encrypted. Token could be signed by the HMACSHA256 algorithm, and the header and payload are Base64URL encoded, it is not encrypted. Base64URL can be decoded.<br>It should go without saying that sensitive data, such as passwords, should never be stored in the payload. If you must store sensitive data in the payload or your use case calls for the JWT to be obscured, you can use JSON Web Encryption (JWE). JWE allows you to encrypt the contents of a JWT so that it is not readable by anyone but the server.</p>
<p>Commonly, the JWT is placed in the browser’s local storage and this works well for most use cases.There are some issues with storing JWTs in local storage to be aware of. Unlike cookies, local storage is sandboxed to a specific domain and its data cannot be accessed by any other domain including sub-domains.</p>
<p>You can store the token in a cookie instead, but the max size of a cookie is only 4kb so that may be problematic if you have many claims attached to the token. Additionally, you can store the token in <strong>session storage</strong> which is similar to local storage but is cleared as soon as the user closes the browser.</p>
<h3 id="Web-Storage"><a href="#Web-Storage" class="headerlink" title="Web Storage"></a>Web Storage</h3><p>HTML5 提供的 web storage 方法分成兩種： session storage 和 local storage。<br>這是一種可以讓網頁儲存資料於本地端的技術，作用與 cookie 相同，但與只有 4k 容量的 cookie 不同，基本上一般瀏覽器支援 5M 的儲存空間。而且 cookie 會在伺服器和用戶端之間旅行，而 web storage 則是儲存於用戶端，不會佔用網路頻寬、不影響網站效能，因此可以把安全性低而量較大的資料以 web storage 形式儲存。</p>
<p>web storage 儲存形式為 string，存取的程式指令寫在用戶端的 JavaScript 中，資料結構為 key/value pair。</p>
<ul>
<li>local storage: 永久性儲存在瀏覽器中，關閉瀏覽器也不會消失，除非手動刪除。</li>
<li>session storage: 只存在單一分頁，開新分頁即是新的 session，資料無法跨分頁分享。</li>
</ul>
<p>隔離：瀏覽器會把不同網站的 local storage 隔離開來，基於「同源政策」避免不同網域的訪問者進行惡意攻擊，某個網站的網頁所儲存於 local storage 的資料，其他網站是看不到的，只有來自相同網站的網頁才能共享資料。</p>
<ul>
<li>不同協定視為不同源： HTTP 和 HTTPS 不同源</li>
<li>主機名稱： 相同 host name 底下的虛擬路徑屬於相同來源，不同主機名稱視為不同源</li>
</ul>
<h1 id="Session-安全設計原則"><a href="#Session-安全設計原則" class="headerlink" title="Session 安全設計原則"></a>Session 安全設計原則</h1><ul>
<li>需有一定期限的生命週期（expire機制）</li>
<li>盡量利用原有架構 session 管理的機制</li>
<li>登入成功後的 sessoin id 必須強制更換</li>
</ul>
<h1 id="Notes"><a href="#Notes" class="headerlink" title="Notes"></a>Notes</h1><ul>
<li><p><a href="https://github.com/aszx87410/blog/issues/46" target="_blank" rel="noopener">深入 Session 與 Cookie：Express、PHP 與 Rails 的實作</a><br>sessionID 如何產生、sessionID 儲存方式、session 資訊儲存方式</p>
</li>
<li><p><a href="https://ithelp.ithome.com.tw/articles/10187343" target="_blank" rel="noopener">Day24 - Cookie在express上的應用—登入實作為例。</a></p>
</li>
</ul>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul>
<li><a href="https://github.com/aszx87410/blog/issues/45" target="_blank" rel="noopener">淺談 Session 與 Cookie：一起來讀 RFC</a></li>
<li><a href="https://cythilya.github.io/2015/08/18/node-cookie-and-session/" target="_blank" rel="noopener">Node.js: Cookie and Session</a></li>
<li><a href="https://github.com/aszx87410/blog/issues/17" target="_blank" rel="noopener">我遇過最難的 cookie 問題</a></li>
<li><a href="https://dzone.com/articles/cookies-vs-tokens-the-definitive-guide" target="_blank" rel="noopener">Cookies vs. Tokens: The Definitive Guide</a></li>
</ul>
<h1 id="延伸閱讀"><a href="#延伸閱讀" class="headerlink" title="延伸閱讀"></a>延伸閱讀</h1><ul>
<li><a href>HTTPS/HTTP/JSON/AJAX</a></li>
<li><a href>CSRF, XSS, SQL injection</a></li>
<li><a href>CORS 同源政策</a></li>
<li><a href>Hash function &amp; Encryption</a></li>
<li><a href>Cache &amp; HTTP Cache</a></li>
</ul>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="https://chinyun.github.io/myblog/myblog/2019/10/31/git-push-fatal-please-verify-email-address/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="chinyun">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/myblog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jinny's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/myblog/2019/10/31/git-push-fatal-please-verify-email-address/" class="post-title-link" itemprop="url">git push fatal-please verify email address</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-10-31 16:48:41" itemprop="dateCreated datePublished" datetime="2019-10-31T16:48:41+00:00">2019-10-31</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-11-07 14:21:10" itemprop="dateModified" datetime="2019-11-07T14:21:10+00:00">2019-11-07</time>
              </span>
            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Git 向遠端儲存庫傳輸資料有兩種方式：SSH 金鑰 或 HTTPS 通訊協定。</p>
<h1 id="問題"><a href="#問題" class="headerlink" title="問題"></a>問題</h1><p>這次發生 git push 失敗時，是打算透過 HTTPS 遠端傳輸檔案，將完成的檔案 git commit 到已經創建好的 Github Repository，但 iTerm 顯示下面資訊：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">remote: You must verify your email address.</span><br><span class="line">remote: See https://github.com/settings/emails. </span><br><span class="line">fatal: unable to access ‘https://github.com/username/repo.git/’: The requested URL returned error: 403</span><br></pre></td></tr></table></figure>

<blockquote>
<p>P.S. 這裡 username 代表自己的使用者名稱；repo 代表 repository名稱。</p>
</blockquote>
<p>參考 <a href="https://help.github.com/en/github/getting-started-with-github/verifying-your-email-address" target="_blank" rel="noopener">Github 官方</a>的說明 ，先前使用 Github 時已 verify 過 email 無法重寄認證信，而且確認設定的遠端地址正確。</p>
<h1 id="原因：Git-credential-storage"><a href="#原因：Git-credential-storage" class="headerlink" title="原因：Git credential storage"></a>原因：Git credential storage</h1><p>之前使用的 Github 帳戶因為 email 刪除已經不存在，<br>即便已經重設過帳密，但是因為這台電腦儲存了我之前的帳戶的帳密，每次要 git push 的時候就會因為和遠地帳戶帳密不符而失敗。</p>
<p>類似的問題像是更改 username 或 密碼等也會遇到相同錯誤。<br>在 Stackoverflow 也有查詢到解法：改用 SSH 金鑰傳輸就不用認證帳密，如果還是想用 HTTPS 傳輸的話，就要研究一下要怎麼修改電腦設定。</p>
<p>要探討這個問題，須先了解 Git 的認證機制：<br>通過 HTTPS 傳輸時，預設需要輸入帳號密碼才可以訪問，而 Git 內建 credential storage 提供了開發者將帳密儲存於自己電腦中的功能，就不用每次遠端傳輸資料時都要輸入 帳號密碼；儲存可分為 osxkeychain、store、chache 三種方式。</p>
<h1 id="解決辦法"><a href="#解決辦法" class="headerlink" title="解決辦法"></a>解決辦法</h1><p>先用這個指令查詢電腦系統支援的 git credentials 形式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git help -a | grep credential</span><br></pre></td></tr></table></figure>

<p>在不同的作業系統平台，Git credential storage 有不同的預設值，如果是 mac OS X 用 Homebrew 安裝 Git ，會得到如下的資訊：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">credential                remote-ext</span><br><span class="line">credential-cache          remote-fd</span><br><span class="line">credential-cache--daemon  remote-ftp</span><br><span class="line">credential-osxkeychain    remote-ftps</span><br><span class="line">credential-osxkeychain    remote-http</span><br></pre></td></tr></table></figure>

<p>Homebrew 安裝過程預設 HTTPS 通訊協定情況使用 osxkeychain 輔助工具來儲存認證訊息，表示透過 HTTPS 連接 Repository 時，系統用 osxkeychain 儲存的帳密向其要求傳輸權限，所以如果把 HTTPS 的 credential 設定修改，就能重新輸入新的、正確的帳號密碼了。</p>
<p>修改方式如下：</p>
<p>用這行命令找出所有 credential.helper 在電腦中的位置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --show-origin --get credential.helper</span><br></pre></td></tr></table></figure>

<blockquote>
<p>通常可能是在…/usr/share/git-core/gitconfig</p>
</blockquote>
<ol start="2">
<li>找到 .gitconfig 文件後，將下面這段文字修改後儲存：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">原始預設：</span><br><span class="line">[credential]   helper = osxkeychain  </span><br><span class="line">刪除 osxkeychain 變成：</span><br><span class="line">[credential]   helper =</span><br></pre></td></tr></table></figure>

</li>
</ol>
<blockquote>
<p>此時沒有設置儲存方式，之後每次 push 都會詢問帳密。</p>
</blockquote>
<ol start="3">
<li><p>輸入以下指令來檢查是否已經成功取消osxkeychain設置，如果還是出現 osxkeychain 表示沒有完成，可能一台電腦上有多個 .gitconfig 文件需要處理</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config credential.helper</span><br></pre></td></tr></table></figure>
</li>
<li><p>檢查完成後，進行 git push ， 此時 git 會詢問帳密，便可輸入新的、正確的帳號密碼了。</p>
</li>
<li><p>最後可以直接在 iTerm 命令列恢復 osxkeychain 設定：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git  config --global  credential.helper  osxkeychain</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>或開啟.gitconfig 文件修改 <code>[credential] helper = osxkeychain</code> ，由於使用 store 方式會產生一個明碼的檔案在電腦中，比較不建議，為了安全起見，還是使用 osxkeychain 方式來儲存帳密。而如果是用 cache 方式的話，會將帳密暫存在硬碟中，一定時間內可以快取，但時間過了就要再重新輸入。<br>這樣就完成了 git credentials 的重新設置，另外如果想要查看 git config 的相關設定，可以用這個指令 <code>git config --list</code> 。</p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="https://chinyun.github.io/myblog/myblog/2019/10/29/Scrum-敏捷開發/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="chinyun">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/myblog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jinny's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/myblog/2019/10/29/Scrum-敏捷開發/" class="post-title-link" itemprop="url">Scrum 敏捷開發</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-10-29 18:05:47" itemprop="dateCreated datePublished" datetime="2019-10-29T18:05:47+00:00">2019-10-29</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-11-07 14:21:10" itemprop="dateModified" datetime="2019-11-07T14:21:10+00:00">2019-11-07</time>
              </span>
            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Scrum-是什麼？"><a href="#Scrum-是什麼？" class="headerlink" title="Scrum 是什麼？"></a>Scrum 是什麼？</h1><p>Scrum 是一個流程框架，從 1990 年代初期由 Ken Schwaber 和 Jeff Sutherland 共同發展出來的，他被用在研究和辨識市場、技術、產品性能的可能性，以及開發產品和加強功能，人們透過運用這個框架來處理錯綜複雜的調適性問題，並且講求團隊運用其生產力和創意來盡可能的交付高價值的產品。</p>
<p>“A framework within which people can address complex adaptive problems, while productively and creatively delivering products of the highest possible value.”<br>– <a href="https://scrumguides.org/index.html" target="_blank" rel="noopener">The Scrum Guide</a></p>
<h1 id="Scrum-如何運作？"><a href="#Scrum-如何運作？" class="headerlink" title="Scrum 如何運作？"></a>Scrum 如何運作？</h1><p>將所有工作事項切分成多個可量化執行時間、工作量的小任務，並依照優先順序分配小任務於每個開發週期中，這個週期稱為 sprint，也就是快速衝刺的意思，通常以 2-4 週為一個 sprint，團隊成員必須於時限內完成計畫目標，當一個 sprint 結束時，會將完成的任務整理成一個可檢視的成果，再繼續進行下一個週期，反覆循環直到專案完成。</p>
<p>在管理進程上，會此用 Scrum board 來視覺化表示進度，例如將 board 分為 story（使用情境）、todo（細節功能）、WIP(work-in-process)、to verify（QA、test） 和 done 這幾個欄位，並用一張便利貼表示一個任務，當任務有進度時，便將便利貼移動到所屬進度，依照狀態及時挪動，直到完成，這樣的作法可以讓團隊成員共享資訊並清楚所有工作流程和進度。</p>
<p>scrum 的運作依靠以下重要物件、活動、特質：</p>
<ol>
<li>使用者故事</li>
<li>task: 根據 user story 列出所有需要被完成的任務</li>
<li>product backlog: 產品代辦清單</li>
<li>sprint backlog: 衝刺代辦清單</li>
<li>product increment: 可隨時發佈的可運作產品</li>
<li>sprint meeting</li>
<li>daily srcum</li>
<li>sprint review meeting</li>
<li>sprint retrospective meeting</li>
<li>團隊專注、勇氣、開放、承諾和尊重</li>
</ol>
<h1 id="專案角色"><a href="#專案角色" class="headerlink" title="專案角色"></a>專案角色</h1><p>在 scrum 中需要有明確的角色分配，主要角色為：</p>
<ol>
<li><p>product owner 代表客戶立場，整合客戶意見、使用者回饋，確保開發中產品符合需求，負責規劃使用者故事，並與團隊討論<br>決定開發優先順序，在開發過程協助團隊釐清產品需求。在每個 sprint 週期結束時，決定使否將此週期的成果發佈。</p>
</li>
<li><p>scrum master<br>確保專案按照 scrum 方式開發，並排除任何會影響 scrum 流程的障礙，是規則的執行者。</p>
</li>
<li><p>develop team<br>負責開發和交付產品，包括設計、工程等個領域的專業人士。</p>
</li>
</ol>
<p>其他角色可能為：<br>stackholder 利益關係者，可能是客戶</p>
<h1 id="kanban-v-s-scrum"><a href="#kanban-v-s-scrum" class="headerlink" title="kanban v.s. scrum"></a>kanban v.s. scrum</h1><p>kanban 也是一種敏捷開發框架，由豐田汽車的創辦人 豐田喜一郎開發出來的一套管理方法，以「減少浪費」、「持續改進」為生產管理目標，也使用 kanban board 來視覺化作業流程，限制半成品（work-in-progress）的數量，監控與管理作業流程，建立明確的規劃，建立良好的訊息回饋路徑，團隊間互相合作，帶著實驗精神展開持續的改善。屬於長期的工作計畫，可以在任何時間點，透過團隊討論達成共識，改變專案執行方式和流程，沒有明確的專案角色，視專案和團隊需求而定，同時持續發布產品更新，由團隊成員共同決定是否發佈。</p>
<p>兩者的主要不同之處為：</p>
<ul>
<li>scrum 限制每個任務執行時間，kanban 主要限制同時執行的任務數目</li>
<li>scrum 有明確的專案角色，kanban 沒有</li>
<li>scrum 有明確的週期時間，kanban 是長期持續進行</li>
<li>scrum 在一個 sprint 結束後發佈產品，kanban 因為沒有明確週期，所以可以隨時發佈產品</li>
</ul>
<p>兩者的相同之處是：</p>
<ul>
<li>採用視覺化的流程管理，公開透明化讓團隊成員可以共同討論、檢視。</li>
<li>有週期性檢閱成果，持續改善優化工作內容與流程</li>
<li>將複雜龐大的工作項目切分成多項可執行小任務，提升工作效率。</li>
</ul>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="https://chinyun.github.io/myblog/myblog/2019/10/12/React-lifecycle-and-state/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="chinyun">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/myblog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jinny's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/myblog/2019/10/12/React-lifecycle-and-state/" class="post-title-link" itemprop="url">React lifecycle and state</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-10-12 20:15:41" itemprop="dateCreated datePublished" datetime="2019-10-12T20:15:41+00:00">2019-10-12</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-11-07 14:21:10" itemprop="dateModified" datetime="2019-11-07T14:21:10+00:00">2019-11-07</time>
              </span>
            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="React-lifecycle-method-amp-state-updating"><a href="#React-lifecycle-method-amp-state-updating" class="headerlink" title="React lifecycle method &amp; state updating"></a>React lifecycle method &amp; state updating</h1><h1 id="提升-React-效能：保持-virtual-DOM-的一致"><a href="#提升-React-效能：保持-virtual-DOM-的一致" class="headerlink" title="提升 React 效能：保持 virtual DOM 的一致"></a>提升 React 效能：保持 virtual DOM 的一致</h1><ul>
<li>DOM (Document Object Model)是什麼？</li>
</ul>
<p>DOM 文件物件模型，是 Html, XML, SVG 等文件的程式介面，提供一種文件樹的結構化表示方法，可以讓程式存取並改變文件架構、風格（style）和內容，透過 DOM 結構，文件擁有屬性、函式節點，物件可以和事件處理程序連結，當事件被觸發，執行處理程序來存取或改變文件。</p>
<ul>
<li>React 如何改變 DOM 以及如何提升效能？</li>
</ul>
<p>由於讀取更新 DOM 損耗 browser 的執行率，每一次改變便 render 整個頁面在 JavaScript 是很慢的，React 使用 Virtual DOM 虛擬 DOM 的一個強大的 Render 系統，只需更新 DOM 而不需要從 DOM 讀取，以減少運算。<br>同時， React 的 diff 演算法，當 render function running 得時候，讓 virtual dom 和 real dom 比對只重繪有更新的部分，做出最低必要的更新。</p>
<p>官方文件：<br>When you use React, at a single point in time you can think of the render() function as creating a tree of React elements. On the next state or props update, that render() function will return a different tree of React elements. React then needs to figure out how to efficiently update the UI to match the most recent tree.</p>
<ul>
<li>開發者提升 React 應用程式的方法</li>
</ul>
<p>盡可能的減少讀取和更新 DOM<br>We must minimize the amount of work that we do to the DOM.</p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="https://chinyun.github.io/myblog/myblog/2019/10/12/React-Updating-state-when-state-is-an-array-of-objects/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="chinyun">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/myblog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jinny's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/myblog/2019/10/12/React-Updating-state-when-state-is-an-array-of-objects/" class="post-title-link" itemprop="url">React: Updating state when state is an array of objects</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-10-12 19:06:41" itemprop="dateCreated datePublished" datetime="2019-10-12T19:06:41+00:00">2019-10-12</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-11-07 14:21:10" itemprop="dateModified" datetime="2019-11-07T14:21:10+00:00">2019-11-07</time>
              </span>
            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>當 state 的結構是 array of objects 的時候，更新 state 的方法需要考慮到 data structure 和 react update 機制。</p>
<h1 id="Immutable-Data-Structures"><a href="#Immutable-Data-Structures" class="headerlink" title="Immutable Data Structures"></a>Immutable Data Structures</h1><p>由於 react 的 state update 機制是觸發 render function 後會讓 virtual dom 和 real dom 比對只重繪有更新的部分，做出最低必要的更新。<br>因此每次變動 state 的時候需要這樣寫：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">this.setState(&#123;</span><br><span class="line">  obj: &#123;</span><br><span class="line">    ...this.state.obj,</span><br><span class="line">    id: 2</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">  </span><br><span class="line">this.setState(&#123;</span><br><span class="line">  list: [...this.state.arr, 123]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>而不能這樣寫：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#wrong</span><br><span class="line">const newObject = this.state.obj</span><br><span class="line">newObject.id = 2;</span><br><span class="line">this.setState(&#123;</span><br><span class="line">  obj: newObject</span><br><span class="line">&#125;)</span><br><span class="line">  </span><br><span class="line">#wrong</span><br><span class="line">const arr = this.state.arr;</span><br><span class="line">arr.push(123);</span><br><span class="line">this.setState(&#123;</span><br><span class="line">  list: arr</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>也就是說每次改動 state 的時候，都是產生一個新的物件，而不是直接對現有的 object 進行變更，這就是 Immutable data 的概念。</p>
<h1 id="如何正確的更新-state？"><a href="#如何正確的更新-state？" class="headerlink" title="如何正確的更新 state？"></a>如何正確的更新 state？</h1><p>由於 JavaScript 的資料結構特性，我們需要用 <code>Object Spread Operator</code> 和 <code>Object.assign({}, defaults, options)</code> 等方法在 React 中更新 state。</p>
<ul>
<li>Objects, Array 深、淺拷貝</li>
</ul>
<p>由於在 JavaScript 中 Objects, Array 的資料型別在賦值的時候，是用 pass by reference 的方法，與原始型別（primitive type）的直接傳值（pass by value）是不一樣的。</p>
<p>所以我們在複製 Objects, Array 的時候會利用函式處理，而不會直接用等號賦值。<br>但賦值的時候因為傳值的差異，有 淺拷貝（Shallow copies）和深拷貝（Deep copies）的差異。</p>
<p>淺拷貝:<br>Shallow copies duplicate as little as possible. A shallow copy of a collection is a copy of the collection structure, not the elements. With a shallow copy, two collections now share the individual elements.</p>
<p>深拷貝:<br>Deep copies duplicate everything. A deep copy of a collection is two collections with all of the elements in the original collection duplicated.</p>
<p>對 Shallow copy 來說，只是複製 collection structure，而不是 element。<strong>所以在指派第二層物件時會出現問題。</strong></p>
<p>而 Deep Copy 是整個複製，包含 element。<strong>所以當我們在使用多層物件時，要用 deep copy。</strong></p>
<ul>
<li>正確的更新 state</li>
</ul>
<p>當我的 state 如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">this.state = &#123;</span><br><span class="line">  journeyList: [</span><br><span class="line">    &#123;id: 1, name: &quot;Japan, Tokyo&quot;&#125;,</span><br><span class="line">    &#123;id: 2, name: &quot;Japan, Kyoto&quot;&#125;,</span><br><span class="line">    &#123;id: 3, name: &quot;Europe 12 DAYS Travel&quot;&#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Update function would look like this:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">updateJourney = (journey) =&gt; &#123;</span><br><span class="line">    const index = this.state.journeyList.findIndex((item)=&gt; item.id === journey[0].id);</span><br><span class="line">    if (index !== -1) &#123;</span><br><span class="line">      this.setState(&#123;</span><br><span class="line">        journeyList: [</span><br><span class="line">          ...this.state.journeyList.slice(0, index),</span><br><span class="line">           Object.assign(&#123;&#125;, this.state.journeyList[index], journey[0]),</span><br><span class="line">           ...this.state.journeyList.slice(index + 1)</span><br><span class="line">        ]</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>

<p>若 journey 為：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&#123;id: 4, name: &apos;Singapore 7 days trip&apos;&#125;]</span><br></pre></td></tr></table></figure>

<p>則我的 state 就會變成：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">this.state = &#123;</span><br><span class="line">  journeyList: [</span><br><span class="line">    &#123;id: 1, name: &quot;Japan, Tokyo&quot;&#125;,</span><br><span class="line">    &#123;id: 2, name: &quot;Japan, Kyoto&quot;&#125;,</span><br><span class="line">    &#123;id: 3, name: &quot;Europe 12 DAYS Travel&quot;&#125;,</span><br><span class="line">    &#123;id: 4, name: &apos;Singapore 7 days trip&apos;&#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Use-Redux-to-update-state"><a href="#Use-Redux-to-update-state" class="headerlink" title="Use Redux to update state"></a>Use Redux to update state</h1><p>上述寫法當開發規模拓展的時候，每一次操作都需要深拷貝一次 state 並 assign 內容， code 維護上會較困難，因此可以考慮使用 Redux 的 state update pattern。</p>
<p>Redux uses a concept of state reducers which each work on a specific slice of the state of your application. That way you don’t have to manually dig through your entire state each time you want to affect a deep change.</p>
<p>相關文章可以參考：<a href="https://chinyun.github.io/myblog/2019/10/09/React-State-Management-Redux/">React State Management &amp; Redux</a></p>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="https://stackoverflow.com/questions/37662708/react-updating-state-when-state-is-an-array-of-objects" target="_blank" rel="noopener">StackOverflow</a></p>
<p><a href="https://blog.techbridge.cc/2018/01/05/react-render-optimization/" target="_blank" rel="noopener">React 性能優化大挑戰</a></p>
<p><a href="https://dustinhsiao21.com/2018/01/07/javascript-shallow-copy-and-deep-copy/" target="_blank" rel="noopener">關於JAVASCRIPT中的SHALLOW COPY(淺拷貝)及DEEP COPY(深拷貝)</a></p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="https://chinyun.github.io/myblog/myblog/2019/10/12/UI-variation-and-dynamic-feedback/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="chinyun">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/myblog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jinny's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/myblog/2019/10/12/UI-variation-and-dynamic-feedback/" class="post-title-link" itemprop="url">UI variation and dynamic feedback</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-10-12 14:47:37" itemprop="dateCreated datePublished" datetime="2019-10-12T14:47:37+00:00">2019-10-12</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-11-07 14:21:10" itemprop="dateModified" datetime="2019-11-07T14:21:10+00:00">2019-11-07</time>
              </span>
            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="UI-UX-與互動設計"><a href="#UI-UX-與互動設計" class="headerlink" title="UI/UX 與互動設計"></a>UI/UX 與互動設計</h1><ul>
<li><p>靜態的網頁介面與具有互動性的網站不同之處在於，互動能夠有效地引導使用者進行期待的操作。</p>
</li>
<li><p>互動設計與 UX 設計關係緊密，UX 關注網頁所規劃的操作流程是否足夠引導使用者表現出預期行為？使用者完成任務的效率是否良好？操作過程是否有挫折感？設計的操作提示，是否足夠引導使用者良好的方式吸收訊息？</p>
</li>
<li><p>為網頁設計具有互動性 UI 的可以幫助打造更友善的使用者介面，營造良好的使用者體驗。</p>
</li>
</ul>
<p>在為應用程式做介面設計和互動設計的時候，將為使用者考慮的細節包含進去思考，會發現每一個操作的動作，有它可以設計得更貼心的細微處。<br>觀察日常生活中經常使用的應用程式，也可以發現在細節處講究的互動設計，這些微互動設計可以稱為 微互動。</p>
<p>根據 微互動 一書的作者 Dan Saffer，他說：<br>「Microinteractions are contained product moments that revolve around a single use case — they have one main task. Every time you change a setting, sync your data or devices, set an alarm, pick a password, log in, set a status message, or favorite or “like” something, you are engaging with a microinteraction.」</p>
<ul>
<li>微互動是應用程式、設備等與使用者之間互動過程中，所有細節上的互動。</li>
<li>微互動可以幫助使用者更流暢的完成主要功能操作，也能讓使用者感到愉悅，影響使用者會不會繼續使用產品。</li>
</ul>
<p>UI 基本上由 輸入 -&gt; 內容改變 -&gt; 輸出 這個架構構成，而微互動則是<br>觸發 Trigger -&gt; 規則 Ruls -&gt; 回饋 Feedback -&gt; 迴圈和模式 Loops &amp; Modes。</p>
<p>「 A Trigger initiates a microinteraction. The Rules determine what happens, while <strong>Feedback lets people know what’s happening.</strong> Loops and Modes determine the meta-rules of the microinteraction. 」– Reference: MICROINTERACTIONS</p>
<h1 id="為什麼需要回饋（feedbacks）"><a href="#為什麼需要回饋（feedbacks）" class="headerlink" title="為什麼需要回饋（feedbacks）"></a>為什麼需要回饋（feedbacks）</h1><p>使用者操作時有預期心理，即使底層資料已改變，如果視覺上沒有給予足夠的回饋，會覺得操作行為尚未完成，適當的回饋可以傳遞更完整的訊息給使用者。</p>
<p>「 回饋：呼應微互動的規則。<br>使用數位裝置時，我們看到或聽到的一切都是一種抽象概念。只有少數使用者清楚軟體或裝置運作背後的原理。比如，我們不是真的把檔案放進資料夾內，電子郵件也不是真的送進收件夾裡，這些都是方便使用者理解互動如何進行的隱喻。任何可視、可聽、可感覺，可以幫助使用者了解系統運作規則，就是回饋。」 – Reference:[筆記] 微互動 microinteractions</p>
<h1 id="如何產生適當的回饋（feedbacks）"><a href="#如何產生適當的回饋（feedbacks）" class="headerlink" title="如何產生適當的回饋（feedbacks）"></a>如何產生適當的回饋（feedbacks）</h1><p>「 回饋可以採用多種形式：視覺、聽覺、觸覺（震動），甚至是<strong>動畫</strong>（有許多維度可以變化：時間點、速度、方向等）。重點是讓回饋契合執行中的動作，儘可能以最適當的方式傳達明確的訊息。<br>回饋可以展現產品的個性。<br>回饋也可以具備自己的運作規則，比方出現的時機？如何改變顏色？當使用者旋轉平板，畫面如何旋轉？這些規則可以變成回饋本身的微互動，開放使用者手動設定。」 – Reference:[筆記] 微互動 microinteractions</p>
<h1 id="CSS-Animation-amp-React-Render-機制"><a href="#CSS-Animation-amp-React-Render-機制" class="headerlink" title="CSS Animation &amp; React Render 機制"></a>CSS Animation &amp; React Render 機制</h1><ul>
<li><p>問題<br>React 在 Render 時會比較 Virtual DOM 與真實 DOM 的差異，沒有改變的地方便不會重新 Render，但是 CSS Animation 的機制是每次節點生成時產生動畫效果，而如果 React Component 以 props 的方式傳遞資料，父元件的 state 更新使子元件的 props 改變，由 props 傳遞的內容也隨之改變，然而節點本身沒有消失再生成，所以並不會產生動畫效果。</p>
</li>
<li><p>解決方式<br>給予 Html element 特定的 Key -&gt; 每次 props 更新時，連動 Key 更新，使 react render 機制判斷為新節點，因而重新生成觸動 animation的 element。</p>
</li>
</ul>
<p>for example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;p key=&#123;this.props.name&#125; className=&apos;title&apos;&gt;&#123;this.props.name&#125;&lt;/p&gt;</span><br><span class="line">    &lt;/div&gt;</span><br></pre></td></tr></table></figure>

<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="http://uirate.net/?p=1667" target="_blank" rel="noopener">[筆記] 微互動 microinteractions</a><br><a href="http://microinteractions.com/what-is-a-microinteraction/" target="_blank" rel="noopener">MICROINTERACTIONS</a></p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
  </div>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/myblog/page/2/">2</a><a class="extend next" rel="next" href="/myblog/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>


          </div>
          

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">chinyun</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        
          <a href="/myblog/archives/">
        
          <span class="site-state-item-count">15</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
    
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">chinyun</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> v3.9.0</div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.4.1</div>
  <script src='https://unpkg.com/mermaid@7.1.2/dist/mermaid.min.js'></script>
  <script>
    if (window.mermaid) {
      mermaid.initialize("");
    }
  </script>

        












        
      </div>
    </footer>
  </div>

  
  <script src="/myblog/lib/anime.min.js?v=3.1.0"></script>
  <script src="/myblog/lib/velocity/velocity.min.js?v=1.2.1"></script>
  <script src="/myblog/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
<script src="/myblog/js/utils.js?v=7.4.1"></script><script src="/myblog/js/motion.js?v=7.4.1"></script>
<script src="/myblog/js/schemes/pisces.js?v=7.4.1"></script>
<script src="/myblog/js/next-boot.js?v=7.4.1"></script>



  

















<script>
if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.initialize({
      theme: 'forest',
      logLevel: 3,
      flowchart: { curve: 'linear' },
      gantt: { axisFormat: '%m/%d/%Y' },
      sequence: { actorMargin: 50 }
    });
  }, window.mermaid);
}
</script>




  

  

  

</body>
</html>
