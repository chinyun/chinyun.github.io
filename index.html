<!DOCTYPE html>





<html lang="zh-tw">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.9.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/myblog/images/apple-touch-icon-next.png?v=7.4.1">
  <link rel="icon" type="image/png" sizes="32x32" href="/myblog/images/favicon-32x32-next.png?v=7.4.1">
  <link rel="icon" type="image/png" sizes="16x16" href="/myblog/images/favicon-16x16-next.png?v=7.4.1">
  <link rel="mask-icon" href="/myblog/images/logo.svg?v=7.4.1" color="#222">

<link rel="stylesheet" href="/myblog/css/main.css?v=7.4.1">


<link rel="stylesheet" href="/myblog/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/myblog/',
    scheme: 'Pisces',
    version: '7.4.1',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: 'Copy',
      copy_success: 'Copied',
      copy_failure: 'Copy failed'
    },
    sidebarPadding: 40
  };
</script>

  <meta name="keywords" content="JavaScript, React, d3, NodeJS, Web">
<meta property="og:type" content="website">
<meta property="og:title" content="Jinny&#39;s blog">
<meta property="og:url" content="https://chinyun.github.io/myblog/index.html">
<meta property="og:site_name" content="Jinny&#39;s blog">
<meta property="og:locale" content="zh-tw">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Jinny&#39;s blog">
  <link rel="canonical" href="https://chinyun.github.io/myblog/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false,
    isPage: false,
    isArchive: false
  };
</script>

  <title>Jinny's blog</title>
  








  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-tw">
  <div class="container use-motion">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/myblog/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Jinny's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">Writing For Sharing</p>
      
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
      
      
      
        
        <li class="menu-item menu-item-home">
      
    

    <a href="/myblog/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-archives">
      
    

    <a href="/myblog/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
            

          <div id="content" class="content">
            
  <div id="posts" class="posts-expand">
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="https://chinyun.github.io/myblog/myblog/2019/11/18/JS-Asynchronous-Synchronous/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="chinyun">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/myblog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jinny's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/myblog/2019/11/18/JS-Asynchronous-Synchronous/" class="post-title-link" itemprop="url">JS-Asynchronous & Synchronous</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-11-18 22:44:58" itemprop="dateCreated datePublished" datetime="2019-11-18T22:44:58+00:00">2019-11-18</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-11-21 12:25:02" itemprop="dateModified" datetime="2019-11-21T12:25:02+00:00">2019-11-21</time>
              </span>
            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="什麼是同步、非同步？"><a href="#什麼是同步、非同步？" class="headerlink" title="什麼是同步、非同步？"></a>什麼是同步、非同步？</h1><p>同步(synchronous)的意思是指一次只能進行一件事、一件任務，非同步或稱異步(asynchronous)的意思則是不用等上一任務完成再執行。只看名字容易搞混，但如果想成是同一個步道和不同步道，會比較好理解。同步道因為只有一個步道所以一次只能執行一項任務，而不同步道可以多個任務一起執行。</p>
<h1 id="JavaScript-如何實現非同步？"><a href="#JavaScript-如何實現非同步？" class="headerlink" title="JavaScript 如何實現非同步？"></a>JavaScript 如何實現非同步？</h1><p>JavaScript 這種編程語言，我們稱之為腳本(script)、直譯式語言，可以寫在 HTML 中，在頁面加載的時候會自動執行。只要瀏覽器或伺服器有搭載 JavaScript Engine 在環境中，就可以執行 JavaScript。</p>
<p>Scripts are provided and executed as a plain text. They don’t meed a special preparation or a compilation to run. In this aspect, JavaScript is very different from another language called JAVA. JAVA needs to be compiled into machine code.<br>在使用 C、C++、JAVA 之類傳統語言，執行前需要先編譯，這可以為程式碼產生機器的有效表達方式，通常可以優化執行時期的效能。早期的 JavaScript 因為直譯式語言的命令稿語言設計而在性能上表現不佳，但因其對 web 的發展重要性日益增長，許多企業資源和優秀人才的投入，現在既可收命令稿語言的便利性又可享有編譯式語言的性能。 </p>
<p>直譯式和編譯式程式語言的差別在於：直譯式語言需要經過 直譯器 interpreter 逐行轉換，且它是在執行時才被直譯成執行碼，效能一部分取決於直譯器的速度，直譯式語言多為動態語言(dynamic language)，具有靈活的型別處理，在執行時才動態生成等彈性。直譯式語言仰賴一個執行環境(execution context)語言可用的功能由這個執行環境提供。<br>編譯式語言經由 編譯器 compiler 轉換成目的碼(object code)再由連結器(linker)轉換成可執行的二進位碼(byte code)。編譯式語言多為靜態語言(static langauge)有事先定義的型別、型別檢查及高效能執行速度等特性。</p>
<p>由 Google 開發(2008)的 open source Engine：V8 是實現 JavaScript 在瀏覽器環境非同步執行的最佳功臣；在 V8 之前的 Engine 都太慢了，Google 為了讓 JavaScript 能夠在瀏覽器上跑得更快，開發了以 C++ 語言寫成的 V8。V8 將 JavaScript 在執行前編譯成了<a href="https://zh.wikipedia.org/wiki/%E6%9C%BA%E5%99%A8%E8%AF%AD%E8%A8%80" target="_blank" rel="noopener">機器碼</a>(machine code，是電腦的CPU可直接解讀的資料)；而<a href="https://zh.wikipedia.org/wiki/%E5%AD%97%E8%8A%82%E7%A0%81" target="_blank" rel="noopener">位元組碼</a>(bytecode，是為了實現特定軟體運行、軟體環境、與硬體環境無關)或是解釋執行它，並使用了 inline-caching 行內快取等方法，提升效能，使其速度能夠媲美二進制編譯。</p>
<p>每個瀏覽器(Google Chrome, FireFox, IE, Safari)都有自己的 JavaScript Engine implementation and all of them have a JavaScript runtime that provide web APIs. 這些 web APIs 是種應用程式，負責許多瀏覽器運作所需的操作，包括 send HTTP Request, listen to DOM events, delay execution by using setTimeout and setInterval, caching, database storage…etc. 也可以儲存資料、暫存在瀏覽器。其他 Engine 還有 Spider Monkey(used by FireFox)以及 Chakra(used by IE) 等。</p>
<p><strong>JavaScript is a single threaded language that can be non-blocking.</strong></p>
<p>JavaScript 是單一執行緒(single threaded execution)的程式語言，意思是一次只能處理一個需求(任務)，所有的 line code 在執行堆疊(call stack)中記錄執行情況，每次只會執行一個程式碼片段(one thing at a time = one call stack)。</p>
<p>執行堆疊(call stack)會紀錄目前執行到程式的哪個部分，如果進入了某個 function，便會把這個 function 添加到堆疊的最上方，如果 function 執行了 <code>return</code> 便會把 function 從堆疊中抽離(pop off)，在堆疊中的資料是遵守 first-in-last-out 的順序。</p>
<p>雖然 JavaScript 執行程式是同步的，逐一執行，但<strong>因為在瀏覽器環境中，還有 Rendering Engine 和 HTTP Request，所以整個網頁在執行過程中可以達到非同步的運作</strong>。</p>
<h2 id="JavaScript-Run-Time-Environment"><a href="#JavaScript-Run-Time-Environment" class="headerlink" title="JavaScript Run-Time Environment?"></a>JavaScript Run-Time Environment?</h2><p>JavaScript Run-Time Environment 就是指 JavaScript 的執行環境，下圖為執行環境的示意：</p>
<p><img src="https://miro.medium.com/max/1584/1*lZ-KXoVNUSOwaq7q8zUBDg.png" alt="avaScript Run-Time Environment"></p>
<blockquote>
<p>圖片來源為<a href="https://itnext.io/how-javascript-works-in-browser-and-node-ab7d0d09ac2f" target="_blank" rel="noopener">How JavaScript works in browser and node?</a></p>
</blockquote>
<p>JavaScript 依靠這些機制運作執行：</p>
<ul>
<li><strong>Memory Heap</strong> 記憶、儲存。 JavaScript automatically allocates memory when objects are created and frees it when they are not used anymore(Garbage Collection).</li>
<li><strong>Call Stack</strong> 執行堆疊，紀錄當前程序所在位置的數據結構，從最上方開始執行。</li>
<li><strong>Event Loop</strong> 事件循環，不斷檢查 Call Stack 是否為空的。</li>
<li><strong>Callback Queue</strong> 佇列，遵守 fisrt-in-first-out 的資料處理順序。</li>
<li><strong>Web APIs</strong> 由瀏覽器提供的應用程式，例如：fetch(), DOM events, setTimeout, setInterval…etc. These Web APIs are asynchronous. That means, you can instruct these APIs to do something in background and return data once done, meanwhile we can continue further execution of JavaScript code. While instructing these APIs to do something in background, we have to provide a callback function. Responsibility of callback function is to execute some JavaScript once Web API is done with it’s work.</li>
</ul>
<p>在瀏覽器執行 JavaScript 時， call stack 會將不屬於 JavaScript 原生處理範圍的函式或程式碼，丟給 Web APIs 處理，再將處理結果丟到 Callback Queue，透過 Event Loop 不斷查詢是否 Call Stack is empty？如果沒有等待執行的程式碼，再將 Callback Queue 佇列中的第一項放到 Call Stack 中去執行。由於 Event Loop 運作的關係，瀏覽器的 JavaScript 可以同時執行多個需求，而不需要等待上個需求完成才進行下一個。</p>
<h1 id="非同步的-JavaScript"><a href="#非同步的-JavaScript" class="headerlink" title="非同步的 JavaScript"></a>非同步的 JavaScript</h1><p>以下介紹幾個在 JavaScript 中實現非同步操作的語法：</p>
<h3 id="setTimeout-amp-setInterval"><a href="#setTimeout-amp-setInterval" class="headerlink" title="setTimeout() &amp; setInterval()"></a>setTimeout() &amp; setInterval()</h3><p>setTimeout 和 setInterval 是由瀏覽器提供的 Web APIs，可以延遲任務執行時間，作為計時器使用。</p>
<h3 id="ES6-Promise"><a href="#ES6-Promise" class="headerlink" title="ES6: Promise"></a>ES6: Promise</h3><p>為了解決 callback hell 的問題和串接 function 的需求，JavaScript 在 ES6 中加入了 Promise，Promise is saying that “hey, I am doing somthing and I promise to let you know when I have the result.” A promise is an object that may produce a single value some time in the future, either a resolved value, or a reason that it’s not resolved(rejected). Promise 讓非同步請求處理更容易，是一種非同步編程的解決方案。Promise object 是一個構造函數，需要用 <code>new</code> 語法來生成 promise 實例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const promise = new Promise( function(resolve, reject)&#123;</span><br><span class="line">  console.log(&apos;Promise&apos;);</span><br><span class="line">  if(true) &#123;</span><br><span class="line">    resolve(value);  //  state 由 pending 轉為 fulfilled</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    reject(error); // state 由 pending 轉為 rejected</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>Promise 有三種狀態：pending、fulfilled、rejected，分別代表當前腳本任務的執行狀況。當 Promise 實例生成後，可以用 <code>.then(function(){}, function(){})</code> 方法分別指定 fulfilled 和 rejected 狀態時的回調函數(callback function)：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">promise.then(</span><br><span class="line">  function(value)&#123;</span><br><span class="line">    console.log(&apos;resolved&apos;);</span><br><span class="line">  &#125;, </span><br><span class="line">  function(error)&#123;</span><br><span class="line">    console.log(&apos;rejected&apos;); // rejected 狀態的 callback function 可選，不一定要指定</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h3 id="fetch-API"><a href="#fetch-API" class="headerlink" title="fetch() API"></a>fetch() API</h3><p>A fetch simply return a promise.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fetch(&apos;url&apos;)</span><br><span class="line">  .then( response =&gt; response.json()) </span><br><span class="line">    // we would get a response which was a promise. </span><br><span class="line">    //.json() convert it into sth that can be used in js.</span><br><span class="line">  .then( data =&gt; console.log(data))</span><br><span class="line">  .catch((error) =&gt; console.log(error));</span><br><span class="line">    //it&apos;s going to check and run if anything before it fails.</span><br></pre></td></tr></table></figure>

<p>fetch 實作基於 es6 promise，在 2015 年由 google 發佈，fetch 回傳的 promise 物件不會再有收到 response 但是 http status 呈現 404 或 500 的時後變成 rejected，只會在網路出現問題或是被阻止 request 時，狀態才會變成 rejected，其他都是 fulfilled。<br>由於 fetch 會返回一個 promise 所以可以使用 <code>.then</code> 來串接，避免撰寫 callback hell 程式碼，通常使用時會用 <code>.catch</code> 來捕捉 promise 發生的 error。</p>
<h3 id="ES8-Async-Await"><a href="#ES8-Async-Await" class="headerlink" title="ES8: Async/Await"></a>ES8: Async/Await</h3><p><code>Async/Await</code> is bulit on top of Promises. 目的是簡化使用 promise 的行為。我們可以使用   <code>async ()=&gt;{}</code>來宣告一個非同步函式，這個非同步函式會返回一個 promise。 <strong>Every function that returns a promise can be considered as async function.</strong> <code>async</code> function 是不管怎樣都會回傳 <code>Promise</code> 的函式，雖然我們回傳的不是一個 <code>Promise</code>，但因為它是 <code>async</code> function 的關係，JS 會自動把它包成 <code>Promise</code>，所以可以使用 <code>then</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const foo = async () =&gt; &#123;</span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo().then((res) =&gt; &#123;</span><br><span class="line">    console.log(res); // 1</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><code>await</code> 必須在 <code>async</code> function 裡面才能使用，<code>await</code>可以在所有 return a promise 的程式碼前使用，<code>await</code> 會等 promise 執行完，再執行下一行。<code>await</code> 也能夠把 <code>Promise</code> 回傳的值接起來，通常我們在呼叫 API（例如執行 fetch、axios）的時候就很好用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fetch(&apos;https://jsonplaceholder.typicode.com/users&apos;)</span><br><span class="line">  .then(response =&gt; response.json())</span><br><span class="line">  .then((data) =&gt; console.log(data))</span><br></pre></td></tr></table></figure>

<p>改寫成 async function：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">async function fetchUsers() &#123;</span><br><span class="line">  const resp = await fetch(&apos;https://jsonplaceholder.typicode.com/users&apos;);</span><br><span class="line">    // the function is going to pause until we get a response from fetch</span><br><span class="line">  const data = await response.json();</span><br><span class="line">  console.log(data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 async/await 處理多個 非同步請求以及除錯，比使用 promise 的 then 鏈，更容易除錯：</p>
<p>這是使用 promise 和 try/catch 用法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function loadData() &#123; </span><br><span class="line">  // Catches synchronous errors</span><br><span class="line">  try &#123; </span><br><span class="line">    getJSON().then((response) =&gt; &#123;</span><br><span class="line">      var parsed = JSON.parse(response);</span><br><span class="line">      console.log(parsed);</span><br><span class="line">    &#125;).catch( err =&gt; console.log(err)); // Catches asynchronous errors</span><br><span class="line">  &#125; catch(e) &#123;</span><br><span class="line">    console.log(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>這是使用 asyn/await 和 try/catch：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">async function loadData() &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    var data = JSON.parse(await getJSON());</span><br><span class="line">    console.log(data);</span><br><span class="line">  &#125; catch(e) &#123;</span><br><span class="line">    console.log(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在錯誤發生時，如果是用 .then 返回的錯誤堆疊不提供錯誤發生在哪裡，不容易找到錯誤發生原因：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function loadData() &#123;</span><br><span class="line">  return callAPromise()</span><br><span class="line">    .then(callback1)</span><br><span class="line">    .then(callback2)</span><br><span class="line">    .then(callback3)</span><br><span class="line">    .then(() =&gt; &#123;throw new Error(&quot;boom&quot;)&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">loadData()</span><br><span class="line">  .catch((err) =&gt; &#123;console.log(err)&#125;);</span><br><span class="line">    // Error: boom at callAPromise.then.then.then.then (index.js:8:13)</span><br></pre></td></tr></table></figure>

<p>使用 async/await 便可以逐行找到錯誤發生的地方：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">async function loadData() &#123;</span><br><span class="line">  await callAPromise1()</span><br><span class="line">  await callAPromise2()</span><br><span class="line">  await callAPromise3()</span><br><span class="line">  await callAPromise4()</span><br><span class="line">  await callAPromise5()</span><br><span class="line">  throw new Error(&quot;boom&quot;);</span><br><span class="line">&#125;</span><br><span class="line">loadData()</span><br><span class="line">  .catch((err) =&gt; &#123;console.log(err)&#125;);</span><br><span class="line">  // Error: boom at loadData (index.js:7:9)</span><br></pre></td></tr></table></figure>

<h1 id="JavaScript-vs-Node-js"><a href="#JavaScript-vs-Node-js" class="headerlink" title="JavaScript vs Node.js"></a>JavaScript vs Node.js</h1><p><strong>Node.js is a JavaScript runtime bulit on Google chrome’s V8 engine</strong>. 2009 Ryan Doll decided it would be great to run it ouside the browser. So he created Node.js which is actually a C++ program. It’s an executable C++ program that provides JS runtime for us.<br>Node.js uses Google chrome’s V8 engine to provide JavaScript runtime but does not rely only on it’s event loop. It uses <strong>libuv library (written in c) to work along side V8 event loop</strong> to extend what can be done in background. Node follows same callback approach like Web APIs and works in similar fashion as the browser.</p>
<p>Node.js 的執行系統圖示：</p>
<p><img src="https://hackaday.com/wp-content/uploads/2018/08/nojs-system-diagram-by-busyrich.jpg?w=800" alt="nojs-system-diagram-by-busyrich"></p>
<blockquote>
<p>圖片來源為<a href="https://hackaday.com/wp-content/uploads/2018/08/nojs-system-diagram-by-busyrich.jpg?w=800" target="_blank" rel="noopener">nojs-system-diagram-by-busyrich</a></p>
</blockquote>
<p>If you compare browser diagram with above node diagram, you can see the similarities. The entire right section looks like Web API but it also contains event queue (callback queue/message queue) and the event loop. But V8, event queue and event loop runs on single thread while <strong>worker threads are responsible to provide asynchronous I/O operation</strong>. That’s why Node.js is said to have as non-blocking event driven asynchronous I/O architecture.</p>
<p>I/O 指 input/output，資訊處理系統與外部世界(使用者、另一個資訊處理系統)之間的通訊，包括輸入：接收訊號或資料；輸出：發送訊號或資料。任何資訊傳入或傳出 CPU/記憶體組合，例如通過磁盤驅動器讀取資料，就會被認為是 I/O。</p>
<h3 id="Asynchronous-Node-js"><a href="#Asynchronous-Node-js" class="headerlink" title="Asynchronous Node.js"></a>Asynchronous Node.js</h3><p>由 Node.js 建立的後端伺服器，可以使用 Express.js 框架來處理非同步請求的操作，Express.js 是一個基於 Node.js 平台，極簡、靈活的框架，擁有強大的特性可以幫助開放網頁應用。<br>使用 Express.js 就是調用各種中間件(middleware)來處理各種請求、管理路由，其本身也可以視為是一種中間件(middleware)。通過 Express.js 提供的執行函數調用對應的方法，比起直接在 Node.js 中寫處理程式，會更加方便和快捷。</p>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="https://itnext.io/how-javascript-works-in-browser-and-node-ab7d0d09ac2f" target="_blank" rel="noopener">How JavaScript works in browser and node?</a><br><a href="https://www.udemy.com/course/advanced-javascript-concepts/" target="_blank" rel="noopener">Udemy course “Advanced JavaScript Concepts”</a><br><a href="https://kknews.cc/zh-hk/tech/eo352pq.amp" target="_blank" rel="noopener">學習Express前，都會搞懂這幾個問題</a></p>
<h1 id="延伸閱讀"><a href="#延伸閱讀" class="headerlink" title="延伸閱讀"></a>延伸閱讀</h1><p><a href="https://chinyun.github.io/myblog/2019/11/02/HTTPS-HTTP-JSON-AJAX/">HTTPS/HTTP/JSON/AJAX/RestfulAPI</a><br><a href="https://chinyun.github.io/myblog/2019/11/17/JS-ECMAScript">JS-ECMAScript</a></p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="https://chinyun.github.io/myblog/myblog/2019/11/17/JS-ECMAScript/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="chinyun">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/myblog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jinny's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/myblog/2019/11/17/JS-ECMAScript/" class="post-title-link" itemprop="url">JS-ECMAScript</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-11-17 18:50:17" itemprop="dateCreated datePublished" datetime="2019-11-17T18:50:17+00:00">2019-11-17</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-11-21 12:25:02" itemprop="dateModified" datetime="2019-11-21T12:25:02+00:00">2019-11-21</time>
              </span>
            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="ECMAScript"><a href="#ECMAScript" class="headerlink" title="ECMAScript"></a>ECMAScript</h1><p>1996 年創造 JavaScript 的 NetScape 公司決定將 JavaScript 提交給標準化組織 ECMA，希望讓這種語言成為國際標準。1997 年 ECMAScript 1.0 發佈，規定了 browser 腳本語言的標準。<br>使用 ECMAScript 這個名稱的原因是：</p>
<ol>
<li>商標註冊：JAVA 是 Sun 公司的商標，根據授權協議 JavaScript 只有 NetScape 公司可以使用。</li>
<li>可表示這個語言的制定者為 ECMA，保證其開放性和中立性。<br>標準制定者每個月開一次會，委員會供來自任何人的提案，經過多次開會等一個提案足夠成熟，就可以正式進入標準。每年會正式發佈一次，作為當年正式版本。接下來一年期間根據此版本為基礎做微幅變動，直到隔年草案便正式成為新的正式版本。在 2015 年 6 月發佈的就是 ECMAScript2015 又稱為 ES6，由於在上一次是 ES5.1(2009.11)，ES6 包含了較多的新特性，從 ES5.1 之後到 ES6 訂定的標準。<br>規範的推動主要會經過以下幾個階段：</li>
</ol>
<ul>
<li>Stage 0: strawman——最初想法的提交。</li>
<li>Stage 1: proposal（提案）——由TC39至少一名成員倡導的正式提案文件，該文件包括API事例。</li>
<li>Stage 2: draft（草案）——功能規範的初始版本，該版本包含功能規範的兩個實驗實現。</li>
<li>Stage 3: candidate（候選）——提案規範通過審查並從廠商那裡收集反饋</li>
<li>Stage 4: finished（完成）——提案準備加入ECMAScript，但是到瀏覽器或者Nodejs中可能需要更長的時間。</li>
</ul>
<p>以下簡要的依年份條列從 2015 年至今(2019)加入的新功能：</p>
<h2 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h2><ul>
<li><code>let</code> &amp; <code>const</code> &amp; block scope 的概念：避免 <code>var</code> 宣告時，出現區域變數覆蓋全域變數或在  <code>for loop</code> 中循環變數洩露成為全域變數的副作用發生。</li>
<li>Arrow Function：節省 code line，而且沒有自己的 <code>this</code> 值，使用來自外部的 <code>this</code>，作為 object method 的時候不需要再 <code>.bind(this)</code>。</li>
<li>Class</li>
<li>Promise</li>
<li>mudule</li>
<li>Template Strings</li>
<li>解構賦值 (destructuring)：從數組中獲取值並賦值到變量中，變量的順序與數組中對象順序對應。</li>
<li>Array Spread operator</li>
<li>Object.assign()</li>
<li>Symbol</li>
<li>Set, Map, weakSet, weakMap</li>
<li>函數參數默認值</li>
<li>對象屬性簡寫</li>
</ul>
<h2 id="ES7"><a href="#ES7" class="headerlink" title="ES7"></a>ES7</h2><ul>
<li>includes()：可以使用在 string 或 array，檢查有無某元素，返回 true 或 false </li>
<li>exponential operator 指數運算符：**</li>
</ul>
<h2 id="ES8"><a href="#ES8" class="headerlink" title="ES8"></a>ES8</h2><ul>
<li>String padding: <code>padStart()</code>,<code>padEnd()</code> 新增字串長度到指定長度</li>
<li>can use ‘ending commas’ in list or calling 函數參數列表結尾允許逗號</li>
<li>Object.values(), Object.entries()</li>
<li>Async Await</li>
</ul>
<h2 id="ES9"><a href="#ES9" class="headerlink" title="ES9"></a>ES9</h2><ul>
<li>Object Spread operator</li>
<li><code>.finally()</code> 在 promise 完成(resovled or rejected)後執行一個指令</li>
<li>Asynchronous iterators <code>for await(... of...)</code> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">async function process(array) &#123;</span><br><span class="line">  for await (let i of array) &#123;</span><br><span class="line">    doSomething(i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="ES10"><a href="#ES10" class="headerlink" title="ES10"></a>ES10</h2><p>ES10 在 2019 年 2 月中推出，在新版的 Nodejs 和 Chrome 已經可以使用。</p>
<ul>
<li><p><code>[].flat()</code>,<code>[].flatMap()</code></p>
</li>
<li><p><code>Object.fromEntries</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const map = new Map([ [&apos;foo&apos;, &apos;bar&apos;], [&apos;baz&apos;, 42] ]);</span><br><span class="line">const obj = Object.fromEntries(map);</span><br><span class="line">console.log(obj); // &#123; foo: &quot;bar&quot;, baz: 42 &#125;</span><br><span class="line"></span><br><span class="line">const arr = [ [&apos;0&apos;, &apos;a&apos;], [&apos;1&apos;, &apos;b&apos;], [&apos;2&apos;, &apos;c&apos;] ];</span><br><span class="line">const obj = Object.fromEntries(arr);</span><br><span class="line">console.log(obj); // &#123; 0: &quot;a&quot;, 1: &quot;b&quot;, 2: &quot;c&quot; &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>String.trimStart()</code> and <code>String.trimEnd()</code> 減少空白字串</p>
</li>
<li><p><code>try{} catch{}</code> 可以省略 catch 回傳的表達參數 <code>catch(err){} -&gt; catch{}</code></p>
</li>
<li><p>revised Function#toString：<br>function.toString() 回傳確實的 Function 程式碼，包括空白字元和註解:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function exampleFuncton() &#123;</span><br><span class="line">  // Hello, I&apos;m an ordinary function</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(exampleFunction.toString());</span><br><span class="line">// function exampleFunction() &#123;</span><br><span class="line">//     // Hello, I&apos;m an ordinary function</span><br><span class="line">// &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Symbol Description：<br>在建構 symbol 時把 description 作第一個參數傳入，就可以通過 <code>toString()</code> 取得：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const symbolExample = Symbol(&quot;Symbol description&quot;);</span><br><span class="line">console.log(symbolExample.toString());</span><br><span class="line">// &apos;Symbol(Symbol description)&apos;</span><br></pre></td></tr></table></figure>
</li>
<li><p>JSON ⊂ ECMAScript<br>The unescaped line separator U+2028 and paragraph separator U+2029 characters were not accepted in the pre-ES10 era.</p>
</li>
<li><p>well-formed JSON.stringify<br><code>JSON.stringify()</code> may return characters between U+D800 and U+DFFF as values for which there are no equivalent UTF-8 characters. However, JSON format requires UTF-8 encoding. The proposed solution is to represent unpaired surrogate code points as JSON escape sequences rather than returning them as single UTF-16 code units.</p>
</li>
<li><p>stable <code>Array.sort()</code><br>The previous implementation of V8 used an unstable quick-sort algorithm for arrays containing more than 10 items. A stable sorting algorithm is when two objects with equal keys appear in the same order in the sorted output as they appear in the unsorted input.</p>
</li>
<li><p>新增數據資料的基本型別：<code>BigInt</code> (stage 3)<br>BigInt is the 7th primitive type: an arbitrary precision integer. The variables can now represent 253 numbers and not just max out at 9007199254740992.</p>
</li>
<li><p>Dynamic import (stage 3)<br>Dynamic <code>import()</code> returns a promise for the module namespace object of the requested module. Therefore, imports can now be assigned to a variable using async/await.</p>
</li>
<li><p>Standardized <code>globalThis</code> object (stage 3)</p>
</li>
</ul>
<hr>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="https://maksimivanov.com/posts/new-es10-es2019-javascript-features/" target="_blank" rel="noopener">What’s New in ES10? Javascript Features ES2019<br>February 16, 2019</a><br><a href="https://medium.com/@selvaganesh93/javascript-whats-new-in-ecmascript-2019-es2019-es10-35210c6e7f4b" target="_blank" rel="noopener">JavaScript: What’s new in ECMAScript 2019 (ES2019)/ES10?</a><br><a href="https://juejin.im/post/5ca2e1935188254416288eb2" target="_blank" rel="noopener">ES6、ES7、ES8、ES9、ES10新特性一览</a><br><a href="https://medium.com/better-programming/twelve-es10-features-in-twelve-simple-examples-6e8cc109f3d3" target="_blank" rel="noopener">Twelve ES10 Features in Twelve Simple Examples</a></p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="https://chinyun.github.io/myblog/myblog/2019/11/16/JS-module/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="chinyun">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/myblog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jinny's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/myblog/2019/11/16/JS-module/" class="post-title-link" itemprop="url">JS-module</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-11-16 00:19:36" itemprop="dateCreated datePublished" datetime="2019-11-16T00:19:36+00:00">2019-11-16</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-11-21 12:25:02" itemprop="dateModified" datetime="2019-11-21T12:25:02+00:00">2019-11-21</time>
              </span>
            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="什麼是-module？為什麼要用-module？"><a href="#什麼是-module？為什麼要用-module？" class="headerlink" title="什麼是 module？為什麼要用 module？"></a>什麼是 module？為什麼要用 module？</h1><h3 id="什麼是-module？"><a href="#什麼是-module？" class="headerlink" title="什麼是 module？"></a>什麼是 module？</h3><p>Modules are just clusters of code. Good authors divide their books into chapters and sections; good programmers divide their programs into modules.<br>在進行軟體專案時，複雜性總是伴隨，妥善應用抽象、介面和他們底層的概念，將某項功能的需要注意的複雜性最小化，直到他變成單一功能的分支，也就是將一個大的 program 拆分成互相依賴的小文件、再用簡單的方法拼裝起來，透過妥善設計的介面(API)讓使用者知道如何引用一個 module ，這樣的思維就是模組化開發思維。</p>
<p>Good module should be highly self-contained with distinct functionally, allowing them to be shuffled, removed, or added as neccesary, without disrupting the system as a whole.</p>
<p>透過提供一個讓系統其他部分操作的公開介面(API)，這個介面(API)裡面有元件公開的方法或屬性，那些方法和屬性也可以稱為接觸點，也就是可在介面(API)公開互動的東西。接觸點越多，需要操作的地方也越多，也有較高的彈性，因為有大量的功能，所以可能也會更難理解、使用。<br>介面(API)有兩種用途：幫助我們開發元件的新功能、讓使用介面的人(元件、系統)可以受惠於公開的功能，而不需考慮那項功能的背後細節如何實作。因此設計良好合適的介面可以增加功能開發的生產力，當我們持續使用類似的API外貌，就不需要每次都重新擬定新的設計，使用者也可以放心使用。</p>
<h3 id="為什麼要模組化開發？"><a href="#為什麼要模組化開發？" class="headerlink" title="為什麼要模組化開發？"></a>為什麼要模組化開發？</h3><p>隨著專案日漸複雜，全域變量容易互相衝突，影響專案的維護性和可拓展性。使用模組化開發方法的好處有：</p>
<ol>
<li>提升維護性 (Maintainability)</li>
<li>命名空間 (Namingspacing)</li>
<li>提供可重用性 (Reusability)</li>
</ol>
<p>在 JavaScript 中，管理變量 variable 是一切 coding 的基礎，看起來似乎是越少變量越容易管理，不過透過 scope 的概念可以讓變量在單一作用域內產生作用，不同作用域的變量便不會互相干擾，然而當你想要共用變量或資料時卻只能透過全域變量的設定，或用 callback function 將變量傳出來，設定全域變量容易產生命名衝突，而且當所有變量都需要在全域中，就必須按照一定順序編程。當需要移除舊程式碼、製作新功能時，就會有困難。所以有 module 開發的必要性。</p>
<h1 id="JavaScript-Module-History"><a href="#JavaScript-Module-History" class="headerlink" title="JavaScript Module History"></a>JavaScript Module History</h1><p>早期 JavaScript 沒有 module 體系，其他語言都有這個功能，例如：Ruby 的 require、Python 的 import，連 css 都有 @import。因為有開發上的實際需要，所以社群制定了一些 module pattern 的加載方法，最主要的有 CommonJS 和 AMD 規範，前者用於 server 後者用於 browser。 </p>
<ul>
<li><strong>AMD(Async Module Definition)</strong> 非同步載入模組規範</li>
<li><strong>CommonJS</strong> 同步模組載入規範，Node.js 遵守其規範，透過 require 進行模組同步載入，並透過 exports, module.exports 來輸出模組。主要實現為 Node.js 伺服器端的同步載入和瀏覽器端的 Browserify。</li>
<li>CMD(Common Module Definition) 依賴就近，延遲執行</li>
<li><strong>CND-Based, inline-script, Script Tags</strong> 最傳統的 <code>&lt;script&gt;&lt;/script&gt;</code>引入方式，但開發大型專案時容易產生弊端：<ul>
<li>global variable 污染、衝突</li>
<li>文件只能按照順序載入，須由開發者自行判斷模組與函式庫之間的依賴性</li>
<li>資源與版本難以維護</li>
</ul>
</li>
<li>UMD(Universal Module Definition) 為了兼容 AMD 和 CommonJS。</li>
<li><strong>ES6 Module</strong> (2015年)<br>ES6 Module 的標準中定義了 JavaScript 的模組化方式，自此產生了 JavaScript 原生的模組語法，其功能可以取代之前社群使用的規範，提供靜態的宣告式 API、以及採用 promise 的動態宣告式，在編譯時就確定 module 之間的依賴關係，以及輸出和輸入的變量。而 CommonJS 只能在運行時確定這些東西。目前 browser 和 Node.js 對 ES6 模組支援度還不完整，大部分還需要透過 babel 轉譯器進行轉譯。</li>
</ul>
<h1 id="ES6-module-現代模組化開發方法"><a href="#ES6-module-現代模組化開發方法" class="headerlink" title="ES6 module 現代模組化開發方法"></a>ES6 module 現代模組化開發方法</h1><p>在 ES6 module 中，每個檔案都是一個模組，有自己的範圍和環境，通過 <code>export</code> 命令輸出指定 code，再用 <code>import</code> 命令輸入文件。（自動採用嚴格模式）<br>過去 server 開發時會使用一個叫做 Browserify 的 module bundler， Browserify  使用 CommonJS 語法，會產生一個 bundle.js 檔案，讓我們能夠上傳並發佈網站。而現在我們會使用 <strong>ES6 module + Webpack + Babel</strong>，Webpack 也是一個類似於 Browserify 的 module bundler，但 Webpack 可以結合 Babel 轉譯器，讓瀏覽器也讀懂 ES6，並產生 bundle.js 檔案。<br>現代的模組化開發多使用以下工具(庫)：</p>
<h3 id="NPM-Node-Package-Manager"><a href="#NPM-Node-Package-Manager" class="headerlink" title="NPM (Node Package Manager)"></a>NPM (Node Package Manager)</h3><p>一個強大的套件管理工具、線上資料庫，擁有龐大的社群支持，一開始是為了 Node.js 而發展出來的套件工具，隨著發展變成開發者社群用來 share code、package 的資料庫，透過 npm 提供的指令，可以管理套件版本、加載套件、卸除套件等。使用套件做開發，簡化重複的程式碼，可以加快開發速度和提升程式維護性。</p>
<p>npm 在初始化專案時會產生一個 package.json 的檔案，裡面紀錄專案所使用的 packages 版本紀錄，透過檔案紀錄可以確保團隊工作時所有人使用的版本一致。</p>
<p>其他套件管理工具還有由 facebook 開發的 Yarn，目前也有部分人在使用。</p>
<hr>
<h3 id="Wepack"><a href="#Wepack" class="headerlink" title="Wepack"></a>Wepack</h3><p>Wepack is a static module bundler for morden JavaScript applications.<br>運行在 Node.js 環境的一個開發工具。</p>
<ul>
<li>可以使用 CommonJS + AMD + ES6 module 規範。</li>
<li>使用 import 語法和 export 的語法，在 browser 上實現模組化。</li>
<li>能夠將圖片、css 等資源，和 js 檔案都一併打包。</li>
<li>能夠編譯 Sass、Less、JS 擴充語法(JSX, Coffee Script, TypeScript)</li>
<li>可用的擴充 plugin 很多</li>
</ul>
<p>實作方法：在 <code>webpack.config.js</code> 中設定要進行 bundle 的檔案。自己編寫設定檔，透過指令去驅動的自動化工具，所有的動作都需要自己寫規則去做編譯，將我們寫好的前端框架檔案(preprocess)編譯成目前 browser 看得懂的內容並打包成一包的完整檔案，提交給 server，會在專案底下創建一個 webpack.config.js 和 index.js 檔案。</p>
<hr>
<h3 id="Babel"><a href="#Babel" class="headerlink" title="Babel"></a>Babel</h3><p>Babel is a JavaScript compiler that takes your morden JS code and returns browser compatible JS(older JS code).<br>有很多開發工具（ex:create-react-app）都自動搭載了 babel 作為轉譯工具。他也可以轉換 react 的 jsx 還有 typescript。</p>
<hr>
<h3 id="Gulp"><a href="#Gulp" class="headerlink" title="Gulp"></a>Gulp</h3><p>自動化工作流程的 library。可以 compile css 也可以 compile JavaScript。<br><a href="https://gulpjs.com" target="_blank" rel="noopener">官網</a></p>
<hr>
<h3 id="Eslint"><a href="#Eslint" class="headerlink" title="Eslint"></a>Eslint</h3><p>程式碼 coding style 檢查工具。</p>
<hr>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p>深入學習 JavaScript 模組化設計 - NICOLAS BEVACQUA 著 O’REILLY<br><a href="http://blog.turn.tw/?p=3532" target="_blank" rel="noopener">搞懂為何設定 REACT、JSX、ES2015、BABEL、WEBPACK 的學習筆記</a></p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="https://chinyun.github.io/myblog/myblog/2019/11/14/JS-Data-Structure/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="chinyun">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/myblog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jinny's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/myblog/2019/11/14/JS-Data-Structure/" class="post-title-link" itemprop="url">JS-Data Structure</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-11-14 21:34:23" itemprop="dateCreated datePublished" datetime="2019-11-14T21:34:23+00:00">2019-11-14</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-11-21 12:25:02" itemprop="dateModified" datetime="2019-11-21T12:25:02+00:00">2019-11-21</time>
              </span>
            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="JavaScript-資料結構"><a href="#JavaScript-資料結構" class="headerlink" title="JavaScript 資料結構"></a>JavaScript 資料結構</h1><p>資料結構是電腦中儲存、組織資料的方式，在 JavaScript 中，資料可以分做基本型別和物件型別，基本型別儲存一個值，物件型別儲存更複雜的資料，為了更簡便的存取複雜的資料，JavaScript 使用有規則可循的結構來管理資料。</p>
<p>The key distinctions between primitives and objects:</p>
<ul>
<li>A primitive<ul>
<li>Is a value of a primitive type.</li>
<li>There are 6 primitive types: string, number, boolean, symbol, null and undefined.</li>
</ul>
</li>
<li>An object<ul>
<li>Is capable of storing multiple values as properties.</li>
<li>Can be created with {}, for instance: {name: “John”, age: 30}. There are other kinds of objects in JavaScript: functions, for example, are objects.</li>
<li>One of the best things about objects is that we can store a function as one of its properties.</li>
</ul>
</li>
</ul>
<p>資料結構：</p>
<ul>
<li>index 管理：透過索引(index)數字，一個數字代表一個資料</li>
<li>key-value-pair：使用 key-value(通常是一個字串)對應到資料</li>
</ul>
<p>在 Ruby 語言中，使用 index 的叫做 Array，使用 key-value-pair 的叫做 Hash。<br>而在 JavaScript 中，使用 index 的也叫做 Array，使用 key-value-pair 的有兩種： Object 和 Map。</p>
<p>JavaScript 為這些資料結構內建了一些方法來方便開發者使用、管理資料:</p>
<h2 id="JavaScrip-Objects-methods-list"><a href="#JavaScrip-Objects-methods-list" class="headerlink" title="JavaScrip Objects methods list"></a>JavaScrip Objects methods list</h2><ul>
<li><p>Array 陣列</p>
<ul>
<li>其他資料結構：<ul>
<li>Stack 堆疊：last-in-first-out，支持 push, pop operation</li>
<li>Queue 佇列：first-in-first-out. A Queue is one of most common uses of an array. In computer science, this means an ordered collection of elements which supports two operations: push, shift.<br>在 JavaScript 中的 array 可以用作 queue 也可以用作 stack，從陣列的前/後來添加或刪除元素。</li>
</ul>
</li>
<li>JavaScrip 陣列內建支援的方法<ul>
<li>pop()：對 array 從尾刪除元素</li>
<li>push()：對 array 從尾添加元素</li>
<li>shift()：對 array 從頭刪除元素</li>
<li>unshift()：對 array 從頭添加元素</li>
<li>concat()：返回一個新數組：複製當前數組的所有成員並向其中添加 items。如果有任何items 是一個數組，那麼就取其元素。不會改變原 array。</li>
<li>slice(start, end)：複製並返回切下的部分，不會改變原 array。 </li>
<li>splice(index, 刪除幾個, “插入”)：返回切下的部分，會改變原 array。</li>
<li>split()：複製一組 array，將 string 轉為 array。</li>
<li>join()：複製一組 array，將 array 內容轉為 string。</li>
<li>sort()：對原 array 做排序</li>
<li>reverse()：對原 array 做倒序</li>
<li>indexOf(item, from)：從 from index 開始由右至左找 item，返回符合的第一個 index</li>
<li>lastIndexOf(item, from)：從 from index 開始由左至右找 item，返回符合的第一個 index</li>
<li>includes(item, from)：從 from index 開始由右至左找 item，返回 true/false</li>
</ul>
</li>
</ul>
</li>
<li><p>Object Array 物件陣列<br>是指陣列元素為 object 或 array 的多層結構資料。針對這種類型的資料，JavaScrip也提供一些有用的方法來協助管理：</p>
<ul>
<li>map(function(item, index, array){ 遍歷每一個元素後，返回新 array })</li>
<li>find(function(item, index, array){ 查詢到返回 true，return 第一個符合的元素 })</li>
<li>filter(function(item, index, array){ 元素通過過濾器時返回 true，return 符合元素 })</li>
<li>reduce(function(accumulator, num){})</li>
</ul>
</li>
<li><p>Object</p>
<ul>
<li>Object.assign(target, …source) 產生一個新的 object 或合併 objects</li>
<li>Object.keys(obj) 返回一個由 keys 組成的陣列</li>
<li>Object.values(obj) 返回一個由 values 組成的陣列</li>
<li>Object.entries(obj) 返回一個 key-value-pair 組成的陣列</li>
<li>自創 methods</li>
</ul>
</li>
<li><p>Map 也是 key-value-pair 物件，但是他可以直接被 iterate、 key 可以使用任何資料型別；object的 key 只能是 string。</p>
<ul>
<li>set(key, value): stores the value by the key.</li>
<li>get(key): return the value if the key exists, <code>undefined</code> if keys don’t exist.</li>
<li>has(key): return true/false whether the key exists or not</li>
<li>delete(key): remove value by the key</li>
<li>clear(): removes every thing from the set</li>
<li>size: counts the elements</li>
<li>keys()</li>
<li>values()</li>
<li>entries()</li>
</ul>
</li>
<li><p>Set is a collection of values, where each value may occur only once.</p>
<ul>
<li>add(value): add a value, return set itself.</li>
<li>delete(value): removes the value, return true/false.</li>
<li>has(value): return true/false whether the value exists or not.</li>
<li>clear(): removes every thing from the set</li>
<li>size: counts the elements</li>
<li>keys()</li>
<li>values()</li>
<li>entries()</li>
</ul>
</li>
<li><p>WeakMap &amp; WeakSet<br>通常情況下，當某數據存在於內存中時，對象的屬性或者數組的元素或其他的數據結構將被認為是可以獲取的並留存於內存。在一個正常 Map 中，我們將某對象存儲為鍵還是值並不重要。它將會被一直保留在內存中，就算已經沒有指向它的引用。</p>
<ul>
<li><p>WeakSet</p>
<ul>
<li>WeakSet 是一種特殊的 Set，它不會阻止 JavaScript 將它的元素從內存中移除。</li>
<li>它和 Set 類似，但是我們僅能將對象添加進 WeakSet（不可以是基礎類型）</li>
<li>僅當對象存在其他位置的引用時它才存在於 set 中。</li>
<li>支持 add()、has() 和 delete()，不支持 size、keys() 也不支持迭代器。</li>
</ul>
</li>
<li><p>WeakMap</p>
<ul>
<li>WeakMap 也不會阻止 JavaScript 將它的元素從內存中移除，而且它和 Map 的區別是它的鍵必須是對象，不能是基礎類型的值。</li>
<li>支持 get(key)、set(key, value)、delete(key, value)、has(key)</li>
<li>但不支持 keys()、values()、entries()，我們不能對它進行迭代，所以沒有辦法獲取它的所有鍵值。</li>
<li>WeakMap 的目的是，我們可以僅<strong>當該對象存在時，為對象存儲一些內容</strong>。但我們並不會因為存儲了對象的一些內容，就強制對像一直保留在內存中。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="基本型別的-methods-list"><a href="#基本型別的-methods-list" class="headerlink" title="基本型別的 methods list"></a>基本型別的 methods list</h2><p>There are many things one would want to do with a primitive. So JavaScript provides methods to call. JavaScript allows us to work with primitives (strings, numbers, etc.) as if they were objects. </p>
<p>The solution is:<br>The “object wrappers” are different for each primitive type and are called: String, Number, Boolean and Symbol. Thus, they provide different sets of methods.</p>
<p>JavaScript 允許訪問字符串，數字，布爾值和符號的方法和屬性。當進行訪問時，創建一個特殊的“包裝對象”，它提供額外的功能，運行後即被銷毀。除 null 和 undefined 以外的基本類型都提供了許多有用的方法。從形式上講，這些方法通過臨時對象工作，但 JavaScript 引擎可以很好地調整以優化內部，因此調用它們並不需要太高的成本。</p>
<ul>
<li><p>Number<br>JavaScript 有一個內置的 Math 對象，它包含了一個小型的數學函數和常量庫。</p>
<ul>
<li>Math.random()</li>
<li>Math.max(a, b, c…) / Math.min(a, b, c…)</li>
<li>Math.pow(n, power)<br>分數可使用(須記住使用分數時會損失精度):</li>
<li>Math.floor 向下舍入，3.1 變成 3，-1.1 變成 -2。</li>
<li>Math.ceil 向上舍入，3.1 變成 4，-1.1 變成 -1。</li>
<li>Math.trunc 刪除小數點後的所有內容而不捨入：3.1 變成 3，-1.1 變成-1，IE 瀏覽器不支援。</li>
<li>Math.round 向最近的整數舍入：3.1 變成 3，3.6變成4，-1.1變成-1。</li>
<li>num.toFixed(precision) 將點數後的數字四捨五入到 n 個數字並返回結果以字符串表示<br>檢查是否為特殊 Number？</li>
<li>isNaN</li>
<li>isFinite<br>檢視字符串並返回 Number：他們從字符串中“讀出”一個數字。如果發生錯誤，則返回收集的數字。有時候 parseInt / parseFloat 會返回 NaN。一般發生在沒有數字可讀的情況下。</li>
<li>parseInt(str, radix) 返回整數。第二個參數指定了數字系統的基礎，因此 parseInt 還可以解析十六進制數字，二進制數字等字符串。</li>
<li>parseFloat() 可以返回浮點數</li>
</ul>
</li>
<li><p>String</p>
<ul>
<li>string.length 字符串長度</li>
<li>string[0] 或 string.charAt(0):<br>如果沒有找到字符，[] 返回 undefined，而 charAt 返回一個空字符串</li>
<li>toLowerCase()</li>
<li>toUpperCase()</li>
<li>trim() 刪除前後的空格</li>
<li>查找字符的方法：<ul>
<li>indexOf(substr, pos)</li>
<li>includes(substr, pos)</li>
<li>endsWith()</li>
<li>startsWith()</li>
</ul>
</li>
<li>獲取字符串的方法：<ul>
<li>slice(start [, end]) 返回從 start 到（但不包括）end 的字符串部分。</li>
<li>substring(start [, end]) 返回 start 和 end 之間的字符串部分。這與 slice 幾乎相同，但它允許 start 大於 end。</li>
<li>substr(start [, length]) 從 start 開始返回給定 length 的字符串部分。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="https://zh.javascript.info/map-set-weakmap-weakset" target="_blank" rel="noopener">javascript.info/map-set-weakmap-weakset</a><br><a href="https://javascript.info/primitives-methods" target="_blank" rel="noopener">javascript.info/primitives-methods</a></p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="https://chinyun.github.io/myblog/myblog/2019/11/13/JS-Shallow-Copy-Deep-Copy/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="chinyun">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/myblog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jinny's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/myblog/2019/11/13/JS-Shallow-Copy-Deep-Copy/" class="post-title-link" itemprop="url">JS-Shallow Copy & Deep Copy</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-11-13 19:12:02" itemprop="dateCreated datePublished" datetime="2019-11-13T19:12:02+00:00">2019-11-13</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-11-21 12:25:02" itemprop="dateModified" datetime="2019-11-21T12:25:02+00:00">2019-11-21</time>
              </span>
            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="為什麼會有深淺拷貝的差異？"><a href="#為什麼會有深淺拷貝的差異？" class="headerlink" title="為什麼會有深淺拷貝的差異？"></a>為什麼會有深淺拷貝的差異？</h1><p>因為 JavaScript 中，基本型別(primitve)與物件型別(object)的值的賦予方式不同，基本型別是 pass by value，物件型別是 pass by sharing。相關介紹可看：<a href="https://chinyun.github.io/myblog/2019/11/13/JS-pass-by-value-or-reference/">JS-pass by value or reference</a></p>
<p>因為值賦予方式的差異，在複製物件例如 object, array 等資料類型時，根據拷貝資料的形式，可以分為淺拷貝(shallow copy)及深拷貝(deep copy)。<br>對淺拷貝來說，只是複製 collection structure，而不是 element，With a shallow copy, two collections now share the individual elements. Collections can be diverse data structures which stores multiple data items.<br>因此對於基本型別來說，淺拷貝(用等號賦值)會傳值，但對物件型別來說，淺拷貝是傳遞 reference，讓兩者可以共用一個記憶體的物件資料，這樣的話在指派物件型別的資料的第二層或更深層內容時，會同時影響兩個地方。</p>
<p>淺拷貝只複製指向某個物件的指標，而不複製物件本身，新舊物件還是共用同一塊記憶體。<br>而深拷貝是整個複製，包含element，會另外創造一個一模一樣的物件，新物件跟原物件不共用記憶體，修改新物件不會改到原物件。所以當我們在使用有多層結構的物件資料時，要盡量用深拷貝。<br>一般物件如果用等號賦值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var obj1 = &#123; a: 10, b: 20, c: 30 &#125;;</span><br><span class="line">var obj2 = obj1;</span><br><span class="line">obj2.b = 100;</span><br><span class="line"></span><br><span class="line">console.log(obj1); // &#123; a: 10, b: 100, c: 30 &#125; &lt;-- b 被改到了</span><br><span class="line">console.log(obj2); // &#123; a: 10, b: 100, c: 30 &#125;</span><br></pre></td></tr></table></figure>

<h1 id="如何進行淺拷貝、深拷貝？"><a href="#如何進行淺拷貝、深拷貝？" class="headerlink" title="如何進行淺拷貝、深拷貝？"></a>如何進行淺拷貝、深拷貝？</h1><p>一般而言 基本型別的拷貝方法就是用 等號賦值，而物件型別例如 array 或 object等就有很多方式，依照拷貝的層次深度可以分為淺拷貝和深拷貝：如果物件中屬性的值也是物件，只能複製到<strong>第一層</strong>物件的屬性，而無法複製到屬性值的物件(第二層)，就無法達到實際的複製，而是會與舊物件一起共用同一塊記憶體；這樣的複製方法稱為「淺拷貝」。相反地，深拷貝會另外創造一個一模一樣的物件，新物件跟原物件不共用記憶體，修改新物件不會改到原物件。</p>
<ul>
<li><p>淺拷貝方法</p>
<ul>
<li><p><strong>Array.concat</strong>：一般Array.concat的用法是合併兩個陣列</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  var alpha = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;],</span><br><span class="line">    numeric = [1, 2, 3];</span><br><span class="line">  var alphaNumeric = alpha.concat(numeric);</span><br><span class="line">​  console.log(alphaNumeric); // [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, 1, 2, 3]</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Array.slice</strong>：一般Array.slice()的方法是複製一個新的陣列，可帶入參數 <code>Array.slice(start, end)</code>，當不輸入參數值的話會直接複製一個。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var animals = [&apos;ant&apos;, &apos;bison&apos;, &apos;camel&apos;, &apos;duck&apos;, &apos;elephant&apos;];</span><br><span class="line">console.log(animals.slice(2));</span><br><span class="line">// Array [&quot;camel&quot;, &quot;duck&quot;, &quot;elephant&quot;]</span><br><span class="line">​</span><br><span class="line">console.log(animals.slice(2, 4));</span><br><span class="line">// Array [&quot;camel&quot;, &quot;duck&quot;]</span><br><span class="line">​</span><br><span class="line">console.log(animals.slice());</span><br><span class="line">// Array [&apos;ant&apos;, &apos;bison&apos;, &apos;camel&apos;, &apos;duck&apos;, &apos;elephant&apos;];</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>手動複製</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var obj1 = &#123; a: 10, b: 20, c: 30 &#125;;</span><br><span class="line">var obj2 = &#123; a: obj1.a, b: obj1.b, c: obj1.c &#125;;</span><br><span class="line">obj2.b = 100;</span><br><span class="line"></span><br><span class="line">console.log(obj1); // &#123; a: 10, b: 20, c: 30 &#125; &lt;-- 沒被改到</span><br><span class="line">console.log(obj2); // &#123; a: 10, b: 100, c: 30 &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Object.assign</strong>：用來合併物件，用法為 <code>Object.assign(target, ...source)</code>若目標物件為空物件則可視為複製一個source的物件。<br><code>Object.assign({}, obj1)</code>的意思是先建立一個空物件{}，接著把obj1中所有的屬性複製過去，因為Object.assign跟我們手動複製的效果相同，所以一樣<strong>只能處理深度只有一層的物件</strong>，沒辦法做到真正的 Deep Copy，不過如果要複製的物件只有一層的話可以使用他。</p>
</li>
<li><p><strong>展開運算子(Spread Operator)</strong> 也只能實現一層的拷貝</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let obj = &#123;name:&apos;john&apos;, age:&#123;child: 18&#125;&#125;</span><br><span class="line">let copy = &#123;...obj&#125;;</span><br><span class="line"></span><br><span class="line">copy.name = &apos;mike&apos;;</span><br><span class="line">copy.age.child = 99;</span><br><span class="line"></span><br><span class="line">console.log(obj);  //&#123;name:&quot;john&quot;, age:&#123;child: 99&#125;&#125;</span><br><span class="line">console.log(copy); //&#123;name:&quot;mike&quot;, age:&#123;child: 99&#125;&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>深拷貝方法</p>
<ul>
<li><p><strong>JSON.parse(JSON.stringify(object_array))</strong>:</p>
<ul>
<li>JSON.parse():把字串轉成物件</li>
<li>JSON.stringify():把物件轉成字串<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">  let obj1 = &#123; a:&#123;b:10&#125; &#125;;</span><br><span class="line">  let obj2_string = JSON.stringify(obj1);</span><br><span class="line">  console.log(obj2_string); //&quot;&#123;&quot;a&quot;:&#123;&quot;b&quot;:10&#125;&#125;&quot;;</span><br><span class="line">​</span><br><span class="line">  let obj2 = JSON.parse(obj2_string);</span><br><span class="line">  console.log(obj2); //&#123;a:&#123;b:10&#125;&#125;</span><br><span class="line">​</span><br><span class="line">  obj2.a.b = 20;</span><br><span class="line">  console.log(obj1); //&#123;a:&#123;b:10&#125;&#125;</span><br><span class="line">  console.log(obj2); //&#123;a:&#123;b:20&#125;&#125;</span><br><span class="line">  ``` </span><br><span class="line"></span><br><span class="line">  只有可以轉成JSON格式的物件才可以這樣用，像 function、Set、Map..等型態就沒辦法轉成 JSON。</span><br><span class="line"></span><br><span class="line">- **jQuery `$.extend`**</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>var $ = require(‘jquery’);<br>var obj1 = {<br>  a: 1,<br>  b: { f: { g: 1 } },<br>  c: [1, 2, 3]<br>};<br>var obj2 = $.extend(true, {}, obj1);<br>console.log(obj1.b.f === obj2.b.f); // false</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- **lodash `_.cloneDeep`**</span><br></pre></td></tr></table></figure>

<p>var _ = require(‘lodash’);<br>var obj1 = {<br>  a: 1,<br>  b: { f: { g: 1 } },<br>  c: [1, 2, 3]<br>};<br>var obj2 = _.cloneDeep(obj1);<br>console.log(obj1.b.f === obj2.b.f); // false</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- **自己寫**</span><br><span class="line">  例如下面這個在 react app 裡面用 slice() 和 Object.assign(target, ...sources) 來改變深層結構資料的方法：</span><br><span class="line">  [GitHub Repo:Tripper-app](https://github.com/chinyun/Tripper-app/blob/master/src/containers/App.js)</span><br></pre></td></tr></table></figure>

<p>updateBudgets = (journey, journeyId) =&gt; {<br>  const index = this.state.journeyList.findIndex(item =&gt; item.id === journeyId);<br>  if (index !== -1) {</p>
<pre><code>this.setState({
  journeys: [
    ...this.state.journeys.slice(0, index),
    Object.assign({}, this.state.journeys[index], journey[0]),
    ...this.state.journeys.slice(index + 1)
  ]
})</code></pre><p>  }<br>};</p>
<pre><code></code></pre></li>
</ul>
</li>
</ul>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="https://dustinhsiao21.com/2018/01/07/javascript-shallow-copy-and-deep-copy/" target="_blank" rel="noopener">關於JAVASCRIPT中的SHALLOW COPY(淺拷貝)及DEEP COPY(深拷貝)</a><br><a href="https://larry850806.github.io/2016/09/20/shallow-vs-deep-copy/" target="_blank" rel="noopener">[Javascript] 關於 JS 中的淺拷貝和深拷貝</a></p>
<h1 id="延伸閱讀"><a href="#延伸閱讀" class="headerlink" title="延伸閱讀"></a>延伸閱讀</h1><p><a href="https://chinyun.github.io/myblog/2019/10/12/React-Updating-state-when-state-is-an-array-of-objects/">React: Updating state when state is an array of objects</a></p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="https://chinyun.github.io/myblog/myblog/2019/11/13/JS-pass-by-value-or-reference/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="chinyun">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/myblog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jinny's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/myblog/2019/11/13/JS-pass-by-value-or-reference/" class="post-title-link" itemprop="url">JS-pass by value or reference</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-11-13 17:35:56" itemprop="dateCreated datePublished" datetime="2019-11-13T17:35:56+00:00">2019-11-13</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-11-21 12:25:02" itemprop="dateModified" datetime="2019-11-21T12:25:02+00:00">2019-11-21</time>
              </span>
            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>問題：JavaScript 到底是 pass by value 還是 pass by referece？</p>
<p>根據 JavaScript 的資料型態，可以分為兩大類：基本型別 primitive 和 物件型別 object。<br>基本型別的資料以 純值的形態存在，例如：number、string、boolean、null、undefined、symbol，而 object 的資料可能為 純值 或 多種不同型別組合而成的 物件。</p>
<h1 id="基本型別傳值-pass-by-value，Object-型別傳址-pass-by-referece"><a href="#基本型別傳值-pass-by-value，Object-型別傳址-pass-by-referece" class="headerlink" title="基本型別傳值 pass by value，Object 型別傳址 pass by referece"></a>基本型別傳值 pass by value，Object 型別傳址 pass by referece</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var a = 10;</span><br><span class="line">var b = a;</span><br><span class="line">console.log(a === b); //true</span><br><span class="line"></span><br><span class="line">var c = 5;</span><br><span class="line">var d = 5;</span><br><span class="line">console.log(c === d); //true</span><br></pre></td></tr></table></figure>

<p><code>var b = a;</code> 表面上看起來變數 b 的內容是透過複製變數 a 而來，實際上變數 b 是去建立了一個新的值，然後將變數 a 的內容複製了一份存放到記憶體， a 和 b 其實是存在於兩個不同的記憶體位置，因此變數 a 和變數 b 彼此獨立互不相干，即使更改 a 的內容， b 的值也不會變：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a + 2;</span><br><span class="line">console.log(a); //12</span><br><span class="line">console.log(b); //10</span><br></pre></td></tr></table></figure>

<p>基本型別是不可變的 (immutable)，當修改、更新值時，與那個值的副本完全無關，像這種情況，我們通常稱作「傳值」 (pass by value)。</p>
<p>如果是物件型別的資料：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var obj1 = &#123; a: 10 &#125;;</span><br><span class="line">var obj2 = &#123; a: 10 &#125;;</span><br><span class="line">console.log(obj1 === obj2); //false</span><br><span class="line"></span><br><span class="line">var obj3 = &#123; b: 20 &#125;;</span><br><span class="line">var obj4 = obj3;</span><br><span class="line">console.log(obj3 === obj4); //true</span><br></pre></td></tr></table></figure>

<p>「物件」這類資料型態，在 JavaScript 中是透過「引用」的方式傳遞資料的。<br>當建立起一個新的物件並賦值給一個變數(<code>var obj3 = { b: 20 };</code>)的時候，JavaScript 會在記憶體的某處存放這個物件(<code>{ b: 20 }</code>)，再將變數(<code>obj3</code>)指向這個物件的存放位置，因此當<code>var obj4 = obj3;</code>的時候，其實是將 obj4 這個變數也指向了 <code>{ b: 20 }</code>這個實體。<br>這種透過引用的方式來傳遞資料，接收的其實是引用的「參考」而不是值的副本時，<br>我們通常會稱作「傳址」 (pass by reference)。</p>
<h1 id="特殊情況："><a href="#特殊情況：" class="headerlink" title="特殊情況："></a>特殊情況：</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var coin1 = &#123; value: 10 &#125;;</span><br><span class="line"></span><br><span class="line">function changeValue(obj) &#123;</span><br><span class="line">  obj = &#123; value: 123 &#125;;</span><br><span class="line">&#125;</span><br><span class="line">changeValue(coin1);</span><br><span class="line">console.log(coin1.value);   // ？</span><br></pre></td></tr></table></figure>

<p>答案會是 10，因為當coin1指向的資料被做為 <strong>function 的參數</strong>傳入 function 時，即使資料在 function 內部被重新賦值，外部變數的內容都不會被影響。<br>在這種情況底下， JavaScript 會將 obj 指向一個新建的 object <code>{ value: 123 }</code>，不會影響到外部的 coin1 指向的位址的物件內容。</p>
<p>如果不是 重新賦址 而是 修改傳入 的內容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var coin1 = &#123; value: 10 &#125;;</span><br><span class="line">function changeValue(obj) &#123;</span><br><span class="line">  obj.value = 123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">changeValue(coin1);</span><br><span class="line">console.log(coin1.value);   // 123</span><br></pre></td></tr></table></figure>

<p>此時變數 coin1 所指向的資料內容被改變，傳入 function 作為 obj 參數的值的 coin1 在 function 內被修改，改變了 value 的值。</p>
<h1 id="垃圾回收-Garbage-collection"><a href="#垃圾回收-Garbage-collection" class="headerlink" title="垃圾回收 Garbage collection"></a>垃圾回收 Garbage collection</h1><p>對於開發者來說，JavaScript 的內存管理是自動的、無形的。我們創建的原始值、對象、函數……這一切都會佔用內存。當某個東西我們不再需要時會發生什麼？ JavaScript 引擎如何發現它、清理它？<br>JavaScript 中主要的內存管理概念是<strong>可達性 Reachability</strong>，簡言之，可達值是那些以某種方式可訪問或可用的值，它們保證存儲在內存中。<br>這裡列出固有的可達值基本集合，這些值明顯不能被釋放：</p>
<ol>
<li>當前函數的局部變數和參數。Local variables and parameters of the current function.</li>
<li>嵌套調用時，當前調用鏈上所有函數的變量與參數。Variables and parameters for other functions on the current chain of nested calls.</li>
<li>全局變數。Global variables.</li>
<li>還有一些其他的內部變數。(there are some other, internal ones as well)</li>
</ol>
<p>這些值被稱作根 root。</p>
<p>如果一個值可以通過 引用 或 引用鏈，從根值訪問到，則認為這個值是 可達的。<br>比方說，如果局部變量中有一個對象，並且該對象具有引用另一個對象的 property，則該對像被認為是可達的。而且它引用的內容也是可達的。</p>
<p>在 JavaScript 引擎中有一個被稱作垃圾回收器(garbage collector)的東西在後台執行。它監控著所有對象的狀態，並刪除掉那些已經不可達的。</p>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="https://blog.techbridge.cc/2018/06/23/javascript-call-by-value-or-reference/" target="_blank" rel="noopener">深入探討 JavaScript 中的參數傳遞：call by value 還是 reference？</a><br><a href="https://ithelp.ithome.com.tw/articles/10191057" target="_blank" rel="noopener">重新認識 JavaScript: Day 05 JavaScript 是「傳值」或「傳址」？</a><br><a href="https://zh.javascript.info/garbage-collection" target="_blank" rel="noopener">Garbage collection</a><br><a href="https://pjchender.blogspot.com/2016/03/javascriptby-referenceby-value.html" target="_blank" rel="noopener">[筆記] 談談 JavaScript 中 by reference 和 by value 的重要觀念</a></p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="https://chinyun.github.io/myblog/myblog/2019/11/12/JS-hoisting-scope-closure/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="chinyun">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/myblog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jinny's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/myblog/2019/11/12/JS-hoisting-scope-closure/" class="post-title-link" itemprop="url">JS hoisting,scope,closure</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-11-12 19:59:07" itemprop="dateCreated datePublished" datetime="2019-11-12T19:59:07+00:00">2019-11-12</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-11-21 12:25:02" itemprop="dateModified" datetime="2019-11-21T12:25:02+00:00">2019-11-21</time>
              </span>
            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Hoisting、Scope 和 Closure 在 JavaScript 中是很重要的觀念，因爲會影響我們如何撰寫 JavaScript。了解這三個概念可以幫助我們了解 JaveScript 在內文執行的運作原理，尤其是在創建和執行階段，JaveScript 的執行機制會如何理解我們寫的程式碼，並跑出我們想要的結果。</p>
<h1 id="Hoisting"><a href="#Hoisting" class="headerlink" title="Hoisting"></a>Hoisting</h1><p>JavaScript 內文執行的運作方式有一個機制叫做：Hoisting 提升，在執行任何程式碼前，JavaScript 會把<strong>變數和函數的宣告</strong>在編譯階段就放入記憶體，編譯後執行時因為已經宣告了，所以如此即便我們先寫調用某一函式的程式碼，再寫該函式的內容，JavaScript 也還是可以知道這段程式碼的意義，程式碼仍然可以運作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">catName(&quot;Chloe&quot;);</span><br><span class="line"></span><br><span class="line">function catName(name) &#123;</span><br><span class="line">  console.log(&quot;My cat&apos;s name is &quot; + name);</span><br><span class="line">&#125;</span><br><span class="line">/*上面程式的結果是: &quot;My cat&apos;s name is Chloe&quot;*/</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">num = 6;</span><br><span class="line">num + 7;</span><br><span class="line">var num; </span><br><span class="line">/* 只要 num 有被宣告，就不會有錯誤 */</span><br></pre></td></tr></table></figure>

<p>JavaScript 僅提升宣告的部分，而尚未賦值。如果在使用該變數後才宣告和初始化，那麼該值將是 undefined，以下範例顯示了這個特性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var x = 1; // 給予 x 值</span><br><span class="line">console.log(x + &quot; &quot; + y);  // &apos;1 undefined&apos;，此階段 y 尚未被賦予值</span><br><span class="line">var y = 2;</span><br></pre></td></tr></table></figure>

<p>上述程式碼其實是這樣運作的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var x = 1; </span><br><span class="line">var y; // 宣告 y</span><br><span class="line">console.log(x + &quot; &quot; + y);  // &apos;1 undefined&apos;</span><br><span class="line">y = 2; // 賦值 y</span><br></pre></td></tr></table></figure>

<p><strong>函數宣告的優先權比變數宣告高</strong>，如果 function 調用時有傳參數進來，就會先宣告該參數代表的變數意義並賦值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function test(v) &#123;</span><br><span class="line">  var v</span><br><span class="line">  console.log(v)</span><br><span class="line">  v = 3</span><br><span class="line">&#125;</span><br><span class="line">test(10) // 10</span><br></pre></td></tr></table></figure>

<p>需要注意的是，<strong>只有 declaration 宣告式的 function (ex:<code>function func(){...}</code>)會被在編譯階段提升</strong>，而 expression 表達式宣告的 function (ex:<code>let func = function(){...}</code>)會在執行階段才被存放到記憶體中。</p>
<h1 id="Scope-作用域"><a href="#Scope-作用域" class="headerlink" title="Scope 作用域"></a>Scope 作用域</h1><ul>
<li>Execution Context 執行環境<br>要了解 Scope 須先知道 <strong>Execution Context 執行環境</strong> 的概念。<br>Execution Context is a fancy word for describing the environment in which your Javascript code runs.</li>
</ul>
<p>當 JavaScript engine start up 程式碼準備好開始運行時，就會先建立 <strong>global execution context全域執行環境</strong>，然後建立一個 global object 和 this，在 browser 的環境中，global object 是 window， this === window，在 node.js 環境中， global object 是 global，this === global。<br>我們可以 assign variable、function 到 global object 中。</p>
<p>執行環境在建立時會經歷兩個階段，分別是 ：</p>
<ul>
<li>Creation Phase 創造階段：變數宣告和函數宣告提升，自動跳過函式裡的程式碼。</li>
<li>Execution Phase 執行階段：由上到下、一行一行地執行程式，賦值也是在這階段。</li>
</ul>
<p>當 JavaScript engine 看到 function name() 函數被執行，就會創建一個 function name() execution context，新的 function execution context 會被加入到<strong>Execution stack 執行堆疊</strong>，並依序執行(Javascript 是單一執行緒，一次只能做一件事)，執行環境 的堆疊過程是具有 順序性 的：first in last out。</p>
<ul>
<li>Scope 作用域是什麼？</li>
</ul>
<p><strong>Scope determines the accessibility (visibility) of variables.</strong> Scope is where can I access the variable where’s that variable in my code. It just defines the accessibility of variables and functions in the code. JavaScript has function scope: Each function creates a new scope. Variables defined inside a function are not accessible (visible) from outside the function.</p>
<p>Scope 可以說是一個變數的生存範圍，出了這個範圍就無法存取到。在 JavaScript 裡面，可以分為兩種 Scope 作用域：</p>
<ul>
<li>Global Scope：表示全域、任何地方都能存取得到</li>
<li>Lexical Scope：variable 被寫下來的那個地方，就是作用域<ul>
<li>function scope</li>
<li>block scope<br>it means that only by looking at the source code we can determine which environment the variables in data are avaliable in.<br>這與 Lexical Environment 有關，在物理上我們將 code 寫在哪裡，那就是該 variable 或 function 的 Lexical Environment。 In JS our lexical scope (avalible data + variables where the function was defined) determines our avalible variables. Not the function is called.(相反地，有一種叫做 Dynamic scope 的作用域機制 就是在程式執行時才動態決定的) </li>
</ul>
</li>
</ul>
<ul>
<li>Scope Chain<br>透過程式碼層層的包裹，由內而外，直到 global scope 的這一條 scope chain，可以幫助找到要找的對象(通常是 variables)被寫下的地方(lexical environment)。</li>
</ul>
<p>在 ES6 以前，唯一產生作用域的方法就是 function，每一個 function 都有自己的作用域，在作用域外面你就存取不到這個 function 內部所定義的變數，然而 ES6 的時候引入了 let 跟 const，多了 block-scope 的概念。<br>延伸：<a href="https://cythilya.github.io/2016/10/28/es6-let-const-block-level-scope/" target="_blank" rel="noopener">ES6: let, const, Block-Level Scope</a></p>
<p>因應ES6的出現，使用上建議大家不要再用var來宣告變數，改用let與const，而且優先使用const。<br>因為const在宣告時必須給定值，並且不能再被更改，這可以有效降低出現錯誤的機會。<br>同理，如果是需要變更的數值則改用作用範圍較小的let做宣告，來減少錯誤出現的機率，Ex: for迴圈。<br>– <a href="https://www.iware.com.tw/blog-JavaScript%20%E5%AE%A3%E5%91%8A:%20var%E3%80%81let%E3%80%81const.html" target="_blank" rel="noopener">JavaScript 宣告: var、let、const</a></p>
<h1 id="Closure-閉包"><a href="#Closure-閉包" class="headerlink" title="Closure 閉包"></a>Closure 閉包</h1><p>「閉包（英語：Closure），又稱詞法閉包（Lexical Closure）或函式閉包（function closures），是參照了自由變數的函式。這個被參照的自由變數將和這個函式一同存在，即使已經離開了創造它的環境也不例外。閉包是由函式和與其相關的參照環境組合而成的實體。」–wiki<br>每個宣告的 function 都會儲存著[[Scope]]，而這個資訊裡面就是參照的環境。<br>「that all functions, independently from their type: anonymous, named, function expression or function declaration, because of the scope chain mechanism, are closures.</p>
<p>from the theoretical viewpoint: all functions, since all they save at creation variables of a parent context. Even a simple global function, referencing a global variable refers a free variable and therefore, the general scope chain mechanism is used;<br>from the practical viewpoint: those functions are interesting which:</p>
<ul>
<li>continue to exist after their parent context is finished, e.g. inner functions returned from a parent function;</li>
<li>use free variables.」–<a href="http://dmitrysoshnikov.com/ecmascript/chapter-6-closures/" target="_blank" rel="noopener">ECMA-262-3 in detail. Chapter 6. Closures.</a></li>
</ul>
<p>scopeChain 把每一層的 AO 和 VO 記錄下來，而變數就紀錄在AO 或 VO 裡，也因為 return 才把 AO 和 VO 保留下來。<br>closure 其實就是因為 scopeChain 有 reference 到其他 Execution Context 的 AO(active object) 或是 VO(variable object)，所以在離開之後還是可以存取到上層的變數，如果你是以會記住上層資訊的角度來看 closure，那所有的 function 其實都是 closure。</p>
<ul>
<li><p><strong>閉包是函式記得並存取 Lexical Scope 語彙範疇的能力，可說是指向特定 scope 的參考，因此當函式是在其宣告的 Lexical Scope 語彙範疇之外執行時也能正常運作</strong>。</p>
</li>
<li><p>迴圈與閉包搭配使用時的謬誤與陷阱。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for (var i = 1; i &lt;= 5; i++) &#123;</span><br><span class="line">  setTimeout(function timer() &#123;</span><br><span class="line">    console.log(i);</span><br><span class="line">  &#125;, i * 1000 );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由於 console.log(i) 中的 i 會存取的範疇是 for 所在的範疇（目前看起來是全域範疇，因為 var 宣告的變數不具區塊範疇的特性），因此當 1 秒、2 秒…5 秒後執行 console.log(i) 時，就會去取 i 的值，而此時 for 迴圈已跑完，i 變成 6，因此就會每隔一秒印出一個「6」。<br>解決方法可以利用 IIFE（Immediately Invoked Function Expression）把一個 function 包起來並傳入 i 立即執行，所以迴圈每跑一圈其實就會立刻呼叫一個新的 function，因此就產生了新的作用域。不過在 ES6 裡面有了 block scope 的概念以後，你只要簡單地把迴圈裡面用的 var 改成 let 就行了：因為 let 的特性，所以其實迴圈每跑一圈都會產生一個新的作用域。</p>
</li>
<li><p>模組模式可經由<strong>建立一個模組實體來調用內層函式，而內層函式由於具有閉包的特性，因此可存取外層的變數和函式。透過模組模式，可隱藏私密資訊，並選擇對外公開的 API</strong>。</p>
</li>
<li><p>利用模組依存性載入器或管理器或 ES6 模組來管理模組。</p>
</li>
</ul>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="https://developer.mozilla.org/zh-TW/docs/Glossary/Hoisting" target="_blank" rel="noopener">提升（Hoisting）</a><br><a href="https://github.com/aszx87410/blog/issues/34#" target="_blank" rel="noopener">我知道你懂 hoisting，可是你了解到多深？</a><br><a href="https://medium.com/%E9%AD%94%E9%AC%BC%E8%97%8F%E5%9C%A8%E7%A8%8B%E5%BC%8F%E7%B4%B0%E7%AF%80%E8%A3%A1/%E6%B7%BA%E8%AB%87-javascript-%E5%9F%B7%E8%A1%8C%E7%92%B0%E5%A2%83-2976b3eaf248" target="_blank" rel="noopener">秒懂！JavaSript 執行環境與堆疊</a><br><a href="https://www.w3schools.com/js/js_scope.asp" target="_blank" rel="noopener">W3C</a><br><a href="https://github.com/aszx87410/blog/issues/35" target="_blank" rel="noopener">所有的函式都是閉包：談 JS 中的作用域與 Closure</a><br><a href="https://cythilya.github.io/2018/10/22/closure/" target="_blank" rel="noopener">你懂 JavaScript 嗎？#15 閉包（Closure）</a><br><a href="https://github.com/healthyspi/weekly-notes/issues/8" target="_blank" rel="noopener">[2019-10-12] 進階 JavaScript - Closure </a><br><a href="https://openhome.cc/Gossip/JavaScript/Closure.html" target="_blank" rel="noopener">閉包（Closure）</a></p>
<blockquote>
<p>閉包也會用來作為物件私用（private）的模擬，以及名稱空間的管理等</p>
</blockquote>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="https://chinyun.github.io/myblog/myblog/2019/11/11/JS-this/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="chinyun">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/myblog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jinny's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/myblog/2019/11/11/JS-this/" class="post-title-link" itemprop="url">JS this</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-11-11 23:25:13" itemprop="dateCreated datePublished" datetime="2019-11-11T23:25:13+00:00">2019-11-11</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-11-21 12:25:02" itemprop="dateModified" datetime="2019-11-21T12:25:02+00:00">2019-11-21</time>
              </span>
            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="this"><a href="#this" class="headerlink" title="this"></a>this</h1><p>在物件導向程式語言裡面，this 概念指的是 instance 本身。<br>舉例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Car &#123;</span><br><span class="line">  setName(name) &#123;</span><br><span class="line">    this.name = name</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  getName() &#123;</span><br><span class="line">    return this.name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">const myCar = new Car()</span><br><span class="line">myCar.setName(&apos;hello&apos;)</span><br><span class="line">console.log(myCar.getName()) // hello</span><br></pre></td></tr></table></figure>

<p>然而和一般物件導向的程式語言 Java 或 C++ 等不同，在 JavaScript 裡面，你在任何地方都可以存取到 this，所以在 JavaScript 裡的 this 跟其他程式語言慣用的那個 this 有了差異，這就是為什麼 this 難懂的原因。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function hello()&#123;</span><br><span class="line">  console.log(this)</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">hello()</span><br></pre></td></tr></table></figure>

<p>一旦脫離了物件導向，也就是在 class 外面的 this，其實沒有太大的意義。<br>在這種很沒意義的情況下，this 的值在瀏覽器底下就會是 <code>window</code>，在 node.js 底下會是 <code>global</code>，如果是在嚴格模式，this 的值就會是 <code>undefined</code>。這個規則就是所謂的「預設綁定」。</p>
<h2 id="this-值的改變"><a href="#this-值的改變" class="headerlink" title="this 值的改變"></a>this 值的改變</h2><ul>
<li><p>可以用 call、apply 與 bind 改變 this 的值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&apos;use strict&apos;;</span><br><span class="line">function hello(a, b) &#123;</span><br><span class="line">  console.log(this, a, b)</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">hello.call(&apos;yo&apos;, 1, 2) // yo 1 2</span><br><span class="line">hello.apply(&apos;hihihi&apos;, [1, 2]) // hihihi 1 2</span><br></pre></td></tr></table></figure>

<p>call 跟 apply 的差別就是 apply 在傳參數時要用 array 包起來。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Car &#123;</span><br><span class="line">  hello() &#123;</span><br><span class="line">    console.log(this)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">const myCar = new Car()</span><br><span class="line">myCar.hello() // myCar instance</span><br><span class="line">myCar.hello.call(&apos;yaaaa&apos;) // yaaaa</span><br></pre></td></tr></table></figure>

<p>可以把原本的 this 值覆蓋掉。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&apos;use strict&apos;;</span><br><span class="line">function hello() &#123;</span><br><span class="line">  console.log(this)</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">const myHello = hello.bind(&apos;my&apos;)</span><br><span class="line">myHello() // my</span><br><span class="line">myHello.call(&apos;call&apos;) // my</span><br></pre></td></tr></table></figure>

<p>使用 bind 之後，call 方法也沒有辦法覆蓋掉。<br>如果是在<strong>非嚴格模式</strong>底下，無論是用 call、apply 還是 bind，你傳進去的如果是 primitive 都會被轉成 object：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function hello() &#123;</span><br><span class="line">  console.log(this)</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">hello.call(123) // [Number: 123]</span><br><span class="line">const myHello = hello.bind(&apos;my&apos;)</span><br><span class="line">myHello() // [String: &apos;my&apos;]</span><br></pre></td></tr></table></figure>
</li>
<li><p>this 是在運行時求值的，可以適用於任何 function，從不同 object 調用同一個 function 可以會有不同 this 的值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const obj = &#123;</span><br><span class="line">  value: 1,</span><br><span class="line">  hello: function() &#123;</span><br><span class="line">    console.log(this.value)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">obj.hello() // 1</span><br></pre></td></tr></table></figure>

<p>this 的值跟 作用域 跟 程式碼的位置 在哪裡完全無關，只跟<strong>「你如何呼叫」</strong>有關。</p>
<p>作用域的概念舉例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">var a = 10</span><br><span class="line">function test()&#123;</span><br><span class="line">  console.log(a)</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">const obj = &#123;</span><br><span class="line">  a: &apos;ojb&apos;,</span><br><span class="line">  hello: function() &#123;</span><br><span class="line">    test() // 10</span><br><span class="line">  &#125;,</span><br><span class="line">  hello2: function() &#123;</span><br><span class="line">    var a = 200</span><br><span class="line">    test() // 10</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">test() // 10</span><br><span class="line">obj.hello()  </span><br><span class="line">obj.hello2()</span><br></pre></td></tr></table></figure>

<p>無論我在哪裡，無論我怎麼呼叫test這個 function，他印出來的 a 永遠都會是全域變數的那個 a(// 10)，因為作用域就是這樣運作，test 在自己的作用域裡面找不到 a 於是往上一層找，而上一層就是 global scope，這跟你在哪裡呼叫 test 一點關係都沒有。test 這個 function 在宣告的時候就把 scope 給決定好了。</p>
<p>但 this 卻是完全相反，this 的值會根據你怎麼呼叫它而變得不一樣，例如使用 call、apply 跟 bind 可以用不同的方式去呼叫改變 this 的值。如果 function 是在物件下調用，那麼 this 則會指向此物件，無論 function 是在哪裡宣告；使用物件的方法調用時 this 會指向調用的物件。<strong>宣告的位置不重要，重要的是呼叫的方式。</strong></p>
</li>
</ul>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="https://wcc723.github.io/javascript/2017/12/12/javascript-this/" target="_blank" rel="noopener">JavaScript 的 this 到底是誰？</a><br><a href="https://blog.techbridge.cc/2019/02/23/javascript-this/" target="_blank" rel="noopener">淺談 JavaScript 頭號難題 this：絕對不完整，但保證好懂</a></p>
<h1 id="補充-在-React-中的-bind-this-用法"><a href="#補充-在-React-中的-bind-this-用法" class="headerlink" title="補充:在 React 中的 bind(this)用法"></a>補充:在 React 中的 bind(this)用法</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">import React from &apos;react&apos;;</span><br><span class="line"></span><br><span class="line">class App extends React.Component &#123;</span><br><span class="line">   constructor() &#123;</span><br><span class="line">      super();</span><br><span class="line">      this.state = &#123;</span><br><span class="line">         data: []</span><br><span class="line">      &#125;</span><br><span class="line">      this.setStateHandler = this.setStateHandler.bind(this);</span><br><span class="line">   &#125;;</span><br><span class="line"></span><br><span class="line">   setStateHandler() &#123;</span><br><span class="line">      var item = &quot;setState...&quot;</span><br><span class="line">      var myArray = this.state.data;</span><br><span class="line">      myArray.push(item)</span><br><span class="line">      this.setState(&#123;data: myArray&#125;)</span><br><span class="line">   &#125;;</span><br><span class="line"></span><br><span class="line">   render() &#123;</span><br><span class="line">      return (</span><br><span class="line">         &lt;div&gt;</span><br><span class="line">            &lt;button onClick = &#123;this.setStateHandler&#125;&gt;SET STATE&lt;/button&gt;</span><br><span class="line">            &lt;h4&gt;State Array: &#123;this.state.data&#125;&lt;/h4&gt;</span><br><span class="line">         &lt;/div&gt;</span><br><span class="line">      );</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default App;</span><br></pre></td></tr></table></figure>

<p><code>this.setStateHandler().bind(this)</code> sets the context for the function <code>setStateHandler()</code> to be the class object. This is necessary so that you could call <code>this.setState({...})</code> inside the method, because <code>setState()</code> is the method of React.Component. If you do not <code>.bind(this)</code> you would get an error that <code>setState()</code> method is undefined.</p>
<p><a href="https://stackoverflow.com/questions/42434232/what-is-the-usage-of-this-method-bindthis" target="_blank" rel="noopener">what is the usage of : this.method.bind(this)</a></p>
<p><a href="https://medium.com/reactmaker/react-%E8%88%87-bind-this-%E7%9A%84%E4%B8%80%E4%BA%9B%E5%BF%83%E5%BE%97-323c8d3d395d" target="_blank" rel="noopener">React 與 bind this 的一些心得</a><br>當使用 extend React.Component 的方式去宣告元件的時候，React 確實會綁定 this 到元件內，但是卻有以下特定的地方才會被綁進去生命周期函式，例如 componentDidMount 等等<br>render 內其他自己定義的 property 就不會被綁入 this ，而且 this 會被指到 windows 這個全域上。</p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="https://chinyun.github.io/myblog/myblog/2019/11/11/JS-prototype/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="chinyun">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/myblog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jinny's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/myblog/2019/11/11/JS-prototype/" class="post-title-link" itemprop="url">JS prototype</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-11-11 21:09:26" itemprop="dateCreated datePublished" datetime="2019-11-11T21:09:26+00:00">2019-11-11</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-11-21 12:25:02" itemprop="dateModified" datetime="2019-11-21T12:25:02+00:00">2019-11-21</time>
              </span>
            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>筆記 JavaScript 中非常重要的概念：繼承 inheritance、原型 prototype 和原型鍊 prototype chain。</p>
<h1 id="Object-oriented-programming-OOP-物件導向程式設計"><a href="#Object-oriented-programming-OOP-物件導向程式設計" class="headerlink" title="Object-oriented programming(OOP) 物件導向程式設計"></a>Object-oriented programming(OOP) 物件導向程式設計</h1><p>JavaScript 並不像 Java、C++ 這些典型的物件導向語言具有「類別」（class）來區分概念與實體（instance）或天生具有繼承的能力，而 JavaScript 只有「物件」，因此只能利用設計模式來模擬這些功能。在 JavaScript 世界中，到底是怎麼實現物件導向的概念的？ JavaScript 的物件透過原型 (Prototype) 機制相互繼承功能，與典型的物件導向程式語言相較，運作方式有所差異。<br>在討論 <strong>物件導向 JavaScript</strong> 之前，需要先知道物件導向程式設計的意義：OOP 基本概念是<strong>採用物件（objects）來模塑真實的實物世界</strong>；也就是在程式中透過 objects 來塑造模型，並提供簡單方式存取「難以或不可能採用的功能」，物件可裝載相關的資料與程式碼，資料部分是你塑造某個模型的資訊，而程式碼部分則用是操作行為(Method)實現。</p>
<p>為了簡化程式撰寫，我們可以為某個複雜東西建立簡單的模型，藉以代表其最重要的概念或特質，且該模型建立方式極易於搭配我們的程式設計用途：譬如<strong>用「類別」建立物件實體 Object instance — 該物件包含了類別中所定義的資料與功能</strong>。</p>
<p>在根據類別建立物件實體時，就是執行類別的「建構子 Constructor 函式」所建立，而這個「根據類別來建立物件實體」的過程即稱為「實體化 Instantiation」，物件實體就是從類別實體化而來。我們可根據某一個類別建立許多新的子類別，新的子類別可繼承 (Inherit) 其母類別的資料與程式碼特性。你可重複使用所有物件類型共有的功能，而不需再複製之。若功能需與類別有所差異，則可直接於其上定義特殊功能。</p>
<h1 id="inheritance-繼承"><a href="#inheritance-繼承" class="headerlink" title="inheritance 繼承"></a>inheritance 繼承</h1><p><strong>一個物件可以存取其他物件的屬性 properties、方法 methods，就叫做繼承 inheritance</strong>。<br>繼承可以分成兩種，一種是 classical inheritance 類別繼承，這種方式用在 C# 或 JAVA 當中；另一種則是 JavaScript 使用的 prototypal inheritance 原型繼承。<br>在「典型 OO」中，你必須定義特定的類別物件，才能定義哪些類別所要繼承的類別，而 JavaScript 使用不同的系統：「繼承」的物件並不會一併複製功能過來，而是<strong>透過原型鍊連接其所繼承的功能，亦即所謂的原型繼承 (Prototypal inheritance)</strong>。<br>基於 JavaScript 運作的方式 (原型鍊)，物件之間的功能共享一般稱為「委託 (Delegation)」，即特定物件將功能委託至通用物件類型。「委託」其實比繼承更精確一點。因為「所繼承的功能」並不會複製到「進行繼承的物件」之上，卻是保留在通用物件之中。</p>
<h1 id="Prototype原型-與-proto-＆-Prototype-的意義"><a href="#Prototype原型-與-proto-＆-Prototype-的意義" class="headerlink" title="Prototype原型 與 __proto__ ＆ [[Prototype]] 的意義"></a>Prototype原型 與 <code>__proto__</code> ＆ <code>[[Prototype]]</code> 的意義</h1><ul>
<li>Prototype原型</li>
</ul>
<p><strong>物件之間可以互相成為各自的 Prototype 原型，被繼承的物件將會繼承 父物件本身的屬性和方法 以及 它的 Prototype 的所有屬性</strong>，原型鍊上可追溯的物件都可以找到其屬性、方法。</p>
<p><strong>每個物件都有一個隱藏的內部屬性(internal property) <code>[[Prototype]]</code>，這個屬性指向一個物件，也就是繼承的物件；也可以說是該物件的原型</strong>。</p>
<p>所謂的原型繼承就是指繼承上一個物件的 prototype 屬性 (你也能稱之為 子命名空間 sub namespace) 中定義的成員，也就是以「<code>Object.prototype.</code>」開頭的屬性內容。<code>Object.prototype.</code> 屬性值就是一個物件，儲存了許多我們想「讓原型鍊上的物件一路繼承下去」的屬性與函式。</p>
<p><code>[[Prototype]]</code> 不允許外部存取，從 ES6 開始，[[Prototype]] 可以通過 <code>Object.getPrototypeOf()</code> 和 <code>Object.setPrototypeOf()</code> 訪問器來訪問，也可以使用物件屬性 <code>__proto__</code> 呼叫。</p>
<p><code>__proto__</code> 發音 dunder prototype，它原先並非標準但許多瀏覽器實現，最先被 Firefox 使用，後來在 ES6 被列為 Javascript 的標準內建屬性的。它的出現是為了解決讀寫 <code>Object.prototype</code> 的麻煩，提供一個快捷讀寫的 API，而且它是透過連結內部屬性 <code>[[Prototype]]</code> 完成這個功能。</p>
<p>舉例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function Person(name, age) &#123;</span><br><span class="line">  this.name = name;</span><br><span class="line">  this.age = age;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">Person.prototype.log = function () &#123;</span><br><span class="line">  console.log(this.name + &apos;, age:&apos; + this.age);</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">var nick = new Person(&apos;nick&apos;, 18);</span><br><span class="line">console.log(nick.__proto__ === Person.prototype) // true</span><br><span class="line">console.log(nick.__proto__ === Object.getPrototypeOf(nick)) // true</span><br><span class="line"></span><br><span class="line">var peter = new Person(&apos;peter&apos;, 20);</span><br><span class="line">console.log(nick.log === peter.log) // true</span><br></pre></td></tr></table></figure>

<p>使用 <code>__proto__</code> 屬性可以透過這個接口指向 class 的原型 也就是 <code>nick.__proto__</code> 會指向 <code>Person.prototype</code> 指向的物件；<code>Person.prototype</code> 指向 Person 的原型屬性。</p>
<p>上述範例中，當呼叫 <code>nick.log()</code> 的時候，nick 這個 instance 本身並沒有 log 這個 function，那 JavaScript 是怎麼找到這個 method 的？ 根據 JavaScript 的機制；nick 是 Person 的 instance，所以如果在 nick 本身找不到，它會試著從 <code>Person.prototype</code> 去找。可是，JavaScript 怎麼知道要到這邊去找？ 一定是 nick 跟 Person.prototype 會透過某種方式連接起來，才知道要往哪邊去找 log 這個 function，這個連接方式，就是原型鍊。</p>
<p>假如 JavaScript 在 <code>Person.prototype</code> 還是沒找到 log() method，會繼續依照這個規則，去看 <code>Person.prototype.__proto__</code> (指 Person 的原型物件的原型屬性)裡面有沒有 log() method。就這樣一直不斷找下去，直到找到某個東西的 <code>__proto__</code> 是 <code>null</code> 為止，就表示這邊是最上層了，而這一個不斷串起來的鍊，也就是原型鍊，透過原型鍊可以呼叫自己 parent class 的 method，達到繼承的功能。</p>
<h1 id="prototype-chain-原型鍊"><a href="#prototype-chain-原型鍊" class="headerlink" title="prototype chain 原型鍊"></a>prototype chain 原型鍊</h1><p>傳統的 OOP 在複製物件時，是先定義了類別，建立物件實例之後，將類型上定義的所有屬性與函式複製到此實例。<br><strong>但 JavaScript 不會複製這些屬性與函式，卻是在物件實例與其建構子之間設定連結 (原型鍊中的連結)，只要順著原型鍊就能在建構子之中找到屬性與函式</strong>。</p>
<p>新的物件 instance 透過建構子函式 <code>constructor()</code> 產生後，其核心將會透過原型鏈 Prototype chain 的機制傳遞；物件的原型可能也有自己的原型，透過由 prototype 定義的參照鏈連在一起，繼承了其上的函式與屬性。</p>
<p>這樣不斷繼承的過程，使物件可以使用其他物件的屬性和方法，所以精確來說的話，物件實例的屬性與函式都是透過物件的建構子函式所定義，並非物件實例本身：在 JavaScript 主控台中輸入 <code>Object.prototype.</code> 會看到 Object 的 prototype 屬性中所定義的許多函式，而繼承自 Object 的物件也能找到這些函式。只要試著尋找如 String、Date、Number、Array 等全域物件的原型上定義的函式與屬性，就會看到 JavaScript 中的其他原型鍊繼承範例。</p>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="https://zh.javascript.info/function-prototype" target="_blank" rel="noopener">javascript.info:function-prototype</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Inheritance_and_the_prototype_chain" target="_blank" rel="noopener">MDN Web Docs:继承与原型链</a></p>
<p><a href="https://pjchender.blogspot.com/2016/06/javascriptprototypeprototype.html" target="_blank" rel="noopener">了解 JavaScript 中，繼承 inheritance、原型 prototype 和原型鍊 prototype chain 的概念</a><br><a href="https://cythilya.github.io/2018/10/26/prototype/" target="_blank" rel="noopener">你懂 JavaScript 嗎？#19 原型（Prototype）</a><br><a href="https://blog.techbridge.cc/2017/04/22/javascript-prototype/" target="_blank" rel="noopener">該來理解 JavaScript 的原型鍊了</a><br><a href="https://medium.com/@peterchang_82818/javascripter-%E5%BF%85%E9%A0%88%E7%9F%A5%E9%81%93%E7%9A%84%E7%B9%BC%E6%89%BF%E5%9B%A0%E5%AD%90-prototype-prototype-proto-object-class-inheritace-nodejs-%E7%89%A9%E4%BB%B6-%E7%B9%BC%E6%89%BF-54102240a8b4" target="_blank" rel="noopener">Javascripter 必須知道的繼承 prototype, <code>[[prototype]]</code>, <code>__proto__</code></a></p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="https://chinyun.github.io/myblog/myblog/2019/11/11/JS-Class/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="chinyun">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/myblog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jinny's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/myblog/2019/11/11/JS-Class/" class="post-title-link" itemprop="url">JS Class</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-11-11 18:30:54" itemprop="dateCreated datePublished" datetime="2019-11-11T18:30:54+00:00">2019-11-11</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-11-21 12:25:02" itemprop="dateModified" datetime="2019-11-21T12:25:02+00:00">2019-11-21</time>
              </span>
            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="JavaScript-Class"><a href="#JavaScript-Class" class="headerlink" title="JavaScript Class"></a>JavaScript Class</h1><p>In Object-oriented programming, a class is an extensible program-code-template for creating objects, providing initial values for state(member variables) and implementations of behavior(member functions or methods).class 是一種可以拓展的編程模板，用來創建對象(object)，提供狀態初始值(變量)和行為實現(函數或方法)。</p>
<p>JavaScript 雖然具有物件導向程式語言的特性，但與 Java、C++ 等以類別為基礎的程式設計規範不同，JavaScript 是一種以原型(prototype-based)為基礎的語言。</p>
<p>由於開發上經常需要創建許多相似類型的對象，傳統的 JavaScript 寫法，可以用<strong>構造函數(Constructor)和 operator <code>new</code></strong> 來達成這個使用目的，但<strong>在 ES6 中有一個更進階的用法叫做 <code>Class</code></strong>。</p>
<p>ECMAScript 6 中引入了類別 (class) 作為 JavaScript 現有原型程式(prototype-based)繼承的語法糖。語法糖可以讓現有語法操作變得更容易。類別(class)語法並不是要引入新的物件導向繼承模型到 JavaScript 中，而是提供一個<strong>更簡潔的語法來建立物件和處理繼承</strong>。</p>
<p>Class 允許使用更簡潔的結構語法來定義 prototype-based 的類別。在 prototype-based 類別中，所有 methods 都存在 prototype 屬性中，藉以與其他延伸出去的類別共用，如此可以節省 memory 空間。<br>比較傳統原型繼承的寫法和使用 class 的寫法會發現；<strong>class 省略了 prototype chaining 並且整個 class 的宣告定義集中描述在 class 區塊內，幫助讀者了解這段程式的作用範圍，使 class 的目的更為清楚</strong>。</p>
<ul>
<li><p>Constructor 構造函數</p>
<ul>
<li>是一種常規函數，函數名稱首字必須大寫</li>
<li>創建時必須使用 <code>new</code> 來操作</li>
<li>需在 <code>prototype</code> 物件上定義方法</li>
<li>示範：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function User(name) &#123;</span><br><span class="line">  this.name = name;</span><br><span class="line">  this.isAdmin = false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">User.prototype.sayHi = function() &#123;</span><br><span class="line">  console.log(this.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let user = new User(&quot;Jack&quot;); // 創建一個 User Constructor</span><br><span class="line"></span><br><span class="line">alert(user.name); -&gt; Jack</span><br><span class="line">alert(user.isAdmin); -&gt; false</span><br><span class="line">user.sayHi() -&gt; Jack</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>當一個函數作為 <code>new User(...)</code>執行時，它執行以下步驟：</p>
<ol>
<li>一個新的空對像被創建並分配給 <code>this</code>。</li>
<li>函數體執行。通常它會修改 <code>this</code>，為其添加新的屬性。</li>
<li>返回 <code>this</code> 的值。<br>所以 <code>new User(&quot;Jack&quot;)</code> 的结果是相同的對象</li>
</ol>
</li>
<li><p>Class 用法與特色</p>
<ul>
<li><strong>使用 <code>constructor()</code> 建構子來定義初始狀態，而且創建時也必須使用 <code>new</code> 來操作</strong>。<br>建構子(constructor)方法是一個特別的方法，用來建立和初始化一個類別的物件，一個類別只能有一個建構子(constructor)。<br>Class 的 <code>constructor()</code>函數是默認的 method，即使沒有寫出來也會自動生成一個默認的空構造函數，並加入到 <code>class.prototype</code> 上。<br>class syntax：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class User &#123;</span><br><span class="line">  constructor(name) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  sayHi() &#123;</span><br><span class="line">    alert(this.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">let user = new User(&quot;John&quot;);</span><br><span class="line">user.sayHi();</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>此時 User.prototype 包括 <code>constructor</code> 和 <code>sayHi</code> 兩個 methods。</p>
<ul>
<li><p><strong>class expression</strong> 像一般 function 一樣，也可以寫作沒有名稱的表達式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">let User = class &#123;</span><br><span class="line">  sayHi() &#123;</span><br><span class="line">    alert(&quot;Hello&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function makeClass(phrase) &#123;</span><br><span class="line">  // 返回並宣告一個 class</span><br><span class="line">  return class &#123;  </span><br><span class="line">    sayHi() &#123;</span><br><span class="line">      alert(phrase);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">let User = makeClass(&quot;Hello&quot;);</span><br><span class="line"></span><br><span class="line">new User().sayHi(); // Hello</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>使用 <code>extends()</code> 以及 <code>super()</code> 來繼承父類的參數</strong>給子類。<br>關鍵字 extends 是在類別宣告或是類別敘述中建立子類別的方法。<br>若在子類別中有建構子(constructor)，要使用<code>this</code>前必須先呼叫<code>super()</code>函式：在子類別建構子中用關鍵字 super 來呼叫父類別的建構子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const createPersonClass = name =&gt; class extends User &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    super(name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>內部 method 之間不用逗號區分，與一般物件不同，可以避免我們描述二者時產生混淆</p>
</li>
<li><p>Class 結構中自動開啟了嚴格模式 (Use Strict)</p>
</li>
<li><p>Class 的宣告不會被 hoisting 提升到最高作用區，與函式宣告式不同，<strong>編譯器尚未抵達和執行 class 宣告之前無法建立或存取 class</strong>。</p>
</li>
<li><p>Just like literal objects, classes may include <code>getters/setters</code> computed properties etc. Protection and Control：確保內部才能修改或訪問資料，防止洩漏。</p>
</li>
</ul>
</li>
</ul>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="https://javascript.info/class" target="_blank" rel="noopener">javascript.info</a><br><a href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Classes" target="_blank" rel="noopener">mozilla.org - MDN Web Docs</a></p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
  </div>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/myblog/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/myblog/page/4/">4</a><a class="extend next" rel="next" href="/myblog/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>


          </div>
          

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">chinyun</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        
          <a href="/myblog/archives/">
        
          <span class="site-state-item-count">31</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
    
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">chinyun</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> v3.9.0</div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.4.1</div>
  <script src='https://unpkg.com/mermaid@7.1.2/dist/mermaid.min.js'></script>
  <script>
    if (window.mermaid) {
      mermaid.initialize("");
    }
  </script>

        












        
      </div>
    </footer>
  </div>

  
  <script src="/myblog/lib/anime.min.js?v=3.1.0"></script>
  <script src="/myblog/lib/velocity/velocity.min.js?v=1.2.1"></script>
  <script src="/myblog/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
<script src="/myblog/js/utils.js?v=7.4.1"></script><script src="/myblog/js/motion.js?v=7.4.1"></script>
<script src="/myblog/js/schemes/pisces.js?v=7.4.1"></script>
<script src="/myblog/js/next-boot.js?v=7.4.1"></script>



  

















<script>
if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.initialize({
      theme: 'forest',
      logLevel: 3,
      flowchart: { curve: 'linear' },
      gantt: { axisFormat: '%m/%d/%Y' },
      sequence: { actorMargin: 50 }
    });
  }, window.mermaid);
}
</script>




  

  

  

</body>
</html>
